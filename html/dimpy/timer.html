<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>dimpy.timer API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dimpy.timer</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from time import time as currtime
from datetime import datetime
try:
    from collections import OrderedDict
except ImportError:
    from .odict import odict as OrderedDict

__all__ = [&#39;Timer&#39;, &#39;TimerError&#39;]

class TimerError(Exception):
    &#34;&#34;&#34;Exception for errors in using the timer&#34;&#34;&#34;
    def __init__(self, msg=&#39;Error in using the timer&#39;):
        self.msg = msg
    def __str__(self):
        return self.msg

class Timer(object):
    &#34;&#34;&#34;
    Keeps track of the timing statistics for different parts of a code.

    This class uses a stack approach so that the last started timer must
    be the first ended timer.  This facillitates speed, removes the need
    to search for timer instances on each stop, and prevents bad programming.
    Routines are named internally based on the all timers in the stack.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initiallize a Timer instance.&#34;&#34;&#34;
        # Create a new ordered dictionary for logging times
        self._log = OrderedDict()
        # Initiallize the timer stack
        self._stack_long  = []
        self._stack_short = []

    def startTimer(self, routine, time=None, cpu=None, short=None):
        &#34;&#34;&#34;
        Starts a timer and adds it to the stack. &#39;group&#39; is used to group
        the timings together.  A place for this timer is created in the log.
        Returns the time stamp.
        &#34;&#34;&#34;
        # Use now if nothing was given
        if time is None:
            time = currtime()
        # Use the time for the cpu if not given
        if cpu is None:
            cpu = time
        # If the short name is not given, make it the same as the long
        if short is None:
            short = routine
        # Add this timer to the stack
        self._stack_short.append(short)
        self._stack_long.append(routine)
        # Create a name based on all the timers in the stack.
        name = &#39; =&gt; &#39;.join(self._stack_short)
        # Add to the log.
        try:
            # Assume that we&#39;ve already seen a timer of this name
            self._log[name][1].append(time)
        # Account for times when this name does not exist yet
        except KeyError:
            self._log[name] = [routine, [time], [cpu]]
        else:
            self._log[name][2].append(cpu)

        return datetime.fromtimestamp(time)

    def endTimer(self, routine, time=None, cpu=None):
        &#34;&#34;&#34;
        Ends a timer.  Checks that it is the last started timer in the
        stack, otherwise a ValueError is raised.  This is to ensure that
        the appropriate timer ordering is maintained.
        If everything checks out, the result is added to the log.
        Returns a tuple of the end time stamp and the elapsed time.
        &#34;&#34;&#34;
        # Use now if nothing was given
        if time is None:
            time = currtime()
        # Use time for cpu if not given
        if cpu is None:
            cpu = time
        # Create a name based on all the timers in the stack.
        name = &#39; =&gt; &#39;.join(self._stack_short)
        # Make sure the last timer is the one we want to stop
        if routine != self._stack_long[-1]:
            string = &#39;&#34;{0}&#34; is not the most recently started timer!&#39;
            raise TimerError (string.format(routine))
        # Removes last timer
        self._stack_long.pop()
        self._stack_short.pop()
        # Determie the total time, and add this to the log
        elapsed = time - self._log[name][1].pop()
        self._log[name][1].append(elapsed)
        cpu_elapsed = cpu - self._log[name][2].pop()
        self._log[name][2].append(cpu_elapsed)

        return datetime.fromtimestamp(time), elapsed

    def endAllTimers(self, leave=0):
        &#34;&#34;&#34;
        Ends all timers in the case of an emergency stop.
        leave indicates how many timers to keep running
        &#34;&#34;&#34;
        if leave &lt; 0:
            raise TimerError (&#39;leave parameter must be positive&#39;)
        # End all timers in reverse order using current time
        while len(self._stack_long) &gt; leave:
            self.endTimer(self._stack_long[-1])

    def dumpTimings(self, verbosity=0, out=print):
        &#34;&#34;&#34;
        Prints the timing statistics in a nice table.
        Verbosity level can be 0, 1, or 2.
        0 - Each routine is printed with # calls and total time spent
        1 - Divided into timing groups, with # calls and total time per group
        2 - Same as 1, but for each call the time is listed as well.

        out is a function that can be used to redirect output.
        By default the standard print function is used.
        &#34;&#34;&#34;
        if verbosity not in (0, 1, 2,):
            string = &#39;dumpTimings: Invalid verbosity level {0}&#39;
            raise TimerError (string.format(verbosity))
 
        # Print heading
        line = &#39;Timing Statistics&#39;
        dashes = &#39;=&#39;*len(line)
        out()
        out()
        out(dashes.center(79))
        out(line.center(79))
        out(dashes.center(79))
        out()

        f = &#39;  {0:&gt;14.3f}  {1:&gt;12.3f}  {2:&gt;7d}  {3:&lt;}&#39;
        # Verbosity level 0
        if verbosity == 0:
            routines = OrderedDict()

            # Sum up all timings from routines with same name from all groups
            for fullpath, (routine, times, cpu) in self._log.iteritems():
                r = routine[0].upper() + routine[1:]
                try:
                    routines[r][0] += sum(times)
                    routines[r][1] += sum(cpu)
                    routines[r][2] += len(times)
                except KeyError:
                    routines[r] = [sum(times), sum(cpu), len(times)]

            # Now print off the timings for the routines
            out(&#39;  Total Time (s)  CPU Time (s)  # Calls  Routine&#39;)
            out(&#39;  ----------------------------------------------&#39;)
            for r, times in routines.items():
                out(f.format(times[0], times[1], times[2], r))

        elif verbosity == 1: 
            out(&#39;  Total Time (s)  CPU Time (s)  # Calls  Routine&#39;)
            out(&#39;  ----------------------------------------------&#39;)
            # Loop over each timing group
            for fullpath, (routine, times, cpu) in self._log.iteritems():
                # Print off the total time spent in that routine
                out(f.format(sum(times), sum(cpu), len(times), fullpath))

        elif verbosity == 2:
            out(&#39;  Total Time (s)  CPU Time (s)   Call #  Routine&#39;)
            out(&#39;  ----------------------------------------------&#39;)
            # Loop over each timing group
            for fullpath, (routine, times, cpu) in self._log.iteritems():
                # Print off each time this routine was called
                for i, (t, c) in enumerate(zip(times, cpu)):
                    out(f.format(t, c, i+1, fullpath))

        # Leave a blank at end.
        out()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dimpy.timer.Timer"><code class="flex name class">
<span>class <span class="ident">Timer</span></span>
</code></dt>
<dd>
<div class="desc"><p>Keeps track of the timing statistics for different parts of a code.</p>
<p>This class uses a stack approach so that the last started timer must
be the first ended timer.
This facillitates speed, removes the need
to search for timer instances on each stop, and prevents bad programming.
Routines are named internally based on the all timers in the stack.</p>
<p>Initiallize a Timer instance.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Timer(object):
    &#34;&#34;&#34;
    Keeps track of the timing statistics for different parts of a code.

    This class uses a stack approach so that the last started timer must
    be the first ended timer.  This facillitates speed, removes the need
    to search for timer instances on each stop, and prevents bad programming.
    Routines are named internally based on the all timers in the stack.
    &#34;&#34;&#34;

    def __init__(self):
        &#34;&#34;&#34;Initiallize a Timer instance.&#34;&#34;&#34;
        # Create a new ordered dictionary for logging times
        self._log = OrderedDict()
        # Initiallize the timer stack
        self._stack_long  = []
        self._stack_short = []

    def startTimer(self, routine, time=None, cpu=None, short=None):
        &#34;&#34;&#34;
        Starts a timer and adds it to the stack. &#39;group&#39; is used to group
        the timings together.  A place for this timer is created in the log.
        Returns the time stamp.
        &#34;&#34;&#34;
        # Use now if nothing was given
        if time is None:
            time = currtime()
        # Use the time for the cpu if not given
        if cpu is None:
            cpu = time
        # If the short name is not given, make it the same as the long
        if short is None:
            short = routine
        # Add this timer to the stack
        self._stack_short.append(short)
        self._stack_long.append(routine)
        # Create a name based on all the timers in the stack.
        name = &#39; =&gt; &#39;.join(self._stack_short)
        # Add to the log.
        try:
            # Assume that we&#39;ve already seen a timer of this name
            self._log[name][1].append(time)
        # Account for times when this name does not exist yet
        except KeyError:
            self._log[name] = [routine, [time], [cpu]]
        else:
            self._log[name][2].append(cpu)

        return datetime.fromtimestamp(time)

    def endTimer(self, routine, time=None, cpu=None):
        &#34;&#34;&#34;
        Ends a timer.  Checks that it is the last started timer in the
        stack, otherwise a ValueError is raised.  This is to ensure that
        the appropriate timer ordering is maintained.
        If everything checks out, the result is added to the log.
        Returns a tuple of the end time stamp and the elapsed time.
        &#34;&#34;&#34;
        # Use now if nothing was given
        if time is None:
            time = currtime()
        # Use time for cpu if not given
        if cpu is None:
            cpu = time
        # Create a name based on all the timers in the stack.
        name = &#39; =&gt; &#39;.join(self._stack_short)
        # Make sure the last timer is the one we want to stop
        if routine != self._stack_long[-1]:
            string = &#39;&#34;{0}&#34; is not the most recently started timer!&#39;
            raise TimerError (string.format(routine))
        # Removes last timer
        self._stack_long.pop()
        self._stack_short.pop()
        # Determie the total time, and add this to the log
        elapsed = time - self._log[name][1].pop()
        self._log[name][1].append(elapsed)
        cpu_elapsed = cpu - self._log[name][2].pop()
        self._log[name][2].append(cpu_elapsed)

        return datetime.fromtimestamp(time), elapsed

    def endAllTimers(self, leave=0):
        &#34;&#34;&#34;
        Ends all timers in the case of an emergency stop.
        leave indicates how many timers to keep running
        &#34;&#34;&#34;
        if leave &lt; 0:
            raise TimerError (&#39;leave parameter must be positive&#39;)
        # End all timers in reverse order using current time
        while len(self._stack_long) &gt; leave:
            self.endTimer(self._stack_long[-1])

    def dumpTimings(self, verbosity=0, out=print):
        &#34;&#34;&#34;
        Prints the timing statistics in a nice table.
        Verbosity level can be 0, 1, or 2.
        0 - Each routine is printed with # calls and total time spent
        1 - Divided into timing groups, with # calls and total time per group
        2 - Same as 1, but for each call the time is listed as well.

        out is a function that can be used to redirect output.
        By default the standard print function is used.
        &#34;&#34;&#34;
        if verbosity not in (0, 1, 2,):
            string = &#39;dumpTimings: Invalid verbosity level {0}&#39;
            raise TimerError (string.format(verbosity))
 
        # Print heading
        line = &#39;Timing Statistics&#39;
        dashes = &#39;=&#39;*len(line)
        out()
        out()
        out(dashes.center(79))
        out(line.center(79))
        out(dashes.center(79))
        out()

        f = &#39;  {0:&gt;14.3f}  {1:&gt;12.3f}  {2:&gt;7d}  {3:&lt;}&#39;
        # Verbosity level 0
        if verbosity == 0:
            routines = OrderedDict()

            # Sum up all timings from routines with same name from all groups
            for fullpath, (routine, times, cpu) in self._log.iteritems():
                r = routine[0].upper() + routine[1:]
                try:
                    routines[r][0] += sum(times)
                    routines[r][1] += sum(cpu)
                    routines[r][2] += len(times)
                except KeyError:
                    routines[r] = [sum(times), sum(cpu), len(times)]

            # Now print off the timings for the routines
            out(&#39;  Total Time (s)  CPU Time (s)  # Calls  Routine&#39;)
            out(&#39;  ----------------------------------------------&#39;)
            for r, times in routines.items():
                out(f.format(times[0], times[1], times[2], r))

        elif verbosity == 1: 
            out(&#39;  Total Time (s)  CPU Time (s)  # Calls  Routine&#39;)
            out(&#39;  ----------------------------------------------&#39;)
            # Loop over each timing group
            for fullpath, (routine, times, cpu) in self._log.iteritems():
                # Print off the total time spent in that routine
                out(f.format(sum(times), sum(cpu), len(times), fullpath))

        elif verbosity == 2:
            out(&#39;  Total Time (s)  CPU Time (s)   Call #  Routine&#39;)
            out(&#39;  ----------------------------------------------&#39;)
            # Loop over each timing group
            for fullpath, (routine, times, cpu) in self._log.iteritems():
                # Print off each time this routine was called
                for i, (t, c) in enumerate(zip(times, cpu)):
                    out(f.format(t, c, i+1, fullpath))

        # Leave a blank at end.
        out()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="dimpy.timer.Timer.dumpTimings"><code class="name flex">
<span>def <span class="ident">dumpTimings</span></span>(<span>self, verbosity=0, out=&lt;built-in function print&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the timing statistics in a nice table.
Verbosity level can be 0, 1, or 2.
0 - Each routine is printed with # calls and total time spent
1 - Divided into timing groups, with # calls and total time per group
2 - Same as 1, but for each call the time is listed as well.</p>
<p>out is a function that can be used to redirect output.
By default the standard print function is used.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def dumpTimings(self, verbosity=0, out=print):
    &#34;&#34;&#34;
    Prints the timing statistics in a nice table.
    Verbosity level can be 0, 1, or 2.
    0 - Each routine is printed with # calls and total time spent
    1 - Divided into timing groups, with # calls and total time per group
    2 - Same as 1, but for each call the time is listed as well.

    out is a function that can be used to redirect output.
    By default the standard print function is used.
    &#34;&#34;&#34;
    if verbosity not in (0, 1, 2,):
        string = &#39;dumpTimings: Invalid verbosity level {0}&#39;
        raise TimerError (string.format(verbosity))

    # Print heading
    line = &#39;Timing Statistics&#39;
    dashes = &#39;=&#39;*len(line)
    out()
    out()
    out(dashes.center(79))
    out(line.center(79))
    out(dashes.center(79))
    out()

    f = &#39;  {0:&gt;14.3f}  {1:&gt;12.3f}  {2:&gt;7d}  {3:&lt;}&#39;
    # Verbosity level 0
    if verbosity == 0:
        routines = OrderedDict()

        # Sum up all timings from routines with same name from all groups
        for fullpath, (routine, times, cpu) in self._log.iteritems():
            r = routine[0].upper() + routine[1:]
            try:
                routines[r][0] += sum(times)
                routines[r][1] += sum(cpu)
                routines[r][2] += len(times)
            except KeyError:
                routines[r] = [sum(times), sum(cpu), len(times)]

        # Now print off the timings for the routines
        out(&#39;  Total Time (s)  CPU Time (s)  # Calls  Routine&#39;)
        out(&#39;  ----------------------------------------------&#39;)
        for r, times in routines.items():
            out(f.format(times[0], times[1], times[2], r))

    elif verbosity == 1: 
        out(&#39;  Total Time (s)  CPU Time (s)  # Calls  Routine&#39;)
        out(&#39;  ----------------------------------------------&#39;)
        # Loop over each timing group
        for fullpath, (routine, times, cpu) in self._log.iteritems():
            # Print off the total time spent in that routine
            out(f.format(sum(times), sum(cpu), len(times), fullpath))

    elif verbosity == 2:
        out(&#39;  Total Time (s)  CPU Time (s)   Call #  Routine&#39;)
        out(&#39;  ----------------------------------------------&#39;)
        # Loop over each timing group
        for fullpath, (routine, times, cpu) in self._log.iteritems():
            # Print off each time this routine was called
            for i, (t, c) in enumerate(zip(times, cpu)):
                out(f.format(t, c, i+1, fullpath))

    # Leave a blank at end.
    out()</code></pre>
</details>
</dd>
<dt id="dimpy.timer.Timer.endAllTimers"><code class="name flex">
<span>def <span class="ident">endAllTimers</span></span>(<span>self, leave=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Ends all timers in the case of an emergency stop.
leave indicates how many timers to keep running</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def endAllTimers(self, leave=0):
    &#34;&#34;&#34;
    Ends all timers in the case of an emergency stop.
    leave indicates how many timers to keep running
    &#34;&#34;&#34;
    if leave &lt; 0:
        raise TimerError (&#39;leave parameter must be positive&#39;)
    # End all timers in reverse order using current time
    while len(self._stack_long) &gt; leave:
        self.endTimer(self._stack_long[-1])</code></pre>
</details>
</dd>
<dt id="dimpy.timer.Timer.endTimer"><code class="name flex">
<span>def <span class="ident">endTimer</span></span>(<span>self, routine, time=None, cpu=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Ends a timer.
Checks that it is the last started timer in the
stack, otherwise a ValueError is raised.
This is to ensure that
the appropriate timer ordering is maintained.
If everything checks out, the result is added to the log.
Returns a tuple of the end time stamp and the elapsed time.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def endTimer(self, routine, time=None, cpu=None):
    &#34;&#34;&#34;
    Ends a timer.  Checks that it is the last started timer in the
    stack, otherwise a ValueError is raised.  This is to ensure that
    the appropriate timer ordering is maintained.
    If everything checks out, the result is added to the log.
    Returns a tuple of the end time stamp and the elapsed time.
    &#34;&#34;&#34;
    # Use now if nothing was given
    if time is None:
        time = currtime()
    # Use time for cpu if not given
    if cpu is None:
        cpu = time
    # Create a name based on all the timers in the stack.
    name = &#39; =&gt; &#39;.join(self._stack_short)
    # Make sure the last timer is the one we want to stop
    if routine != self._stack_long[-1]:
        string = &#39;&#34;{0}&#34; is not the most recently started timer!&#39;
        raise TimerError (string.format(routine))
    # Removes last timer
    self._stack_long.pop()
    self._stack_short.pop()
    # Determie the total time, and add this to the log
    elapsed = time - self._log[name][1].pop()
    self._log[name][1].append(elapsed)
    cpu_elapsed = cpu - self._log[name][2].pop()
    self._log[name][2].append(cpu_elapsed)

    return datetime.fromtimestamp(time), elapsed</code></pre>
</details>
</dd>
<dt id="dimpy.timer.Timer.startTimer"><code class="name flex">
<span>def <span class="ident">startTimer</span></span>(<span>self, routine, time=None, cpu=None, short=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Starts a timer and adds it to the stack. 'group' is used to group
the timings together.
A place for this timer is created in the log.
Returns the time stamp.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def startTimer(self, routine, time=None, cpu=None, short=None):
    &#34;&#34;&#34;
    Starts a timer and adds it to the stack. &#39;group&#39; is used to group
    the timings together.  A place for this timer is created in the log.
    Returns the time stamp.
    &#34;&#34;&#34;
    # Use now if nothing was given
    if time is None:
        time = currtime()
    # Use the time for the cpu if not given
    if cpu is None:
        cpu = time
    # If the short name is not given, make it the same as the long
    if short is None:
        short = routine
    # Add this timer to the stack
    self._stack_short.append(short)
    self._stack_long.append(routine)
    # Create a name based on all the timers in the stack.
    name = &#39; =&gt; &#39;.join(self._stack_short)
    # Add to the log.
    try:
        # Assume that we&#39;ve already seen a timer of this name
        self._log[name][1].append(time)
    # Account for times when this name does not exist yet
    except KeyError:
        self._log[name] = [routine, [time], [cpu]]
    else:
        self._log[name][2].append(cpu)

    return datetime.fromtimestamp(time)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dimpy.timer.TimerError"><code class="flex name class">
<span>class <span class="ident">TimerError</span></span>
<span>(</span><span>msg='Error in using the timer')</span>
</code></dt>
<dd>
<div class="desc"><p>Exception for errors in using the timer</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class TimerError(Exception):
    &#34;&#34;&#34;Exception for errors in using the timer&#34;&#34;&#34;
    def __init__(self, msg=&#39;Error in using the timer&#39;):
        self.msg = msg
    def __str__(self):
        return self.msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dimpy" href="index.html">dimpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dimpy.timer.Timer" href="#dimpy.timer.Timer">Timer</a></code></h4>
<ul class="">
<li><code><a title="dimpy.timer.Timer.dumpTimings" href="#dimpy.timer.Timer.dumpTimings">dumpTimings</a></code></li>
<li><code><a title="dimpy.timer.Timer.endAllTimers" href="#dimpy.timer.Timer.endAllTimers">endAllTimers</a></code></li>
<li><code><a title="dimpy.timer.Timer.endTimer" href="#dimpy.timer.Timer.endTimer">endTimer</a></code></li>
<li><code><a title="dimpy.timer.Timer.startTimer" href="#dimpy.timer.Timer.startTimer">startTimer</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dimpy.timer.TimerError" href="#dimpy.timer.TimerError">TimerError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>