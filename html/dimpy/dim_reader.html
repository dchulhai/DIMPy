<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>dimpy.dim_reader API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dimpy.dim_reader</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from input_reader import InputReader, abs_file_path, SUPPRESS
from .constants import EV2HART, NM2HART, HZ2HART, WAVENUM2HART, NOCONV, HART2NM
from os.path import isabs, dirname, join, abspath
from sys import exit
from .printer import error
#from math import pi
import numpy, math

__all__ = [&#39;DIMReader&#39;, &#39;SUPPRESS&#39;]

unitmap = {&#39;ev&#39;: EV2HART,
           &#39;nm&#39;: NM2HART,
           &#39;hz&#39;: HZ2HART,
           &#39;cm-1&#39;: WAVENUM2HART,
           &#39;hartree&#39;: NOCONV,
           &#39;au&#39;: NOCONV}


class DIMReader(InputReader):
    def __init__(self, **kwargs):
        &#34;&#34;&#34;Run the InputReader initializations&#34;&#34;&#34;
        super(DIMReader, self).__init__(**kwargs)

    def post_process(self, namespace):
        &#34;&#34;&#34;Post-process the input to be ready for use by FORTRAN&#34;&#34;&#34;

        self.set_print_rules_for_output(namespace)
        self.perform_sanity_checks(namespace)
        self.set_appropriate_numbers_from_input(namespace)
        self.collect_coordinates_and_atoms(namespace)
        self.format_frequency_range(namespace)
        self.format_parameters_for_each_element(namespace)

        # Keep the input file in the namespace
        namespace.add(&#39;input_file&#39;, self.input_file)

    def set_print_rules_for_output(self, namespace):
        &#34;&#34;&#34;Sets the print rules to use for the output file&#34;&#34;&#34;
        print_rules = set([])
        # The PRINTLEVEL macros set pre-defined printers
        if namespace.printlevel &gt;= 0:
            print_rules.update([&#39;pol&#39;, &#39;timing&#39;, &#39;input&#39;])
        if namespace.printlevel &gt;= 1:
            print_rules.update([&#39;coords&#39;, &#39;energy&#39;])
        if namespace.printlevel &gt;= 2:
            print_rules.add(&#39;atmdip&#39;)
        if namespace.printlevel &gt;= 3:
            print_rules.add(&#39;timingverbose&#39;)
            print_rules.discard(&#39;timing&#39;)

        # Make noprint a set so we can add to it
        if &#39;noprint&#39; in namespace:
            noprint = set(namespace.noprint)
        else:
            noprint = set([])

        # Add requested keys
        if &#39;print&#39; in namespace:
            for k in namespace.print:
                print_rules.add(k)
                # TIMING and TIMINGVERBOSE are mutually exclusive
                if k == &#39;timing&#39;:
                    noprint.update([&#39;timingverbose&#39;, &#39;timingveryverbose&#39;])
                if k == &#39;timingverbose&#39;:
                    noprint.update([&#39;timing&#39;, &#39;timingveryverbose&#39;])
                if k == &#39;timingveryverbose&#39;:
                    noprint.update([&#39;timing&#39;, &#39;timingverbose&#39;])

        # If TIMINGVERYVERBOSE is present, choose this over the others
        if &#39;timingveryverbose&#39; in print_rules:
            noprint.discard(&#39;timingveryverbose&#39;)
        # If TIMINGVERBOSE is present, choose it over TIMING
        elif &#39;timingverbose&#39; in print_rules:
            noprint.discard(&#39;timingverbose&#39;)

        # Remove keys not wanted
        for k in noprint:
            print_rules.discard(k)

        namespace.add(&#39;print_rules&#39;, print_rules)

    def perform_sanity_checks(self, namespace):
        &#34;&#34;&#34;Ensure that some variables that cannot appear together don&#39;t&#34;&#34;&#34;
        if namespace.nopol and namespace.nochar:
            exit(&#39;Using both NOPOL and NOCHAR makes no sense&#39;)
        if namespace.nopol and namespace.nocross:
            exit(&#39;Using both NOPOL and NOCROSS makes no sense&#39;)
        if namespace.nocross and namespace.nochar:
            exit(&#39;Using both NOCROSS and NOCHAR makes no sense&#39;)
        if namespace.totalcharge != 0:
            exit(&#39;Nonzero TOTCHARGE not yet implemented&#39;)
        if namespace.cpim and namespace.algorithm &gt; 0:
            exit(&#39;Iterative solver not implemented for CPIM&#39;)
        if namespace.direction and namespace.algorithm == 0:
            exit(&#34;Direct solver can&#39;t separate field directions&#34;)

    def set_appropriate_numbers_from_input(self, namespace):
        &#34;&#34;&#34;Some values in input can be string or integer.  Fortran will only
        accept the integer version.&#34;&#34;&#34;

        # Make sure the algorithm is a number.  If it is already a number,
        # an error will be raised and we don&#39;t do anything.
        try:
            namespace.algorithm = {&#39;DIRECT&#39;: 0,
                                   &#39;BRUTE&#39;: 1,
                                   &#39;SINGLE&#39;: 2,
                                   &#39;MULTI&#39;: 3}[namespace.algorithm.upper()]
        except AttributeError:
            pass

        # Default the algorithm if one was not specified
        if namespace.algorithm == -1:
            if namespace.cpim:
                namespace.algorithm = 0
            else:
                namespace.algorithm = 1

        # Set numbers to the preconditioner
        try:
            namespace.precon = {&#39;NONE&#39;: 101.0,
                                &#39;PERFECT&#39;: 0.0,
                                &#39;JACOBI&#39;: 99.0}[namespace.precon.upper()]
        except AttributeError:
            pass

        # Make sure the grid spacing is a number.  If it is already a number, an
        # error will be raised and we don&#39;t do anything.
        try:
            namespace.grid = {&#39;EXTRACOARSE&#39;: 3,
                              &#39;COARSE&#39;: 5,
                              &#39;MEDIUM&#39;: 7,
                              &#39;FINE&#39;: 9,
                              &#39;EXTRAFINE&#39;: 11}[namespace.grid.upper()]
        except AttributeError:
            pass
        dirs = [False, False, False]
        if namespace.direction:
            for k in namespace.direction:
                try:
                    i = {&#39;X&#39;: 0,
                         &#39;Y&#39;: 1,
                         &#39;Z&#39;: 2}[k.upper()]
                    dirs[i] = True        
                except KeyError:
                    error(&#39;Direction must be x, y, and/or z&#39;)
                    exit (&#39;Expected [X, Y, Z], got {0}&#39;.format(k))

                    
        else:
            dirs = [True, True, True]
        
        namespace.add(&#39;dirs&#39;, dirs)

    def collect_coordinates_and_atoms(self, namespace):
        &#34;&#34;&#34;Collect the coordinates from the input, either directly or from other file&#34;&#34;&#34;

        # Collect from a file
        if &#39;file&#39; in namespace.xyz:
            # Make sure the xyz file path absolute
            if isabs(namespace.xyz.file.group(1)):
                fname = namespace.xyz.file.group(1)
            else:
                if isinstance(self.filename, str):
                    fname = dirname(self.filename)
                    fname = join(fname, namespace.xyz.file.group(1))
                else:
                    fname = abspath(namespace.xyz.file.group(1))
            try:
                with open(fname) as fl:
                    xyzfile = [line.strip() for line in fl]
            except IOError:
                exit(&#39;Error reading file {0}&#39;.format(fname))
            else:
                try:
                    coords = [[float(x.split()[1]),
                               float(x.split()[2]),
                               float(x.split()[3])] for x in xyzfile[2:]]
                    names = [x.split()[0].capitalize() for x in xyzfile[2:]]
                except IndexError:
                    msg = &#39;Bad coordinate specification in file {0}.&#39;
                    exit(msg.format(fname))
                try:
                    natoms = int(xyzfile[0])
                except ValueError:
                    msg = &#39;Unable to read number of atoms in file {0}.&#39;
                    exit(msg.format(fname))
                if len(names) != natoms:
                    error(&#39;Number of atoms found does not match expected&#39;)
                    exit(&#39;Expected {0}, found {1}&#39;.format(natoms, len(names)))

        # Otherwise, collect from the block defined in the input
        else:
            names = [m.group(1).capitalize() for m in namespace.xyz.coords]
            coords = [[float(m.group(2)), float(m.group(3)), float(m.group(4))]
                      for m in namespace.xyz.coords]
            natoms = len(names)
            if &#39;natoms&#39; in namespace.xyz:
                namenatoms = int(namespace.xyz.natoms.group(1))
                if natoms != namenatoms:
                    error(&#39;Number of atoms found does not match expected&#39;)
                    exit(&#39;Expected {0}, found {1}&#39;.format(natoms, namenatoms))
        from numpy import array, argsort

        # Add the coordinates to the namespace
        namespace.add(&#39;natoms&#39;, natoms)
        namespace.add(&#39;atoms&#39;, names)
        namespace.add(&#39;coords&#39;, [[namespace.distconv(x) for x in c] for c in coords])
        namespace.add(&#39;elements&#39;, set(names))

    def format_frequency_range(self, namespace):
        &#34;&#34;&#34;Format the frequency range correctly&#34;&#34;&#34;

        freqs = []

        # Convert each given frequency
        if &#39;frequency&#39; in namespace:
            conv = unitmap[namespace.frequency[0]]
            for freq in namespace.frequency[1:]:
                freqs.append(conv(freq))

        # Expand the frequency range and convert appropriately
        elif &#39;freqrange&#39; in namespace:
            conv = unitmap[namespace.freqrange[0]]
            if namespace.freqrange[3] == 1:
                frequencies = [float(namespace.freqrange[1])]
            else:
                start, stop, num = namespace.freqrange[1:]
                step = (stop - start) / float(num - 1)
                frequencies = [y * step + start for y in xrange(num)]
                frequencies[-1] = stop
            for freq in frequencies:
                freqs.append(conv(freq))

        # No frequencies for static
        else:
            pass

        # Sort the frequencies in ascending order
        namespace.add(&#39;freqs&#39;, sorted(freqs))
        namespace.add(&#39;nfreq&#39;, len(freqs))



    def calculate_static_polarizability(self, elem, namespace, par, keyelem, keyrmin, keyrmax):
        &#34;&#34;&#34;Add a special static polarizability term&#34;&#34;&#34;
        import numpy as np

        def find_CN(rmn,rmin,rmax):
            if rmn &lt; rmin:
                return 1
            elif rmn &gt; rmax:
                return 0
            elif rmin &lt;= rmn &lt;= rmax:
                return 0.5*(1 + numpy.cos(numpy.pi*((rmn - rmin)/(rmax - rmin))))

        if namespace.cpim:
                par.add(&#39;static_pol&#39;, [par.pol, par.cap])
        elif par.coorddepend==True:
            coord = numpy.array(namespace.coords, dtype=&#39;float64&#39;)
            # save the index of coordination dependent atom in dependindex
            n=-1
            dependindex=[]
            for atomname in namespace.atoms:
                n = n + 1
                if atomname == elem:
                    dependindex.append(n)
            #print(&#34;dependindex: {0}&#34;.format(dependindex))

            # save the index of metal atom in metalindex
            metal = [&#39;Na&#39;, &#39;Mg&#39;, &#39;Al&#39;, &#39;Si&#39;, &#39;Ar&#39;, &#39;K&#39;,  &#39;Ca&#39;, &#39;Sc&#39;,&#39;Ti&#39;, &#39;V&#39;,  &#39;Cr&#39;,
                    &#39;Mn&#39;, &#39;Fe&#39;, &#39;Co&#39;, &#39;Ni&#39;, &#39;Cu&#39;, &#39;Zi&#39;, &#39;Ga&#39;, &#39;Ge&#39;,&#39;As&#39;, &#39;Se&#39;, &#39;Br&#39;,
                    &#39;Kr&#39;, &#39;Rb&#39;, &#39;Sr&#39;, &#39;Y&#39;,  &#39;Zr&#39;, &#39;Nb&#39;, &#39;Mo&#39;, &#39;Tc&#39;,&#39;Ru&#39;, &#39;Rh&#39;, &#39;Pd&#39;,
                    &#39;Ag&#39;, &#39;Cd&#39;, &#39;In&#39;, &#39;Sn&#39;, &#39;Sb&#39;, &#39;Te&#39;, &#39;Xe&#39;, &#39;Cs&#39;, &#39;Ba&#39;, &#39;La&#39;,&#39;Ce&#39;,
                    &#39;Pr&#39;, &#39;Nd&#39;, &#39;Pm&#39;, &#39;Sm&#39;, &#39;Eu&#39;, &#39;Gd&#39;, &#39;Tb&#39;,&#39;Dy&#39;, &#39;Ho&#39;, &#39;Er&#39;, &#39;Tm&#39;,
                    &#39;Yb&#39;, &#39;Lu&#39;, &#39;Hf&#39;, &#39;Ta&#39;, &#39;W&#39;,  &#39;Re&#39;, &#39;Os&#39;, &#39;Ir&#39;, &#39;Pt&#39;, &#39;Au&#39;, &#39;Hg&#39;,
                    &#39;Tl&#39;, &#39;Pb&#39;, &#39;Bi&#39;, &#39;Po&#39;, &#39;At&#39;, &#39;Rn&#39;, &#39;Fr&#39;,&#39;Ra&#39;, &#39;Ac&#39;, &#39;Th&#39;, &#39;Pa&#39;, &#39;U&#39;]
            n=-1
            metalindex=[]
            for atomname in namespace.atoms:
                n = n + 1
                if atomname in metal:
                    metalindex.append(n)
            #print(&#34;metalindex: {0}&#34;.format(metalindex))

            # calculate the coordination number between coordination dependent atom and metal atom
            dependcn=[]
            for i in range(len(dependindex)):
                CN = 0
                for j in range(len(metalindex)):
                    rv = coord[dependindex[i]]-coord[metalindex[j]]
                    rv = numpy.sqrt(numpy.dot(rv, rv))
                    CN += find_CN(rv, par.rmin, par.rmax)
                dependcn.append(CN)


            # save the index of the atom binding to the coordination dependent atom in keyindex
            keycn=[]
            g=[]
            if len(keyelem) != 0:
                n=-1
                keyindex = []
                romin = []
                romax = []
                for atomname in namespace.atoms:
                    n = n + 1
                    for i in xrange(len(keyelem)):
                        if atomname == keyelem[i]:
                            keyindex.append(n)
                            romin.append(keyrmin[i])
                            romax.append(keyrmax[i])

                for i in xrange(len(dependindex)):
                    CN = 0
                    for j in xrange(len(keyindex)):
                        rv = coord[dependindex[i]] - coord[keyindex[j]]
                        rv = numpy.sqrt(numpy.dot(rv, rv))
                        CN += find_CN(rv, romin[j], romax[j])
                    keycn.append(CN)
                    f = 1.0 - CN/namespace.gfactor
                    g.append(f)

            else:
                for i in xrange(len(dependcn)):
                    keycn.append(0.0)
                    g.append(1.0)

            # total coordination number of coordination dependent atom
            cn=[]
            for i in xrange(len(dependcn)):
                cn.append(keycn[i]+dependcn[i])

            # calculate coordination dependent parameters
            r=[]
            for i in xrange(len(cn)):
                a = par.rsurf + (( par.rbulk - par.rsurf )*( min( par.cnmax,cn[i] )/par.cnmax ))
                r.append(a)

            p = [( 6/numpy.pi ) * x**3 for x in r]
            par.add(&#39;cd_static_pol&#39;, p)
            par.add(&#39;cd_rad&#39;, r)

            d = [(( x - par.rbulk )/( par.rsurf - par.rbulk )) for x in r]
            # Plasmon parameter
            conv = unitmap[&#39;ev&#39;]
            a=[]
            aa=[]
            b=[]
            for x in d:
                aa.append((( 1 - x )*conv(par.drude[0])) +( x*(conv(par.wpin))))
                b.append((( 1 - x )*conv(par.drude[1])) +( x*(conv(par.sc))))
            for i in xrange(len(aa)):
                a.append(aa[i]*g[i])
#
            par.add(&#39;cd_drude&#39;,zip(a,b))
            #print(&#34;par.cd_drude {0}&#34;.format(par.cd_drude))
        else:
            rad = par.rad + (par.spillout / pow(namespace.natoms, 1 / 3))
            par.add(&#39;static_pol&#39;, (6 / math.pi) * rad ** 3)

       
    def format_parameters_for_each_element(self, namespace):
        &#34;&#34;&#34;Make sure that the parameters for each element are formatted correctly&#34;&#34;&#34;

        keyelem = []
        keyrmin = []
        keyrmax = []
        for elem in namespace.elements:
            par = self.get_parameters_for_element(elem, namespace)
            if par.binding == True:
                keyelem.append(elem)
                keyrmin.append(par.romin)
                keyrmax.append(par.romax)

        for elem in namespace.elements:
            par = self.get_parameters_for_element(elem, namespace)
            self.check_only_valid_parameters_appear_for_element(elem, namespace, par)
            self.check_that_valid_parameters_are_defined(elem, namespace, par)
            self.collect_experimental_dielectrics(namespace, par)
            self.zero_parameters_that_are_not_needed(par)
            par.rad = namespace.distconv(par.rad)  # Make sure radius is in Bohr
            par.rmin = namespace.distconv(par.rmin)
            par.rmax = namespace.distconv(par.rmax)
            par.rsurf = namespace.distconv(par.rsurf)
            par.rbulk = namespace.distconv(par.rbulk)
            self.calculate_static_polarizability(elem, namespace, par, keyelem, keyrmin, keyrmax)
#
            self.collect_drude_term(par)
            self.collect_and_format_lorentzian_terms(par)



    def get_parameters_for_element(self, elem, namespace):
        &#34;&#34;&#34;Get the parameters for the given element. If it doesn&#39;t exist, quit.&#34;&#34;&#34;
        if elem.lower() not in namespace:
            exit(&#39;Missing type information for element &#39; + elem)
        else:
            par = getattr(namespace, elem.lower())
        return par
    
    def zero_parameters_that_are_not_needed(self, par):
        &#34;&#34;&#34;Give zero value to parameters that weren&#39;t needed&#34;&#34;&#34;
        for p in (&#39;pol&#39;, &#39;cap&#39;, &#39;om1&#39;, &#39;om2&#39;, &#39;gm1&#39;, &#39;gm2&#39;, &#39;size&#39;):
            if p not in par:
                par.add(p, 0.0)

    def collect_experimental_dielectrics(self, namespace, par):
        &#34;&#34;&#34;Collect the experimental dielectric, or return all zeros if none&#34;&#34;&#34;
        try:
            par.exp = self.expdie(par.exp, namespace.freqs)
        except AttributeError:
            par.exp = self.expdie(&#39;&#39;, namespace.freqs)

    def loadtxt(self, filename):
        &#34;&#34;&#34;Loads text file as a list of floats., skipping comments
        Each column of data is a row in the returned data list.&#34;&#34;&#34;
        with open(filename) as fl:
            f = [x.strip().split() for x in fl if x[0] != &#39;#&#39;]
            # Now, reorganize from row x col ==&gt; col x row
        return [[float(nums[n]) for nums in f] for n in xrange(len(f[0]))]

    def expdie(self, name, freqs):
        &#34;&#34;&#34;Retrieves the experimental dielectric parameters for this type.
        If none were found, return complex zero&#39;s for each frequency&#34;&#34;&#34;
        from os.path import join, dirname, realpath
        from spline import spline, interpolate

        die = []
        if name:
            try:
                expdata = self.loadtxt(name)
            except IOError:
                # If not found as given, look in the DIM library
                dn = dirname(realpath(__file__))
                try:
                    p = join(dn, &#39;dielectrics&#39;, name)
                    expdata = self.loadtxt(p)
                except IOError:
                    exit(&#39;Cannot find dielectric file for &#39; + name)

            # Spline the data
            realknots = spline(expdata[0], expdata[1])
            imagknots = spline(expdata[0], expdata[2])
            # For each frequency, interpolate
            for om in freqs:
                real = interpolate(expdata[0], expdata[1], realknots, HART2NM(om))
                imag = interpolate(expdata[0], expdata[2], imagknots, HART2NM(om))
                die.append(complex(real, imag))
        else:
            die = [complex(0.0) for i in xrange(len(freqs))]

        return die

    def check_only_valid_parameters_appear_for_element(self, elem, namespace, par):
        &#34;&#34;&#34;Make sure that only valid parameters appear for the given element.&#34;&#34;&#34;

        invalid = {
            &#39;CPIM&#39;: [&#39;lrtz&#39;, &#39;lrtz1&#39;, &#39;lrtz2&#39;, &#39;lrtz3&#39;, &#39;drude&#39;, &#39;exp&#39;],
            &#39;DIE&#39;: [&#39;pol&#39;, &#39;cap&#39;, &#39;om1&#39;, &#39;om2&#39;, &#39;gm1&#39;, &#39;gm2&#39;, &#39;size&#39;],
            &#39;POL&#39;: [&#39;drude&#39;, &#39;lrtz1&#39;, &#39;lrtz2&#39;, &#39;lrtz3&#39;, &#39;exp&#39;]}
        invalid[&#39;POL&#39;] += invalid[&#39;DIE&#39;]

        msg = &#39;{0} is not a valid parameter {1} ({2})&#39;
        if namespace.cpim:
            for p in invalid[&#39;CPIM&#39;]:
                if p in par:
                    exit(msg.format(p, &#39;for CPIM&#39;, elem))
            if par.dielectric:
                exit(&#39;Dielectric parameters not valid for CPIM&#39;)
            else:
                par.polarizability = True
        else:
            # Default to dielectric if polarizability is not given
            par.dielectric = not par.polarizability
            t = &#39;dielectric&#39; if par.dielectric else &#39;polarizability&#39;
            k = &#39;DIE&#39; if par.dielectric else &#39;POL&#39;
            for p in invalid[k]:
                if p in par:
                    exit(msg.format(p, &#39;for a {0} for PIM&#39;.format(t), elem))

    def check_that_valid_parameters_are_defined(self, elem, namespace, par):
        &#34;&#34;&#34;Ensure that valid parameters for the elements are defined (if required).
        If they are not defined but a default is implemented, choose the default.&#34;&#34;&#34;

        # These experimental dielectric values have defaults
        default_experimental_dielectrics_defined = set(
            [&#39;Ag&#39;, &#39;Al&#39;, &#39;Au&#39;, &#39;Be&#39;, &#39;Co&#39;, &#39;Cr&#39;, &#39;Cu&#39;, &#39;Ir&#39;, &#39;K&#39;, &#39;Li&#39;, &#39;Mo&#39;, &#39;Na&#39;,
             &#39;Nb&#39;, &#39;Ni&#39;, &#39;Os&#39;, &#39;Pd&#39;, &#39;Pt&#39;, &#39;Rh&#39;, &#39;Si&#39;, &#39;Ta&#39;, &#39;V&#39;, &#39;W&#39;, ])
        valid_parameters = {
            &#39;CPIM&#39;: {&#39;NOFREQ&#39;: (&#39;pol&#39;, &#39;cap&#39;,),
                     &#39;FREQ&#39;: (&#39;pol&#39;, &#39;cap&#39;, &#39;om1&#39;, &#39;om2&#39;, &#39;gm1&#39;, &#39;gm2&#39;, &#39;size&#39;)},
            &#39;PIM&#39;: {&#39;NOFREQ&#39;: tuple(),
                    &#39;FREQ&#39;: (&#39;exp&#39;,) if par.dielectric else (&#39;lrtz&#39;,)}}
        cpim_defaults = {
            &#39;Ag&#39;: {&#39;pol&#39;: 49.9843, &#39;cap&#39;: 2.7529, &#39;om1&#39;: 0.0747, &#39;om2&#39;: 0.0545,
                   &#39;gm1&#39;: 0.0604, &#39;gm2&#39;: 0.0261, &#39;size&#39;: 2.7759, },
            &#39;Au&#39;: {&#39;pol&#39;: 39.5297, &#39;cap&#39;: 1.2159, }}

        typ = &#39;CPIM&#39; if namespace.cpim else &#39;PIM&#39;
        ftyp = &#39;FREQ&#39; if namespace.nfreq else &#39;NOFREQ&#39;

        # Loop over the valid parameters, assigning defaults if needed
        msg = &#39;No default {0} for {1} found for element {2}&#39;
        for p in valid_parameters[typ][ftyp]:
            if p not in par:
                # Default CPIM parameters if not given
                if namespace.cpim:
                    try:
                        value = cpim_defaults[elem][p]
                    except KeyError:
                        exit(msg.format(&#39;value&#39;, p, elem))

                # Default PIM parameter if not given
                
                    # Experimental dielectric default
                    if (par.dielectric and
                        &#39;drude&#39; not in par and &#39;lrtz&#39;  not in par and
                        &#39;lrtz1&#39; not in par and &#39;lrtz2&#39; not in par and
                        &#39;lrtz3&#39; not in par):
                        if elem in default_experimental_dielectrics_defined:
                            value = elem
                        else:
                            exit(msg.format(&#39;dielectric&#39;, p, elem))

                    # Polarizability needs some lorentzians
                    elif not par.dielectric and &#39;lrtz&#39; not in par:
                        exit(msg.format(&#39;polarizability&#39;, p, elem))

                    # No default, but parameter not required
                    else:
                        continue

                # Add the default to the parameters since it does not exist
                par.add(p, value)

    def collect_drude_term(self, par):
        &#34;&#34;&#34;Puts the drude terms in the correct format, returning -1 if not given&#34;&#34;&#34;
        if &#39;drude&#39; in par:
            conv = unitmap[par.drude[2]]
            #print(par.drude)
            par.drude = [conv(par.drude[0]), conv(par.drude[1])]
        else:
            par.add(&#39;drude&#39;, [-1.0, -1.0])
      
    def collect_and_format_lorentzian_terms(self, par):
        &#34;&#34;&#34;Convert Lorentzian units and make them unified.  This is different
        for polarizability and dielectric parameters types.&#34;&#34;&#34;

        def extract_data_for_lrtz(lrtz_type, counter, par, osc, om, res, pls, unit):
            for l in getattr(par, lrtz_type):
                c = unitmap[l[unit]]
                o = l[osc] if osc &gt;= 0 else 1.0
                w = c(l[om]) if om &gt;= 0 else 1.0
                try:
                    par.lrtz[counter] = [o, w, c(l[res]), c(l[pls])]
                except IndexError:
                    exit(&#39;The maximum number of lorentzians is 50&#39;)
                counter += 1
            par.remove(lrtz_type)
            return counter

        # First, convert lrtz to lrtz1
        if &#39;lrtz&#39; in par:
            if &#39;q+=1lrtz1&#39; not in par:
                par.add(&#39;lrtz1&#39;, [])
            else:
                par.lrtz1 = list(par.lrtz1)
            for l in par.lrtz:
                par.lrtz1.append(l)
            par.remove(&#39;lrtz&#39;)
            # Init lrtz to -1 for all values
        par.add(&#39;lrtz&#39;, [[-1.0, -1.0, -1.0, -1.0] for i in xrange(50)])

        counter = 0
        # Dielectric
        if par.dielectric:
            # lrtz1 uses res for res and pls
            if &#39;lrtz1&#39; in par:
                counter = extract_data_for_lrtz(&#39;lrtz1&#39;, counter, par, 0, 1, 1, 2, 3)

            # lrtz2 uses all parameters
            if &#39;lrtz2&#39; in par:
                counter = extract_data_for_lrtz(&#39;lrtz2&#39;, counter, par, 0, 1, 2, 3, 4)

            # lrtz3 has no osc
            if &#39;lrtz3&#39; in par:
                extract_data_for_lrtz(&#39;lrtz3&#39;, counter, par, -1, 0, 1, 2, 3)

        # For polarizability
        else:
            # polarizability lorentzian has no om
            if &#39;lrtz1&#39; in par:
                extract_data_for_lrtz(&#39;lrtz1&#39;, counter, par, 0, -1, 1, 2, 3)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dimpy.dim_reader.DIMReader"><code class="flex name class">
<span>class <span class="ident">DIMReader</span></span>
<span>(</span><span>**kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>:py:class:<code>InputReader</code> is a class that is designed to read in
an input file and return the information contained based on rules
supplied to the class using a syntax similar to what is used in
the :py:mod:<code>argparse</code> module in the Python standard library.</p>
<p>:py:class:<code>InputReader</code> accepts blocks-type, line-type and
boolean-type keys, mutually exclusive groups, required keys,
defaults, and more.</p>
<p>:keyword comment:
Defines what is a comment in the input block.
This can be a single string or a list of strings.
The default is :py:const:<code>['#']</code>.
Optional.
:type comment: str or list
:keyword case:
Tells if the keys are case-sensitive or not.
The default is :py:obj:<code>False</code>.
Optional.
:type case: bool
:keyword ignoreunknown:
Ignore keys that are not defined.
The default is
:py:obj:<code>False</code>.
Optional
:type ignoreunknown: bool
:keyword default:
The default default that will be given when a
key is created without a default.
Optional</p>
<p>Run the InputReader initializations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DIMReader(InputReader):
    def __init__(self, **kwargs):
        &#34;&#34;&#34;Run the InputReader initializations&#34;&#34;&#34;
        super(DIMReader, self).__init__(**kwargs)

    def post_process(self, namespace):
        &#34;&#34;&#34;Post-process the input to be ready for use by FORTRAN&#34;&#34;&#34;

        self.set_print_rules_for_output(namespace)
        self.perform_sanity_checks(namespace)
        self.set_appropriate_numbers_from_input(namespace)
        self.collect_coordinates_and_atoms(namespace)
        self.format_frequency_range(namespace)
        self.format_parameters_for_each_element(namespace)

        # Keep the input file in the namespace
        namespace.add(&#39;input_file&#39;, self.input_file)

    def set_print_rules_for_output(self, namespace):
        &#34;&#34;&#34;Sets the print rules to use for the output file&#34;&#34;&#34;
        print_rules = set([])
        # The PRINTLEVEL macros set pre-defined printers
        if namespace.printlevel &gt;= 0:
            print_rules.update([&#39;pol&#39;, &#39;timing&#39;, &#39;input&#39;])
        if namespace.printlevel &gt;= 1:
            print_rules.update([&#39;coords&#39;, &#39;energy&#39;])
        if namespace.printlevel &gt;= 2:
            print_rules.add(&#39;atmdip&#39;)
        if namespace.printlevel &gt;= 3:
            print_rules.add(&#39;timingverbose&#39;)
            print_rules.discard(&#39;timing&#39;)

        # Make noprint a set so we can add to it
        if &#39;noprint&#39; in namespace:
            noprint = set(namespace.noprint)
        else:
            noprint = set([])

        # Add requested keys
        if &#39;print&#39; in namespace:
            for k in namespace.print:
                print_rules.add(k)
                # TIMING and TIMINGVERBOSE are mutually exclusive
                if k == &#39;timing&#39;:
                    noprint.update([&#39;timingverbose&#39;, &#39;timingveryverbose&#39;])
                if k == &#39;timingverbose&#39;:
                    noprint.update([&#39;timing&#39;, &#39;timingveryverbose&#39;])
                if k == &#39;timingveryverbose&#39;:
                    noprint.update([&#39;timing&#39;, &#39;timingverbose&#39;])

        # If TIMINGVERYVERBOSE is present, choose this over the others
        if &#39;timingveryverbose&#39; in print_rules:
            noprint.discard(&#39;timingveryverbose&#39;)
        # If TIMINGVERBOSE is present, choose it over TIMING
        elif &#39;timingverbose&#39; in print_rules:
            noprint.discard(&#39;timingverbose&#39;)

        # Remove keys not wanted
        for k in noprint:
            print_rules.discard(k)

        namespace.add(&#39;print_rules&#39;, print_rules)

    def perform_sanity_checks(self, namespace):
        &#34;&#34;&#34;Ensure that some variables that cannot appear together don&#39;t&#34;&#34;&#34;
        if namespace.nopol and namespace.nochar:
            exit(&#39;Using both NOPOL and NOCHAR makes no sense&#39;)
        if namespace.nopol and namespace.nocross:
            exit(&#39;Using both NOPOL and NOCROSS makes no sense&#39;)
        if namespace.nocross and namespace.nochar:
            exit(&#39;Using both NOCROSS and NOCHAR makes no sense&#39;)
        if namespace.totalcharge != 0:
            exit(&#39;Nonzero TOTCHARGE not yet implemented&#39;)
        if namespace.cpim and namespace.algorithm &gt; 0:
            exit(&#39;Iterative solver not implemented for CPIM&#39;)
        if namespace.direction and namespace.algorithm == 0:
            exit(&#34;Direct solver can&#39;t separate field directions&#34;)

    def set_appropriate_numbers_from_input(self, namespace):
        &#34;&#34;&#34;Some values in input can be string or integer.  Fortran will only
        accept the integer version.&#34;&#34;&#34;

        # Make sure the algorithm is a number.  If it is already a number,
        # an error will be raised and we don&#39;t do anything.
        try:
            namespace.algorithm = {&#39;DIRECT&#39;: 0,
                                   &#39;BRUTE&#39;: 1,
                                   &#39;SINGLE&#39;: 2,
                                   &#39;MULTI&#39;: 3}[namespace.algorithm.upper()]
        except AttributeError:
            pass

        # Default the algorithm if one was not specified
        if namespace.algorithm == -1:
            if namespace.cpim:
                namespace.algorithm = 0
            else:
                namespace.algorithm = 1

        # Set numbers to the preconditioner
        try:
            namespace.precon = {&#39;NONE&#39;: 101.0,
                                &#39;PERFECT&#39;: 0.0,
                                &#39;JACOBI&#39;: 99.0}[namespace.precon.upper()]
        except AttributeError:
            pass

        # Make sure the grid spacing is a number.  If it is already a number, an
        # error will be raised and we don&#39;t do anything.
        try:
            namespace.grid = {&#39;EXTRACOARSE&#39;: 3,
                              &#39;COARSE&#39;: 5,
                              &#39;MEDIUM&#39;: 7,
                              &#39;FINE&#39;: 9,
                              &#39;EXTRAFINE&#39;: 11}[namespace.grid.upper()]
        except AttributeError:
            pass
        dirs = [False, False, False]
        if namespace.direction:
            for k in namespace.direction:
                try:
                    i = {&#39;X&#39;: 0,
                         &#39;Y&#39;: 1,
                         &#39;Z&#39;: 2}[k.upper()]
                    dirs[i] = True        
                except KeyError:
                    error(&#39;Direction must be x, y, and/or z&#39;)
                    exit (&#39;Expected [X, Y, Z], got {0}&#39;.format(k))

                    
        else:
            dirs = [True, True, True]
        
        namespace.add(&#39;dirs&#39;, dirs)

    def collect_coordinates_and_atoms(self, namespace):
        &#34;&#34;&#34;Collect the coordinates from the input, either directly or from other file&#34;&#34;&#34;

        # Collect from a file
        if &#39;file&#39; in namespace.xyz:
            # Make sure the xyz file path absolute
            if isabs(namespace.xyz.file.group(1)):
                fname = namespace.xyz.file.group(1)
            else:
                if isinstance(self.filename, str):
                    fname = dirname(self.filename)
                    fname = join(fname, namespace.xyz.file.group(1))
                else:
                    fname = abspath(namespace.xyz.file.group(1))
            try:
                with open(fname) as fl:
                    xyzfile = [line.strip() for line in fl]
            except IOError:
                exit(&#39;Error reading file {0}&#39;.format(fname))
            else:
                try:
                    coords = [[float(x.split()[1]),
                               float(x.split()[2]),
                               float(x.split()[3])] for x in xyzfile[2:]]
                    names = [x.split()[0].capitalize() for x in xyzfile[2:]]
                except IndexError:
                    msg = &#39;Bad coordinate specification in file {0}.&#39;
                    exit(msg.format(fname))
                try:
                    natoms = int(xyzfile[0])
                except ValueError:
                    msg = &#39;Unable to read number of atoms in file {0}.&#39;
                    exit(msg.format(fname))
                if len(names) != natoms:
                    error(&#39;Number of atoms found does not match expected&#39;)
                    exit(&#39;Expected {0}, found {1}&#39;.format(natoms, len(names)))

        # Otherwise, collect from the block defined in the input
        else:
            names = [m.group(1).capitalize() for m in namespace.xyz.coords]
            coords = [[float(m.group(2)), float(m.group(3)), float(m.group(4))]
                      for m in namespace.xyz.coords]
            natoms = len(names)
            if &#39;natoms&#39; in namespace.xyz:
                namenatoms = int(namespace.xyz.natoms.group(1))
                if natoms != namenatoms:
                    error(&#39;Number of atoms found does not match expected&#39;)
                    exit(&#39;Expected {0}, found {1}&#39;.format(natoms, namenatoms))
        from numpy import array, argsort

        # Add the coordinates to the namespace
        namespace.add(&#39;natoms&#39;, natoms)
        namespace.add(&#39;atoms&#39;, names)
        namespace.add(&#39;coords&#39;, [[namespace.distconv(x) for x in c] for c in coords])
        namespace.add(&#39;elements&#39;, set(names))

    def format_frequency_range(self, namespace):
        &#34;&#34;&#34;Format the frequency range correctly&#34;&#34;&#34;

        freqs = []

        # Convert each given frequency
        if &#39;frequency&#39; in namespace:
            conv = unitmap[namespace.frequency[0]]
            for freq in namespace.frequency[1:]:
                freqs.append(conv(freq))

        # Expand the frequency range and convert appropriately
        elif &#39;freqrange&#39; in namespace:
            conv = unitmap[namespace.freqrange[0]]
            if namespace.freqrange[3] == 1:
                frequencies = [float(namespace.freqrange[1])]
            else:
                start, stop, num = namespace.freqrange[1:]
                step = (stop - start) / float(num - 1)
                frequencies = [y * step + start for y in xrange(num)]
                frequencies[-1] = stop
            for freq in frequencies:
                freqs.append(conv(freq))

        # No frequencies for static
        else:
            pass

        # Sort the frequencies in ascending order
        namespace.add(&#39;freqs&#39;, sorted(freqs))
        namespace.add(&#39;nfreq&#39;, len(freqs))



    def calculate_static_polarizability(self, elem, namespace, par, keyelem, keyrmin, keyrmax):
        &#34;&#34;&#34;Add a special static polarizability term&#34;&#34;&#34;
        import numpy as np

        def find_CN(rmn,rmin,rmax):
            if rmn &lt; rmin:
                return 1
            elif rmn &gt; rmax:
                return 0
            elif rmin &lt;= rmn &lt;= rmax:
                return 0.5*(1 + numpy.cos(numpy.pi*((rmn - rmin)/(rmax - rmin))))

        if namespace.cpim:
                par.add(&#39;static_pol&#39;, [par.pol, par.cap])
        elif par.coorddepend==True:
            coord = numpy.array(namespace.coords, dtype=&#39;float64&#39;)
            # save the index of coordination dependent atom in dependindex
            n=-1
            dependindex=[]
            for atomname in namespace.atoms:
                n = n + 1
                if atomname == elem:
                    dependindex.append(n)
            #print(&#34;dependindex: {0}&#34;.format(dependindex))

            # save the index of metal atom in metalindex
            metal = [&#39;Na&#39;, &#39;Mg&#39;, &#39;Al&#39;, &#39;Si&#39;, &#39;Ar&#39;, &#39;K&#39;,  &#39;Ca&#39;, &#39;Sc&#39;,&#39;Ti&#39;, &#39;V&#39;,  &#39;Cr&#39;,
                    &#39;Mn&#39;, &#39;Fe&#39;, &#39;Co&#39;, &#39;Ni&#39;, &#39;Cu&#39;, &#39;Zi&#39;, &#39;Ga&#39;, &#39;Ge&#39;,&#39;As&#39;, &#39;Se&#39;, &#39;Br&#39;,
                    &#39;Kr&#39;, &#39;Rb&#39;, &#39;Sr&#39;, &#39;Y&#39;,  &#39;Zr&#39;, &#39;Nb&#39;, &#39;Mo&#39;, &#39;Tc&#39;,&#39;Ru&#39;, &#39;Rh&#39;, &#39;Pd&#39;,
                    &#39;Ag&#39;, &#39;Cd&#39;, &#39;In&#39;, &#39;Sn&#39;, &#39;Sb&#39;, &#39;Te&#39;, &#39;Xe&#39;, &#39;Cs&#39;, &#39;Ba&#39;, &#39;La&#39;,&#39;Ce&#39;,
                    &#39;Pr&#39;, &#39;Nd&#39;, &#39;Pm&#39;, &#39;Sm&#39;, &#39;Eu&#39;, &#39;Gd&#39;, &#39;Tb&#39;,&#39;Dy&#39;, &#39;Ho&#39;, &#39;Er&#39;, &#39;Tm&#39;,
                    &#39;Yb&#39;, &#39;Lu&#39;, &#39;Hf&#39;, &#39;Ta&#39;, &#39;W&#39;,  &#39;Re&#39;, &#39;Os&#39;, &#39;Ir&#39;, &#39;Pt&#39;, &#39;Au&#39;, &#39;Hg&#39;,
                    &#39;Tl&#39;, &#39;Pb&#39;, &#39;Bi&#39;, &#39;Po&#39;, &#39;At&#39;, &#39;Rn&#39;, &#39;Fr&#39;,&#39;Ra&#39;, &#39;Ac&#39;, &#39;Th&#39;, &#39;Pa&#39;, &#39;U&#39;]
            n=-1
            metalindex=[]
            for atomname in namespace.atoms:
                n = n + 1
                if atomname in metal:
                    metalindex.append(n)
            #print(&#34;metalindex: {0}&#34;.format(metalindex))

            # calculate the coordination number between coordination dependent atom and metal atom
            dependcn=[]
            for i in range(len(dependindex)):
                CN = 0
                for j in range(len(metalindex)):
                    rv = coord[dependindex[i]]-coord[metalindex[j]]
                    rv = numpy.sqrt(numpy.dot(rv, rv))
                    CN += find_CN(rv, par.rmin, par.rmax)
                dependcn.append(CN)


            # save the index of the atom binding to the coordination dependent atom in keyindex
            keycn=[]
            g=[]
            if len(keyelem) != 0:
                n=-1
                keyindex = []
                romin = []
                romax = []
                for atomname in namespace.atoms:
                    n = n + 1
                    for i in xrange(len(keyelem)):
                        if atomname == keyelem[i]:
                            keyindex.append(n)
                            romin.append(keyrmin[i])
                            romax.append(keyrmax[i])

                for i in xrange(len(dependindex)):
                    CN = 0
                    for j in xrange(len(keyindex)):
                        rv = coord[dependindex[i]] - coord[keyindex[j]]
                        rv = numpy.sqrt(numpy.dot(rv, rv))
                        CN += find_CN(rv, romin[j], romax[j])
                    keycn.append(CN)
                    f = 1.0 - CN/namespace.gfactor
                    g.append(f)

            else:
                for i in xrange(len(dependcn)):
                    keycn.append(0.0)
                    g.append(1.0)

            # total coordination number of coordination dependent atom
            cn=[]
            for i in xrange(len(dependcn)):
                cn.append(keycn[i]+dependcn[i])

            # calculate coordination dependent parameters
            r=[]
            for i in xrange(len(cn)):
                a = par.rsurf + (( par.rbulk - par.rsurf )*( min( par.cnmax,cn[i] )/par.cnmax ))
                r.append(a)

            p = [( 6/numpy.pi ) * x**3 for x in r]
            par.add(&#39;cd_static_pol&#39;, p)
            par.add(&#39;cd_rad&#39;, r)

            d = [(( x - par.rbulk )/( par.rsurf - par.rbulk )) for x in r]
            # Plasmon parameter
            conv = unitmap[&#39;ev&#39;]
            a=[]
            aa=[]
            b=[]
            for x in d:
                aa.append((( 1 - x )*conv(par.drude[0])) +( x*(conv(par.wpin))))
                b.append((( 1 - x )*conv(par.drude[1])) +( x*(conv(par.sc))))
            for i in xrange(len(aa)):
                a.append(aa[i]*g[i])
#
            par.add(&#39;cd_drude&#39;,zip(a,b))
            #print(&#34;par.cd_drude {0}&#34;.format(par.cd_drude))
        else:
            rad = par.rad + (par.spillout / pow(namespace.natoms, 1 / 3))
            par.add(&#39;static_pol&#39;, (6 / math.pi) * rad ** 3)

       
    def format_parameters_for_each_element(self, namespace):
        &#34;&#34;&#34;Make sure that the parameters for each element are formatted correctly&#34;&#34;&#34;

        keyelem = []
        keyrmin = []
        keyrmax = []
        for elem in namespace.elements:
            par = self.get_parameters_for_element(elem, namespace)
            if par.binding == True:
                keyelem.append(elem)
                keyrmin.append(par.romin)
                keyrmax.append(par.romax)

        for elem in namespace.elements:
            par = self.get_parameters_for_element(elem, namespace)
            self.check_only_valid_parameters_appear_for_element(elem, namespace, par)
            self.check_that_valid_parameters_are_defined(elem, namespace, par)
            self.collect_experimental_dielectrics(namespace, par)
            self.zero_parameters_that_are_not_needed(par)
            par.rad = namespace.distconv(par.rad)  # Make sure radius is in Bohr
            par.rmin = namespace.distconv(par.rmin)
            par.rmax = namespace.distconv(par.rmax)
            par.rsurf = namespace.distconv(par.rsurf)
            par.rbulk = namespace.distconv(par.rbulk)
            self.calculate_static_polarizability(elem, namespace, par, keyelem, keyrmin, keyrmax)
#
            self.collect_drude_term(par)
            self.collect_and_format_lorentzian_terms(par)



    def get_parameters_for_element(self, elem, namespace):
        &#34;&#34;&#34;Get the parameters for the given element. If it doesn&#39;t exist, quit.&#34;&#34;&#34;
        if elem.lower() not in namespace:
            exit(&#39;Missing type information for element &#39; + elem)
        else:
            par = getattr(namespace, elem.lower())
        return par
    
    def zero_parameters_that_are_not_needed(self, par):
        &#34;&#34;&#34;Give zero value to parameters that weren&#39;t needed&#34;&#34;&#34;
        for p in (&#39;pol&#39;, &#39;cap&#39;, &#39;om1&#39;, &#39;om2&#39;, &#39;gm1&#39;, &#39;gm2&#39;, &#39;size&#39;):
            if p not in par:
                par.add(p, 0.0)

    def collect_experimental_dielectrics(self, namespace, par):
        &#34;&#34;&#34;Collect the experimental dielectric, or return all zeros if none&#34;&#34;&#34;
        try:
            par.exp = self.expdie(par.exp, namespace.freqs)
        except AttributeError:
            par.exp = self.expdie(&#39;&#39;, namespace.freqs)

    def loadtxt(self, filename):
        &#34;&#34;&#34;Loads text file as a list of floats., skipping comments
        Each column of data is a row in the returned data list.&#34;&#34;&#34;
        with open(filename) as fl:
            f = [x.strip().split() for x in fl if x[0] != &#39;#&#39;]
            # Now, reorganize from row x col ==&gt; col x row
        return [[float(nums[n]) for nums in f] for n in xrange(len(f[0]))]

    def expdie(self, name, freqs):
        &#34;&#34;&#34;Retrieves the experimental dielectric parameters for this type.
        If none were found, return complex zero&#39;s for each frequency&#34;&#34;&#34;
        from os.path import join, dirname, realpath
        from spline import spline, interpolate

        die = []
        if name:
            try:
                expdata = self.loadtxt(name)
            except IOError:
                # If not found as given, look in the DIM library
                dn = dirname(realpath(__file__))
                try:
                    p = join(dn, &#39;dielectrics&#39;, name)
                    expdata = self.loadtxt(p)
                except IOError:
                    exit(&#39;Cannot find dielectric file for &#39; + name)

            # Spline the data
            realknots = spline(expdata[0], expdata[1])
            imagknots = spline(expdata[0], expdata[2])
            # For each frequency, interpolate
            for om in freqs:
                real = interpolate(expdata[0], expdata[1], realknots, HART2NM(om))
                imag = interpolate(expdata[0], expdata[2], imagknots, HART2NM(om))
                die.append(complex(real, imag))
        else:
            die = [complex(0.0) for i in xrange(len(freqs))]

        return die

    def check_only_valid_parameters_appear_for_element(self, elem, namespace, par):
        &#34;&#34;&#34;Make sure that only valid parameters appear for the given element.&#34;&#34;&#34;

        invalid = {
            &#39;CPIM&#39;: [&#39;lrtz&#39;, &#39;lrtz1&#39;, &#39;lrtz2&#39;, &#39;lrtz3&#39;, &#39;drude&#39;, &#39;exp&#39;],
            &#39;DIE&#39;: [&#39;pol&#39;, &#39;cap&#39;, &#39;om1&#39;, &#39;om2&#39;, &#39;gm1&#39;, &#39;gm2&#39;, &#39;size&#39;],
            &#39;POL&#39;: [&#39;drude&#39;, &#39;lrtz1&#39;, &#39;lrtz2&#39;, &#39;lrtz3&#39;, &#39;exp&#39;]}
        invalid[&#39;POL&#39;] += invalid[&#39;DIE&#39;]

        msg = &#39;{0} is not a valid parameter {1} ({2})&#39;
        if namespace.cpim:
            for p in invalid[&#39;CPIM&#39;]:
                if p in par:
                    exit(msg.format(p, &#39;for CPIM&#39;, elem))
            if par.dielectric:
                exit(&#39;Dielectric parameters not valid for CPIM&#39;)
            else:
                par.polarizability = True
        else:
            # Default to dielectric if polarizability is not given
            par.dielectric = not par.polarizability
            t = &#39;dielectric&#39; if par.dielectric else &#39;polarizability&#39;
            k = &#39;DIE&#39; if par.dielectric else &#39;POL&#39;
            for p in invalid[k]:
                if p in par:
                    exit(msg.format(p, &#39;for a {0} for PIM&#39;.format(t), elem))

    def check_that_valid_parameters_are_defined(self, elem, namespace, par):
        &#34;&#34;&#34;Ensure that valid parameters for the elements are defined (if required).
        If they are not defined but a default is implemented, choose the default.&#34;&#34;&#34;

        # These experimental dielectric values have defaults
        default_experimental_dielectrics_defined = set(
            [&#39;Ag&#39;, &#39;Al&#39;, &#39;Au&#39;, &#39;Be&#39;, &#39;Co&#39;, &#39;Cr&#39;, &#39;Cu&#39;, &#39;Ir&#39;, &#39;K&#39;, &#39;Li&#39;, &#39;Mo&#39;, &#39;Na&#39;,
             &#39;Nb&#39;, &#39;Ni&#39;, &#39;Os&#39;, &#39;Pd&#39;, &#39;Pt&#39;, &#39;Rh&#39;, &#39;Si&#39;, &#39;Ta&#39;, &#39;V&#39;, &#39;W&#39;, ])
        valid_parameters = {
            &#39;CPIM&#39;: {&#39;NOFREQ&#39;: (&#39;pol&#39;, &#39;cap&#39;,),
                     &#39;FREQ&#39;: (&#39;pol&#39;, &#39;cap&#39;, &#39;om1&#39;, &#39;om2&#39;, &#39;gm1&#39;, &#39;gm2&#39;, &#39;size&#39;)},
            &#39;PIM&#39;: {&#39;NOFREQ&#39;: tuple(),
                    &#39;FREQ&#39;: (&#39;exp&#39;,) if par.dielectric else (&#39;lrtz&#39;,)}}
        cpim_defaults = {
            &#39;Ag&#39;: {&#39;pol&#39;: 49.9843, &#39;cap&#39;: 2.7529, &#39;om1&#39;: 0.0747, &#39;om2&#39;: 0.0545,
                   &#39;gm1&#39;: 0.0604, &#39;gm2&#39;: 0.0261, &#39;size&#39;: 2.7759, },
            &#39;Au&#39;: {&#39;pol&#39;: 39.5297, &#39;cap&#39;: 1.2159, }}

        typ = &#39;CPIM&#39; if namespace.cpim else &#39;PIM&#39;
        ftyp = &#39;FREQ&#39; if namespace.nfreq else &#39;NOFREQ&#39;

        # Loop over the valid parameters, assigning defaults if needed
        msg = &#39;No default {0} for {1} found for element {2}&#39;
        for p in valid_parameters[typ][ftyp]:
            if p not in par:
                # Default CPIM parameters if not given
                if namespace.cpim:
                    try:
                        value = cpim_defaults[elem][p]
                    except KeyError:
                        exit(msg.format(&#39;value&#39;, p, elem))

                # Default PIM parameter if not given
                
                    # Experimental dielectric default
                    if (par.dielectric and
                        &#39;drude&#39; not in par and &#39;lrtz&#39;  not in par and
                        &#39;lrtz1&#39; not in par and &#39;lrtz2&#39; not in par and
                        &#39;lrtz3&#39; not in par):
                        if elem in default_experimental_dielectrics_defined:
                            value = elem
                        else:
                            exit(msg.format(&#39;dielectric&#39;, p, elem))

                    # Polarizability needs some lorentzians
                    elif not par.dielectric and &#39;lrtz&#39; not in par:
                        exit(msg.format(&#39;polarizability&#39;, p, elem))

                    # No default, but parameter not required
                    else:
                        continue

                # Add the default to the parameters since it does not exist
                par.add(p, value)

    def collect_drude_term(self, par):
        &#34;&#34;&#34;Puts the drude terms in the correct format, returning -1 if not given&#34;&#34;&#34;
        if &#39;drude&#39; in par:
            conv = unitmap[par.drude[2]]
            #print(par.drude)
            par.drude = [conv(par.drude[0]), conv(par.drude[1])]
        else:
            par.add(&#39;drude&#39;, [-1.0, -1.0])
      
    def collect_and_format_lorentzian_terms(self, par):
        &#34;&#34;&#34;Convert Lorentzian units and make them unified.  This is different
        for polarizability and dielectric parameters types.&#34;&#34;&#34;

        def extract_data_for_lrtz(lrtz_type, counter, par, osc, om, res, pls, unit):
            for l in getattr(par, lrtz_type):
                c = unitmap[l[unit]]
                o = l[osc] if osc &gt;= 0 else 1.0
                w = c(l[om]) if om &gt;= 0 else 1.0
                try:
                    par.lrtz[counter] = [o, w, c(l[res]), c(l[pls])]
                except IndexError:
                    exit(&#39;The maximum number of lorentzians is 50&#39;)
                counter += 1
            par.remove(lrtz_type)
            return counter

        # First, convert lrtz to lrtz1
        if &#39;lrtz&#39; in par:
            if &#39;q+=1lrtz1&#39; not in par:
                par.add(&#39;lrtz1&#39;, [])
            else:
                par.lrtz1 = list(par.lrtz1)
            for l in par.lrtz:
                par.lrtz1.append(l)
            par.remove(&#39;lrtz&#39;)
            # Init lrtz to -1 for all values
        par.add(&#39;lrtz&#39;, [[-1.0, -1.0, -1.0, -1.0] for i in xrange(50)])

        counter = 0
        # Dielectric
        if par.dielectric:
            # lrtz1 uses res for res and pls
            if &#39;lrtz1&#39; in par:
                counter = extract_data_for_lrtz(&#39;lrtz1&#39;, counter, par, 0, 1, 1, 2, 3)

            # lrtz2 uses all parameters
            if &#39;lrtz2&#39; in par:
                counter = extract_data_for_lrtz(&#39;lrtz2&#39;, counter, par, 0, 1, 2, 3, 4)

            # lrtz3 has no osc
            if &#39;lrtz3&#39; in par:
                extract_data_for_lrtz(&#39;lrtz3&#39;, counter, par, -1, 0, 1, 2, 3)

        # For polarizability
        else:
            # polarizability lorentzian has no om
            if &#39;lrtz1&#39; in par:
                extract_data_for_lrtz(&#39;lrtz1&#39;, counter, par, 0, -1, 1, 2, 3)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>input_reader.input_reader.InputReader</li>
<li>input_reader.key_adder._KeyAdder</li>
<li>input_reader.keylevel._KeyLevel</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dimpy.dim_reader.DIMReader.calculate_static_polarizability"><code class="name flex">
<span>def <span class="ident">calculate_static_polarizability</span></span>(<span>self, elem, namespace, par, keyelem, keyrmin, keyrmax)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a special static polarizability term</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def calculate_static_polarizability(self, elem, namespace, par, keyelem, keyrmin, keyrmax):
        &#34;&#34;&#34;Add a special static polarizability term&#34;&#34;&#34;
        import numpy as np

        def find_CN(rmn,rmin,rmax):
            if rmn &lt; rmin:
                return 1
            elif rmn &gt; rmax:
                return 0
            elif rmin &lt;= rmn &lt;= rmax:
                return 0.5*(1 + numpy.cos(numpy.pi*((rmn - rmin)/(rmax - rmin))))

        if namespace.cpim:
                par.add(&#39;static_pol&#39;, [par.pol, par.cap])
        elif par.coorddepend==True:
            coord = numpy.array(namespace.coords, dtype=&#39;float64&#39;)
            # save the index of coordination dependent atom in dependindex
            n=-1
            dependindex=[]
            for atomname in namespace.atoms:
                n = n + 1
                if atomname == elem:
                    dependindex.append(n)
            #print(&#34;dependindex: {0}&#34;.format(dependindex))

            # save the index of metal atom in metalindex
            metal = [&#39;Na&#39;, &#39;Mg&#39;, &#39;Al&#39;, &#39;Si&#39;, &#39;Ar&#39;, &#39;K&#39;,  &#39;Ca&#39;, &#39;Sc&#39;,&#39;Ti&#39;, &#39;V&#39;,  &#39;Cr&#39;,
                    &#39;Mn&#39;, &#39;Fe&#39;, &#39;Co&#39;, &#39;Ni&#39;, &#39;Cu&#39;, &#39;Zi&#39;, &#39;Ga&#39;, &#39;Ge&#39;,&#39;As&#39;, &#39;Se&#39;, &#39;Br&#39;,
                    &#39;Kr&#39;, &#39;Rb&#39;, &#39;Sr&#39;, &#39;Y&#39;,  &#39;Zr&#39;, &#39;Nb&#39;, &#39;Mo&#39;, &#39;Tc&#39;,&#39;Ru&#39;, &#39;Rh&#39;, &#39;Pd&#39;,
                    &#39;Ag&#39;, &#39;Cd&#39;, &#39;In&#39;, &#39;Sn&#39;, &#39;Sb&#39;, &#39;Te&#39;, &#39;Xe&#39;, &#39;Cs&#39;, &#39;Ba&#39;, &#39;La&#39;,&#39;Ce&#39;,
                    &#39;Pr&#39;, &#39;Nd&#39;, &#39;Pm&#39;, &#39;Sm&#39;, &#39;Eu&#39;, &#39;Gd&#39;, &#39;Tb&#39;,&#39;Dy&#39;, &#39;Ho&#39;, &#39;Er&#39;, &#39;Tm&#39;,
                    &#39;Yb&#39;, &#39;Lu&#39;, &#39;Hf&#39;, &#39;Ta&#39;, &#39;W&#39;,  &#39;Re&#39;, &#39;Os&#39;, &#39;Ir&#39;, &#39;Pt&#39;, &#39;Au&#39;, &#39;Hg&#39;,
                    &#39;Tl&#39;, &#39;Pb&#39;, &#39;Bi&#39;, &#39;Po&#39;, &#39;At&#39;, &#39;Rn&#39;, &#39;Fr&#39;,&#39;Ra&#39;, &#39;Ac&#39;, &#39;Th&#39;, &#39;Pa&#39;, &#39;U&#39;]
            n=-1
            metalindex=[]
            for atomname in namespace.atoms:
                n = n + 1
                if atomname in metal:
                    metalindex.append(n)
            #print(&#34;metalindex: {0}&#34;.format(metalindex))

            # calculate the coordination number between coordination dependent atom and metal atom
            dependcn=[]
            for i in range(len(dependindex)):
                CN = 0
                for j in range(len(metalindex)):
                    rv = coord[dependindex[i]]-coord[metalindex[j]]
                    rv = numpy.sqrt(numpy.dot(rv, rv))
                    CN += find_CN(rv, par.rmin, par.rmax)
                dependcn.append(CN)


            # save the index of the atom binding to the coordination dependent atom in keyindex
            keycn=[]
            g=[]
            if len(keyelem) != 0:
                n=-1
                keyindex = []
                romin = []
                romax = []
                for atomname in namespace.atoms:
                    n = n + 1
                    for i in xrange(len(keyelem)):
                        if atomname == keyelem[i]:
                            keyindex.append(n)
                            romin.append(keyrmin[i])
                            romax.append(keyrmax[i])

                for i in xrange(len(dependindex)):
                    CN = 0
                    for j in xrange(len(keyindex)):
                        rv = coord[dependindex[i]] - coord[keyindex[j]]
                        rv = numpy.sqrt(numpy.dot(rv, rv))
                        CN += find_CN(rv, romin[j], romax[j])
                    keycn.append(CN)
                    f = 1.0 - CN/namespace.gfactor
                    g.append(f)

            else:
                for i in xrange(len(dependcn)):
                    keycn.append(0.0)
                    g.append(1.0)

            # total coordination number of coordination dependent atom
            cn=[]
            for i in xrange(len(dependcn)):
                cn.append(keycn[i]+dependcn[i])

            # calculate coordination dependent parameters
            r=[]
            for i in xrange(len(cn)):
                a = par.rsurf + (( par.rbulk - par.rsurf )*( min( par.cnmax,cn[i] )/par.cnmax ))
                r.append(a)

            p = [( 6/numpy.pi ) * x**3 for x in r]
            par.add(&#39;cd_static_pol&#39;, p)
            par.add(&#39;cd_rad&#39;, r)

            d = [(( x - par.rbulk )/( par.rsurf - par.rbulk )) for x in r]
            # Plasmon parameter
            conv = unitmap[&#39;ev&#39;]
            a=[]
            aa=[]
            b=[]
            for x in d:
                aa.append((( 1 - x )*conv(par.drude[0])) +( x*(conv(par.wpin))))
                b.append((( 1 - x )*conv(par.drude[1])) +( x*(conv(par.sc))))
            for i in xrange(len(aa)):
                a.append(aa[i]*g[i])
#
            par.add(&#39;cd_drude&#39;,zip(a,b))
            #print(&#34;par.cd_drude {0}&#34;.format(par.cd_drude))
        else:
            rad = par.rad + (par.spillout / pow(namespace.natoms, 1 / 3))
            par.add(&#39;static_pol&#39;, (6 / math.pi) * rad ** 3)</code></pre>
</details>
</dd>
<dt id="dimpy.dim_reader.DIMReader.check_only_valid_parameters_appear_for_element"><code class="name flex">
<span>def <span class="ident">check_only_valid_parameters_appear_for_element</span></span>(<span>self, elem, namespace, par)</span>
</code></dt>
<dd>
<div class="desc"><p>Make sure that only valid parameters appear for the given element.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_only_valid_parameters_appear_for_element(self, elem, namespace, par):
    &#34;&#34;&#34;Make sure that only valid parameters appear for the given element.&#34;&#34;&#34;

    invalid = {
        &#39;CPIM&#39;: [&#39;lrtz&#39;, &#39;lrtz1&#39;, &#39;lrtz2&#39;, &#39;lrtz3&#39;, &#39;drude&#39;, &#39;exp&#39;],
        &#39;DIE&#39;: [&#39;pol&#39;, &#39;cap&#39;, &#39;om1&#39;, &#39;om2&#39;, &#39;gm1&#39;, &#39;gm2&#39;, &#39;size&#39;],
        &#39;POL&#39;: [&#39;drude&#39;, &#39;lrtz1&#39;, &#39;lrtz2&#39;, &#39;lrtz3&#39;, &#39;exp&#39;]}
    invalid[&#39;POL&#39;] += invalid[&#39;DIE&#39;]

    msg = &#39;{0} is not a valid parameter {1} ({2})&#39;
    if namespace.cpim:
        for p in invalid[&#39;CPIM&#39;]:
            if p in par:
                exit(msg.format(p, &#39;for CPIM&#39;, elem))
        if par.dielectric:
            exit(&#39;Dielectric parameters not valid for CPIM&#39;)
        else:
            par.polarizability = True
    else:
        # Default to dielectric if polarizability is not given
        par.dielectric = not par.polarizability
        t = &#39;dielectric&#39; if par.dielectric else &#39;polarizability&#39;
        k = &#39;DIE&#39; if par.dielectric else &#39;POL&#39;
        for p in invalid[k]:
            if p in par:
                exit(msg.format(p, &#39;for a {0} for PIM&#39;.format(t), elem))</code></pre>
</details>
</dd>
<dt id="dimpy.dim_reader.DIMReader.check_that_valid_parameters_are_defined"><code class="name flex">
<span>def <span class="ident">check_that_valid_parameters_are_defined</span></span>(<span>self, elem, namespace, par)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure that valid parameters for the elements are defined (if required).
If they are not defined but a default is implemented, choose the default.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_that_valid_parameters_are_defined(self, elem, namespace, par):
    &#34;&#34;&#34;Ensure that valid parameters for the elements are defined (if required).
    If they are not defined but a default is implemented, choose the default.&#34;&#34;&#34;

    # These experimental dielectric values have defaults
    default_experimental_dielectrics_defined = set(
        [&#39;Ag&#39;, &#39;Al&#39;, &#39;Au&#39;, &#39;Be&#39;, &#39;Co&#39;, &#39;Cr&#39;, &#39;Cu&#39;, &#39;Ir&#39;, &#39;K&#39;, &#39;Li&#39;, &#39;Mo&#39;, &#39;Na&#39;,
         &#39;Nb&#39;, &#39;Ni&#39;, &#39;Os&#39;, &#39;Pd&#39;, &#39;Pt&#39;, &#39;Rh&#39;, &#39;Si&#39;, &#39;Ta&#39;, &#39;V&#39;, &#39;W&#39;, ])
    valid_parameters = {
        &#39;CPIM&#39;: {&#39;NOFREQ&#39;: (&#39;pol&#39;, &#39;cap&#39;,),
                 &#39;FREQ&#39;: (&#39;pol&#39;, &#39;cap&#39;, &#39;om1&#39;, &#39;om2&#39;, &#39;gm1&#39;, &#39;gm2&#39;, &#39;size&#39;)},
        &#39;PIM&#39;: {&#39;NOFREQ&#39;: tuple(),
                &#39;FREQ&#39;: (&#39;exp&#39;,) if par.dielectric else (&#39;lrtz&#39;,)}}
    cpim_defaults = {
        &#39;Ag&#39;: {&#39;pol&#39;: 49.9843, &#39;cap&#39;: 2.7529, &#39;om1&#39;: 0.0747, &#39;om2&#39;: 0.0545,
               &#39;gm1&#39;: 0.0604, &#39;gm2&#39;: 0.0261, &#39;size&#39;: 2.7759, },
        &#39;Au&#39;: {&#39;pol&#39;: 39.5297, &#39;cap&#39;: 1.2159, }}

    typ = &#39;CPIM&#39; if namespace.cpim else &#39;PIM&#39;
    ftyp = &#39;FREQ&#39; if namespace.nfreq else &#39;NOFREQ&#39;

    # Loop over the valid parameters, assigning defaults if needed
    msg = &#39;No default {0} for {1} found for element {2}&#39;
    for p in valid_parameters[typ][ftyp]:
        if p not in par:
            # Default CPIM parameters if not given
            if namespace.cpim:
                try:
                    value = cpim_defaults[elem][p]
                except KeyError:
                    exit(msg.format(&#39;value&#39;, p, elem))

            # Default PIM parameter if not given
            
                # Experimental dielectric default
                if (par.dielectric and
                    &#39;drude&#39; not in par and &#39;lrtz&#39;  not in par and
                    &#39;lrtz1&#39; not in par and &#39;lrtz2&#39; not in par and
                    &#39;lrtz3&#39; not in par):
                    if elem in default_experimental_dielectrics_defined:
                        value = elem
                    else:
                        exit(msg.format(&#39;dielectric&#39;, p, elem))

                # Polarizability needs some lorentzians
                elif not par.dielectric and &#39;lrtz&#39; not in par:
                    exit(msg.format(&#39;polarizability&#39;, p, elem))

                # No default, but parameter not required
                else:
                    continue

            # Add the default to the parameters since it does not exist
            par.add(p, value)</code></pre>
</details>
</dd>
<dt id="dimpy.dim_reader.DIMReader.collect_and_format_lorentzian_terms"><code class="name flex">
<span>def <span class="ident">collect_and_format_lorentzian_terms</span></span>(<span>self, par)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert Lorentzian units and make them unified.
This is different
for polarizability and dielectric parameters types.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_and_format_lorentzian_terms(self, par):
    &#34;&#34;&#34;Convert Lorentzian units and make them unified.  This is different
    for polarizability and dielectric parameters types.&#34;&#34;&#34;

    def extract_data_for_lrtz(lrtz_type, counter, par, osc, om, res, pls, unit):
        for l in getattr(par, lrtz_type):
            c = unitmap[l[unit]]
            o = l[osc] if osc &gt;= 0 else 1.0
            w = c(l[om]) if om &gt;= 0 else 1.0
            try:
                par.lrtz[counter] = [o, w, c(l[res]), c(l[pls])]
            except IndexError:
                exit(&#39;The maximum number of lorentzians is 50&#39;)
            counter += 1
        par.remove(lrtz_type)
        return counter

    # First, convert lrtz to lrtz1
    if &#39;lrtz&#39; in par:
        if &#39;q+=1lrtz1&#39; not in par:
            par.add(&#39;lrtz1&#39;, [])
        else:
            par.lrtz1 = list(par.lrtz1)
        for l in par.lrtz:
            par.lrtz1.append(l)
        par.remove(&#39;lrtz&#39;)
        # Init lrtz to -1 for all values
    par.add(&#39;lrtz&#39;, [[-1.0, -1.0, -1.0, -1.0] for i in xrange(50)])

    counter = 0
    # Dielectric
    if par.dielectric:
        # lrtz1 uses res for res and pls
        if &#39;lrtz1&#39; in par:
            counter = extract_data_for_lrtz(&#39;lrtz1&#39;, counter, par, 0, 1, 1, 2, 3)

        # lrtz2 uses all parameters
        if &#39;lrtz2&#39; in par:
            counter = extract_data_for_lrtz(&#39;lrtz2&#39;, counter, par, 0, 1, 2, 3, 4)

        # lrtz3 has no osc
        if &#39;lrtz3&#39; in par:
            extract_data_for_lrtz(&#39;lrtz3&#39;, counter, par, -1, 0, 1, 2, 3)

    # For polarizability
    else:
        # polarizability lorentzian has no om
        if &#39;lrtz1&#39; in par:
            extract_data_for_lrtz(&#39;lrtz1&#39;, counter, par, 0, -1, 1, 2, 3)</code></pre>
</details>
</dd>
<dt id="dimpy.dim_reader.DIMReader.collect_coordinates_and_atoms"><code class="name flex">
<span>def <span class="ident">collect_coordinates_and_atoms</span></span>(<span>self, namespace)</span>
</code></dt>
<dd>
<div class="desc"><p>Collect the coordinates from the input, either directly or from other file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_coordinates_and_atoms(self, namespace):
    &#34;&#34;&#34;Collect the coordinates from the input, either directly or from other file&#34;&#34;&#34;

    # Collect from a file
    if &#39;file&#39; in namespace.xyz:
        # Make sure the xyz file path absolute
        if isabs(namespace.xyz.file.group(1)):
            fname = namespace.xyz.file.group(1)
        else:
            if isinstance(self.filename, str):
                fname = dirname(self.filename)
                fname = join(fname, namespace.xyz.file.group(1))
            else:
                fname = abspath(namespace.xyz.file.group(1))
        try:
            with open(fname) as fl:
                xyzfile = [line.strip() for line in fl]
        except IOError:
            exit(&#39;Error reading file {0}&#39;.format(fname))
        else:
            try:
                coords = [[float(x.split()[1]),
                           float(x.split()[2]),
                           float(x.split()[3])] for x in xyzfile[2:]]
                names = [x.split()[0].capitalize() for x in xyzfile[2:]]
            except IndexError:
                msg = &#39;Bad coordinate specification in file {0}.&#39;
                exit(msg.format(fname))
            try:
                natoms = int(xyzfile[0])
            except ValueError:
                msg = &#39;Unable to read number of atoms in file {0}.&#39;
                exit(msg.format(fname))
            if len(names) != natoms:
                error(&#39;Number of atoms found does not match expected&#39;)
                exit(&#39;Expected {0}, found {1}&#39;.format(natoms, len(names)))

    # Otherwise, collect from the block defined in the input
    else:
        names = [m.group(1).capitalize() for m in namespace.xyz.coords]
        coords = [[float(m.group(2)), float(m.group(3)), float(m.group(4))]
                  for m in namespace.xyz.coords]
        natoms = len(names)
        if &#39;natoms&#39; in namespace.xyz:
            namenatoms = int(namespace.xyz.natoms.group(1))
            if natoms != namenatoms:
                error(&#39;Number of atoms found does not match expected&#39;)
                exit(&#39;Expected {0}, found {1}&#39;.format(natoms, namenatoms))
    from numpy import array, argsort

    # Add the coordinates to the namespace
    namespace.add(&#39;natoms&#39;, natoms)
    namespace.add(&#39;atoms&#39;, names)
    namespace.add(&#39;coords&#39;, [[namespace.distconv(x) for x in c] for c in coords])
    namespace.add(&#39;elements&#39;, set(names))</code></pre>
</details>
</dd>
<dt id="dimpy.dim_reader.DIMReader.collect_drude_term"><code class="name flex">
<span>def <span class="ident">collect_drude_term</span></span>(<span>self, par)</span>
</code></dt>
<dd>
<div class="desc"><p>Puts the drude terms in the correct format, returning -1 if not given</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_drude_term(self, par):
    &#34;&#34;&#34;Puts the drude terms in the correct format, returning -1 if not given&#34;&#34;&#34;
    if &#39;drude&#39; in par:
        conv = unitmap[par.drude[2]]
        #print(par.drude)
        par.drude = [conv(par.drude[0]), conv(par.drude[1])]
    else:
        par.add(&#39;drude&#39;, [-1.0, -1.0])</code></pre>
</details>
</dd>
<dt id="dimpy.dim_reader.DIMReader.collect_experimental_dielectrics"><code class="name flex">
<span>def <span class="ident">collect_experimental_dielectrics</span></span>(<span>self, namespace, par)</span>
</code></dt>
<dd>
<div class="desc"><p>Collect the experimental dielectric, or return all zeros if none</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect_experimental_dielectrics(self, namespace, par):
    &#34;&#34;&#34;Collect the experimental dielectric, or return all zeros if none&#34;&#34;&#34;
    try:
        par.exp = self.expdie(par.exp, namespace.freqs)
    except AttributeError:
        par.exp = self.expdie(&#39;&#39;, namespace.freqs)</code></pre>
</details>
</dd>
<dt id="dimpy.dim_reader.DIMReader.expdie"><code class="name flex">
<span>def <span class="ident">expdie</span></span>(<span>self, name, freqs)</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves the experimental dielectric parameters for this type.
If none were found, return complex zero's for each frequency</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def expdie(self, name, freqs):
    &#34;&#34;&#34;Retrieves the experimental dielectric parameters for this type.
    If none were found, return complex zero&#39;s for each frequency&#34;&#34;&#34;
    from os.path import join, dirname, realpath
    from spline import spline, interpolate

    die = []
    if name:
        try:
            expdata = self.loadtxt(name)
        except IOError:
            # If not found as given, look in the DIM library
            dn = dirname(realpath(__file__))
            try:
                p = join(dn, &#39;dielectrics&#39;, name)
                expdata = self.loadtxt(p)
            except IOError:
                exit(&#39;Cannot find dielectric file for &#39; + name)

        # Spline the data
        realknots = spline(expdata[0], expdata[1])
        imagknots = spline(expdata[0], expdata[2])
        # For each frequency, interpolate
        for om in freqs:
            real = interpolate(expdata[0], expdata[1], realknots, HART2NM(om))
            imag = interpolate(expdata[0], expdata[2], imagknots, HART2NM(om))
            die.append(complex(real, imag))
    else:
        die = [complex(0.0) for i in xrange(len(freqs))]

    return die</code></pre>
</details>
</dd>
<dt id="dimpy.dim_reader.DIMReader.format_frequency_range"><code class="name flex">
<span>def <span class="ident">format_frequency_range</span></span>(<span>self, namespace)</span>
</code></dt>
<dd>
<div class="desc"><p>Format the frequency range correctly</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def format_frequency_range(self, namespace):
    &#34;&#34;&#34;Format the frequency range correctly&#34;&#34;&#34;

    freqs = []

    # Convert each given frequency
    if &#39;frequency&#39; in namespace:
        conv = unitmap[namespace.frequency[0]]
        for freq in namespace.frequency[1:]:
            freqs.append(conv(freq))

    # Expand the frequency range and convert appropriately
    elif &#39;freqrange&#39; in namespace:
        conv = unitmap[namespace.freqrange[0]]
        if namespace.freqrange[3] == 1:
            frequencies = [float(namespace.freqrange[1])]
        else:
            start, stop, num = namespace.freqrange[1:]
            step = (stop - start) / float(num - 1)
            frequencies = [y * step + start for y in xrange(num)]
            frequencies[-1] = stop
        for freq in frequencies:
            freqs.append(conv(freq))

    # No frequencies for static
    else:
        pass

    # Sort the frequencies in ascending order
    namespace.add(&#39;freqs&#39;, sorted(freqs))
    namespace.add(&#39;nfreq&#39;, len(freqs))</code></pre>
</details>
</dd>
<dt id="dimpy.dim_reader.DIMReader.format_parameters_for_each_element"><code class="name flex">
<span>def <span class="ident">format_parameters_for_each_element</span></span>(<span>self, namespace)</span>
</code></dt>
<dd>
<div class="desc"><p>Make sure that the parameters for each element are formatted correctly</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def format_parameters_for_each_element(self, namespace):
        &#34;&#34;&#34;Make sure that the parameters for each element are formatted correctly&#34;&#34;&#34;

        keyelem = []
        keyrmin = []
        keyrmax = []
        for elem in namespace.elements:
            par = self.get_parameters_for_element(elem, namespace)
            if par.binding == True:
                keyelem.append(elem)
                keyrmin.append(par.romin)
                keyrmax.append(par.romax)

        for elem in namespace.elements:
            par = self.get_parameters_for_element(elem, namespace)
            self.check_only_valid_parameters_appear_for_element(elem, namespace, par)
            self.check_that_valid_parameters_are_defined(elem, namespace, par)
            self.collect_experimental_dielectrics(namespace, par)
            self.zero_parameters_that_are_not_needed(par)
            par.rad = namespace.distconv(par.rad)  # Make sure radius is in Bohr
            par.rmin = namespace.distconv(par.rmin)
            par.rmax = namespace.distconv(par.rmax)
            par.rsurf = namespace.distconv(par.rsurf)
            par.rbulk = namespace.distconv(par.rbulk)
            self.calculate_static_polarizability(elem, namespace, par, keyelem, keyrmin, keyrmax)
#
            self.collect_drude_term(par)
            self.collect_and_format_lorentzian_terms(par)</code></pre>
</details>
</dd>
<dt id="dimpy.dim_reader.DIMReader.get_parameters_for_element"><code class="name flex">
<span>def <span class="ident">get_parameters_for_element</span></span>(<span>self, elem, namespace)</span>
</code></dt>
<dd>
<div class="desc"><p>Get the parameters for the given element. If it doesn't exist, quit.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_parameters_for_element(self, elem, namespace):
    &#34;&#34;&#34;Get the parameters for the given element. If it doesn&#39;t exist, quit.&#34;&#34;&#34;
    if elem.lower() not in namespace:
        exit(&#39;Missing type information for element &#39; + elem)
    else:
        par = getattr(namespace, elem.lower())
    return par</code></pre>
</details>
</dd>
<dt id="dimpy.dim_reader.DIMReader.loadtxt"><code class="name flex">
<span>def <span class="ident">loadtxt</span></span>(<span>self, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Loads text file as a list of floats., skipping comments
Each column of data is a row in the returned data list.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def loadtxt(self, filename):
    &#34;&#34;&#34;Loads text file as a list of floats., skipping comments
    Each column of data is a row in the returned data list.&#34;&#34;&#34;
    with open(filename) as fl:
        f = [x.strip().split() for x in fl if x[0] != &#39;#&#39;]
        # Now, reorganize from row x col ==&gt; col x row
    return [[float(nums[n]) for nums in f] for n in xrange(len(f[0]))]</code></pre>
</details>
</dd>
<dt id="dimpy.dim_reader.DIMReader.perform_sanity_checks"><code class="name flex">
<span>def <span class="ident">perform_sanity_checks</span></span>(<span>self, namespace)</span>
</code></dt>
<dd>
<div class="desc"><p>Ensure that some variables that cannot appear together don't</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def perform_sanity_checks(self, namespace):
    &#34;&#34;&#34;Ensure that some variables that cannot appear together don&#39;t&#34;&#34;&#34;
    if namespace.nopol and namespace.nochar:
        exit(&#39;Using both NOPOL and NOCHAR makes no sense&#39;)
    if namespace.nopol and namespace.nocross:
        exit(&#39;Using both NOPOL and NOCROSS makes no sense&#39;)
    if namespace.nocross and namespace.nochar:
        exit(&#39;Using both NOCROSS and NOCHAR makes no sense&#39;)
    if namespace.totalcharge != 0:
        exit(&#39;Nonzero TOTCHARGE not yet implemented&#39;)
    if namespace.cpim and namespace.algorithm &gt; 0:
        exit(&#39;Iterative solver not implemented for CPIM&#39;)
    if namespace.direction and namespace.algorithm == 0:
        exit(&#34;Direct solver can&#39;t separate field directions&#34;)</code></pre>
</details>
</dd>
<dt id="dimpy.dim_reader.DIMReader.post_process"><code class="name flex">
<span>def <span class="ident">post_process</span></span>(<span>self, namespace)</span>
</code></dt>
<dd>
<div class="desc"><p>Post-process the input to be ready for use by FORTRAN</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def post_process(self, namespace):
    &#34;&#34;&#34;Post-process the input to be ready for use by FORTRAN&#34;&#34;&#34;

    self.set_print_rules_for_output(namespace)
    self.perform_sanity_checks(namespace)
    self.set_appropriate_numbers_from_input(namespace)
    self.collect_coordinates_and_atoms(namespace)
    self.format_frequency_range(namespace)
    self.format_parameters_for_each_element(namespace)

    # Keep the input file in the namespace
    namespace.add(&#39;input_file&#39;, self.input_file)</code></pre>
</details>
</dd>
<dt id="dimpy.dim_reader.DIMReader.set_appropriate_numbers_from_input"><code class="name flex">
<span>def <span class="ident">set_appropriate_numbers_from_input</span></span>(<span>self, namespace)</span>
</code></dt>
<dd>
<div class="desc"><p>Some values in input can be string or integer.
Fortran will only
accept the integer version.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_appropriate_numbers_from_input(self, namespace):
    &#34;&#34;&#34;Some values in input can be string or integer.  Fortran will only
    accept the integer version.&#34;&#34;&#34;

    # Make sure the algorithm is a number.  If it is already a number,
    # an error will be raised and we don&#39;t do anything.
    try:
        namespace.algorithm = {&#39;DIRECT&#39;: 0,
                               &#39;BRUTE&#39;: 1,
                               &#39;SINGLE&#39;: 2,
                               &#39;MULTI&#39;: 3}[namespace.algorithm.upper()]
    except AttributeError:
        pass

    # Default the algorithm if one was not specified
    if namespace.algorithm == -1:
        if namespace.cpim:
            namespace.algorithm = 0
        else:
            namespace.algorithm = 1

    # Set numbers to the preconditioner
    try:
        namespace.precon = {&#39;NONE&#39;: 101.0,
                            &#39;PERFECT&#39;: 0.0,
                            &#39;JACOBI&#39;: 99.0}[namespace.precon.upper()]
    except AttributeError:
        pass

    # Make sure the grid spacing is a number.  If it is already a number, an
    # error will be raised and we don&#39;t do anything.
    try:
        namespace.grid = {&#39;EXTRACOARSE&#39;: 3,
                          &#39;COARSE&#39;: 5,
                          &#39;MEDIUM&#39;: 7,
                          &#39;FINE&#39;: 9,
                          &#39;EXTRAFINE&#39;: 11}[namespace.grid.upper()]
    except AttributeError:
        pass
    dirs = [False, False, False]
    if namespace.direction:
        for k in namespace.direction:
            try:
                i = {&#39;X&#39;: 0,
                     &#39;Y&#39;: 1,
                     &#39;Z&#39;: 2}[k.upper()]
                dirs[i] = True        
            except KeyError:
                error(&#39;Direction must be x, y, and/or z&#39;)
                exit (&#39;Expected [X, Y, Z], got {0}&#39;.format(k))

                
    else:
        dirs = [True, True, True]
    
    namespace.add(&#39;dirs&#39;, dirs)</code></pre>
</details>
</dd>
<dt id="dimpy.dim_reader.DIMReader.set_print_rules_for_output"><code class="name flex">
<span>def <span class="ident">set_print_rules_for_output</span></span>(<span>self, namespace)</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the print rules to use for the output file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_print_rules_for_output(self, namespace):
    &#34;&#34;&#34;Sets the print rules to use for the output file&#34;&#34;&#34;
    print_rules = set([])
    # The PRINTLEVEL macros set pre-defined printers
    if namespace.printlevel &gt;= 0:
        print_rules.update([&#39;pol&#39;, &#39;timing&#39;, &#39;input&#39;])
    if namespace.printlevel &gt;= 1:
        print_rules.update([&#39;coords&#39;, &#39;energy&#39;])
    if namespace.printlevel &gt;= 2:
        print_rules.add(&#39;atmdip&#39;)
    if namespace.printlevel &gt;= 3:
        print_rules.add(&#39;timingverbose&#39;)
        print_rules.discard(&#39;timing&#39;)

    # Make noprint a set so we can add to it
    if &#39;noprint&#39; in namespace:
        noprint = set(namespace.noprint)
    else:
        noprint = set([])

    # Add requested keys
    if &#39;print&#39; in namespace:
        for k in namespace.print:
            print_rules.add(k)
            # TIMING and TIMINGVERBOSE are mutually exclusive
            if k == &#39;timing&#39;:
                noprint.update([&#39;timingverbose&#39;, &#39;timingveryverbose&#39;])
            if k == &#39;timingverbose&#39;:
                noprint.update([&#39;timing&#39;, &#39;timingveryverbose&#39;])
            if k == &#39;timingveryverbose&#39;:
                noprint.update([&#39;timing&#39;, &#39;timingverbose&#39;])

    # If TIMINGVERYVERBOSE is present, choose this over the others
    if &#39;timingveryverbose&#39; in print_rules:
        noprint.discard(&#39;timingveryverbose&#39;)
    # If TIMINGVERBOSE is present, choose it over TIMING
    elif &#39;timingverbose&#39; in print_rules:
        noprint.discard(&#39;timingverbose&#39;)

    # Remove keys not wanted
    for k in noprint:
        print_rules.discard(k)

    namespace.add(&#39;print_rules&#39;, print_rules)</code></pre>
</details>
</dd>
<dt id="dimpy.dim_reader.DIMReader.zero_parameters_that_are_not_needed"><code class="name flex">
<span>def <span class="ident">zero_parameters_that_are_not_needed</span></span>(<span>self, par)</span>
</code></dt>
<dd>
<div class="desc"><p>Give zero value to parameters that weren't needed</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def zero_parameters_that_are_not_needed(self, par):
    &#34;&#34;&#34;Give zero value to parameters that weren&#39;t needed&#34;&#34;&#34;
    for p in (&#39;pol&#39;, &#39;cap&#39;, &#39;om1&#39;, &#39;om2&#39;, &#39;gm1&#39;, &#39;gm2&#39;, &#39;size&#39;):
        if p not in par:
            par.add(p, 0.0)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dimpy.dim_reader.SUPPRESS"><code class="flex name class">
<span>class <span class="ident">SUPPRESS</span></span>
</code></dt>
<dd>
<div class="desc"><p>Use this class to indicate that a key should be suppressed
if not present (i.e. it does not appear in the input file).</p>
<p>To use this, put :py:class:<code><a title="dimpy.dim_reader.SUPPRESS" href="#dimpy.dim_reader.SUPPRESS">SUPPRESS</a></code> for the default of a key.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SUPPRESS(object):
    &#34;&#34;&#34;
    Use this class to indicate that a key should be suppressed
    if not present (i.e. it does not appear in the input file).

    To use this, put :py:class:`SUPPRESS` for the default of a key.
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dimpy" href="index.html">dimpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dimpy.dim_reader.DIMReader" href="#dimpy.dim_reader.DIMReader">DIMReader</a></code></h4>
<ul class="">
<li><code><a title="dimpy.dim_reader.DIMReader.calculate_static_polarizability" href="#dimpy.dim_reader.DIMReader.calculate_static_polarizability">calculate_static_polarizability</a></code></li>
<li><code><a title="dimpy.dim_reader.DIMReader.check_only_valid_parameters_appear_for_element" href="#dimpy.dim_reader.DIMReader.check_only_valid_parameters_appear_for_element">check_only_valid_parameters_appear_for_element</a></code></li>
<li><code><a title="dimpy.dim_reader.DIMReader.check_that_valid_parameters_are_defined" href="#dimpy.dim_reader.DIMReader.check_that_valid_parameters_are_defined">check_that_valid_parameters_are_defined</a></code></li>
<li><code><a title="dimpy.dim_reader.DIMReader.collect_and_format_lorentzian_terms" href="#dimpy.dim_reader.DIMReader.collect_and_format_lorentzian_terms">collect_and_format_lorentzian_terms</a></code></li>
<li><code><a title="dimpy.dim_reader.DIMReader.collect_coordinates_and_atoms" href="#dimpy.dim_reader.DIMReader.collect_coordinates_and_atoms">collect_coordinates_and_atoms</a></code></li>
<li><code><a title="dimpy.dim_reader.DIMReader.collect_drude_term" href="#dimpy.dim_reader.DIMReader.collect_drude_term">collect_drude_term</a></code></li>
<li><code><a title="dimpy.dim_reader.DIMReader.collect_experimental_dielectrics" href="#dimpy.dim_reader.DIMReader.collect_experimental_dielectrics">collect_experimental_dielectrics</a></code></li>
<li><code><a title="dimpy.dim_reader.DIMReader.expdie" href="#dimpy.dim_reader.DIMReader.expdie">expdie</a></code></li>
<li><code><a title="dimpy.dim_reader.DIMReader.format_frequency_range" href="#dimpy.dim_reader.DIMReader.format_frequency_range">format_frequency_range</a></code></li>
<li><code><a title="dimpy.dim_reader.DIMReader.format_parameters_for_each_element" href="#dimpy.dim_reader.DIMReader.format_parameters_for_each_element">format_parameters_for_each_element</a></code></li>
<li><code><a title="dimpy.dim_reader.DIMReader.get_parameters_for_element" href="#dimpy.dim_reader.DIMReader.get_parameters_for_element">get_parameters_for_element</a></code></li>
<li><code><a title="dimpy.dim_reader.DIMReader.loadtxt" href="#dimpy.dim_reader.DIMReader.loadtxt">loadtxt</a></code></li>
<li><code><a title="dimpy.dim_reader.DIMReader.perform_sanity_checks" href="#dimpy.dim_reader.DIMReader.perform_sanity_checks">perform_sanity_checks</a></code></li>
<li><code><a title="dimpy.dim_reader.DIMReader.post_process" href="#dimpy.dim_reader.DIMReader.post_process">post_process</a></code></li>
<li><code><a title="dimpy.dim_reader.DIMReader.set_appropriate_numbers_from_input" href="#dimpy.dim_reader.DIMReader.set_appropriate_numbers_from_input">set_appropriate_numbers_from_input</a></code></li>
<li><code><a title="dimpy.dim_reader.DIMReader.set_print_rules_for_output" href="#dimpy.dim_reader.DIMReader.set_print_rules_for_output">set_print_rules_for_output</a></code></li>
<li><code><a title="dimpy.dim_reader.DIMReader.zero_parameters_that_are_not_needed" href="#dimpy.dim_reader.DIMReader.zero_parameters_that_are_not_needed">zero_parameters_that_are_not_needed</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dimpy.dim_reader.SUPPRESS" href="#dimpy.dim_reader.SUPPRESS">SUPPRESS</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>