<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>dimpy.dimpy API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dimpy.dimpy</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#! /usr/bin/env python
from sys import exit
from os.path import splitext
from input_reader import abs_file_path
from argparse import ArgumentParser, Action
from .run import run
from .parallel import Parallel
from .process import fix_binary
from ._version import __version__


def main():
    &#34;&#34;&#34;\
    Front-end for the DIM code.
    &#34;&#34;&#34;

    # Assume that argparse exists and create an argument parser
    parser = ArgumentParser(description=&#34;Front-end for the DIM code.&#34;, prog=&#39;dim&#39;)
    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;,
                        version=&#39;%(prog)s {0}&#39;.format(__version__))
    parser.add_argument(&#39;file&#39;, help=&#39;The input file to read.&#39;)
    # Add the options
    parser.add_argument(&#39;-o&#39;, &#39;--out&#39;, help=&#39;Defines the file to output data &#39;
                        &#39;to.  If not given, the input name is used with a &#39;
                        &#39;.out extension.&#39;)
    parser.add_argument(&#39;--fix_binary&#39;, action=&#39;store_true&#39;,
                        default=False,
                        help=&#39;Distutils changes the mode &#39;
                        &#39;of the DIM binary to non-executable.  The first &#39;
                        &#39;time you run dim it will try to change this &#39;
                        &#39;back to executable for you, but if it cannot you &#39;
                        &#39;will need run with this mode as root to fix.&#39;)
    parser.add_argument
    if Parallel.is_parallel():
        parser.add_argument(&#39;-n&#39;, &#39;--nproc&#39;, **Parallel.nproc_opts())
    args = parser.parse_args()
    # Fix the binary if needed
    if args.fix_binary:
        fix_binary()

    # Determine output file name.
    # It has the same name as the input but with .out unless otherwise given
    if args.out is not None:
        outputname = args.out
    else:
        outputname = &#39;.&#39;.join([splitext(abs_file_path(args.file))[0], &#39;out&#39;])

    # Perform the actual calculation
    if Parallel.is_parallel():
        run(args.file, outputname, args.nproc)
    else:
        run(args.file, outputname)


def show():
    &#34;&#34;&#34;\
    Front-end for the DIM printing commands.
    &#34;&#34;&#34;
    try:
        from dimclass import DIM
    except ImportError:
        exit(&#34;Cannot import the DIM tools... they may not have been compiled.&#34;)

    parser = ArgumentParser(description=&#34;Front-end for the DIM printing commands.&#34;,
                            prog=&#39;dim-show&#39;)
    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;,
                        version=&#39;%(prog)s {0}&#39;.format(__version__))
    modes = parser.add_subparsers(title=&#39;print modes&#39;,
                                  description=&#39;Choose the type of information &#39;
                                              &#39;to print to the screen&#39;,
                                  help=&#39;Select the type of information to print&#39;,
                                  dest=&#39;mode&#39;)
    coords = modes.add_parser(&#39;coords&#39;,
                              help=&#39;Print the atomic coordinates to &#39;
                                   &#39;standard output&#39;)
    coords.add_argument(&#39;-n&#39;, &#39;--num&#39;, action=&#39;store_true&#39;, default=False,
                        help=&#39;Prints the number of the atom with the &#39;
                             &#39;coordinates&#39;)

    pol = modes.add_parser(&#39;pol&#39;,
                           help=&#39;Print the polarizabiliy tensors to &#39;
                                &#39;standard output&#39;)
    pol.add_argument(&#39;--ani&#39;, action=&#39;store_true&#39;, default=False,
                     help=&#39;Includes the anisotropic polarizabiliy with &#39;
                          &#39;the tensor&#39;)
    pol.add_argument(&#39;-u&#39;, &#39;--unit&#39;, choices=(&#39;au&#39;, &#39;ev&#39;, &#39;nm&#39;),
                     default=&#39;au&#39;,
                     help=&#39;For frequency-dependent calculations, &#39;
                          &#39;specifies the unit to print the frequencies in. &#39;
                          &#34;The default is &#39;%(default)s&#39;.&#34;)
    cross = modes.add_parser(&#39;cross&#39;,
                             help=&#39;Prints the absorption cross-sections to &#39;
                                  &#39;the standard output&#39;)
    cross.add_argument(&#39;--absunit&#39;, default=&#39;angstroms&#39;,
                       choices=(&#39;angstroms&#39;, &#39;bohr&#39;, &#39;nm&#39;, &#39;cm&#39;, &#39;m&#39;),
                       help=&#39;The units of absorption cross-sections to print. &#39;
                            &#34;The default is &#39;%(default)s&#39;.&#34;)
    molar = modes.add_parser(&#39;molar&#39;,
                             help=&#39;Prints the molar absorptivitty to the &#39;
                                  &#39;standard output&#39;)
    absorbance = modes.add_parser(&#39;absorbance&#39;,
                                  help=&#39;Prints the unitless absorbance to the &#39;
                                       &#39;standard output&#39;)
    transmittance = modes.add_parser(&#39;transmittance&#39;,
                                     help=&#39;Prints the normalized &#39;
                                          &#39;transmittance to the &#39;
                                          &#39;standard output&#39;)
    # Add common arguments
    for m in (cross, molar, absorbance, transmittance):
        m.add_argument(&#39;-u&#39;, &#39;--unit&#39;, choices=(&#39;au&#39;, &#39;ev&#39;, &#39;nm&#39;),
                       default=&#39;au&#39;,
                       help=&#39;Specifies the unit &#39;
                            &#39;to print the frequencies in. &#39;
                            &#34;The default is &#39;%(default)s&#39;.&#34;)
        if m in (absorbance, transmittance):
            m.add_argument(&#39;--conc&#39;, type=float, default=1E-6,
                           help=&#34;The Beer&#39;s law concentration in molarity. &#34;
                                &#34;The default is %(default)s&#34;)
            m.add_argument(&#39;--path&#39;, type=float, default=1.0,
                           help=&#34;The Beer&#39;s law pathlength in centimeters. &#34;
                                &#34;The default is %(default)s&#34;)
    parser.add_argument(&#39;file&#39;, help=&#39;The DIM output file to read.&#39;)
    args = parser.parse_args()

    # Read the data
    data = DIM(args.file)
    data.collect()

    # Print out the information
    if args.mode == &#39;pol&#39;:
        data.printTensor(iso=True, ani=args.ani, unit=args.unit)
    elif args.mode == &#39;coords&#39;:
        if args.num:
            data.printCoords(mode=&#39;num&#39;)
        else:
            data.printCoords()
    elif args.mode == &#39;cross&#39;:
        data.printOptical(property=&#39;cross-section&#39;, unit=args.unit,
                          absunit=args.absunit)
    elif args.mode == &#39;molar&#39;:
        data.printOptical(property=&#39;absorptivitty&#39;, unit=args.unit)
    elif args.mode == &#39;absorbance&#39;:
        data.printOptical(property=&#39;absorbance&#39;, unit=args.unit,
                          concentration=args.conc, pathlength=args.path)
    elif args.mode == &#39;transmittance&#39;:
        data.printOptical(property=&#39;transmittance&#39;, unit=args.unit,
                          concentration=args.conc, pathlength=args.path)


def plot():
    &#34;&#34;&#34;Easily plot DIM data&#34;&#34;&#34;
    from plot import plot_dim

    color_dict = {&#39;blue&#39;: &#39;b&#39;, &#39;green&#39;: &#39;g&#39;, &#39;red&#39;: &#39;r&#39;, &#39;cyan&#39;: &#39;c&#39;,
                  &#39;magenta&#39;: &#39;m&#39;, &#39;yellow&#39;: &#39;y&#39;, &#39;black&#39;: &#39;k&#39;, &#39;white&#39;: &#39;w&#39;}

    class ColorAction(Action):
        def __call__(self, parser, namespace, value, option_string=None):
            setattr(namespace, self.dest, color_dict[value])

    point_dict = {&#39;square&#39;: &#39;s&#39;, &#39;circle&#39;: &#39;o&#39;, &#39;tri_up&#39;: &#39;^&#39;,
                  &#39;tri_down&#39;: &#39;v&#39;, &#39;tri_right&#39;: &#39;&gt;&#39;, &#39;tri_left&#39;: &#39;&lt;&#39;,
                  &#39;plus&#39;: &#39;+&#39;, &#39;cross&#39;: &#39;x&#39;, &#39;star&#39;: &#39;*&#39;, &#39;diamond&#39;: &#39;D&#39;}

    class PointAction(Action):
        def __call__(self, parser, namespace, value, option_string=None):
            setattr(namespace, self.dest, point_dict[value])

    line_dict = {&#39;solid&#39;: &#39;-&#39;, &#39;dashed&#39;: &#39;--&#39;, &#39;dot_dash&#39;: &#39;-.&#39;, &#39;dotted&#39;: &#39;.&#39;}

    class LineAction(Action):
        def __call__(self, parser, namespace, value, option_string=None):
            setattr(namespace, self.dest, line_dict[value])

    parser = ArgumentParser(description=&#34;Plot DIM output data.&#34;,
                            prog=&#39;dim-plot&#39;)
    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;,
                        version=&#39;%(prog)s {0}&#39;.format(__version__))
    modes = parser.add_subparsers(title=&#39;plot modes&#39;,
                                  description=&#39;Choose the type of information &#39;
                                              &#39;to plot&#39;,
                                  help=&#39;Select the type of information to plot&#39;,
                                  dest=&#39;mode&#39;)
    pol = modes.add_parser(&#39;pol&#39;,
                           help=&#39;Plot the isotropic polarizability&#39;)
    pol.add_argument(&#39;--real&#39;, action=&#39;store_true&#39;, default=False,
                     help=&#39;If plotting polarizabilities, this will plot &#39;
                     &#39;only the real component.  By default both real and &#39;
                     &#39;imaginary are plotted.&#39;)
    pol.add_argument(&#39;--imag&#39;, action=&#39;store_true&#39;, default=False,
                     help=&#39;If plotting polarizabilities, this will plot &#39;
                     &#39;only the imaginary component.  By default both real &#39;
                     &#39;and imaginary are plotted.&#39;)
    pol.add_argument(&#39;--ylimits2&#39;, type=float, nargs=2,
                     default=[None, None],
                     help=&#39;The plot limits on the Y-axis.  By default the&#39;
                     &#39;limits are dictated by the data. This is only used &#39;
                     &#39;for the imaginary polarizability when both the &#39;
                     &#39;real and imaginary polarizabilities are plotted.&#39;)
    pol.add_argument(&#39;--color2&#39;, default=&#39;g&#39;, choices=color_dict.keys(),
                     action=ColorAction,
                     help=&#39;Defines the color of the line and points &#39;
                     &#39;of the plot for the imaginary polarizability if &#39;
                     &#39;both real and imaginary are plotted. The default &#39;
                     &#39;is green&#39;)
    pol.add_argument(&#39;--linestyle2&#39;, default=&#39;-&#39;,
                     choices=line_dict, action=LineAction,
                     help=&#39;Specifies the line style of the plot for the &#39;
                     &#39;for the imaginary polarizability if both real &#39;
                     &#39;and imaginary are plotted.  The default &#39;
                     &#39;is solid.&#39;)
    pol.add_argument(&#39;--pointstyle2&#39;, default=&#39;s&#39;,
                     choices=point_dict.keys(), action=PointAction,
                     help=&#39;Specifies the point style of the plot &#39;
                     &#39;for the imaginary polarizability if both real &#39;
                     &#39;and imaginary are plotted. &#39;
                     &#39;The default is square.&#39;)
    cross = modes.add_parser(&#39;cross&#39;,
                             help=&#39;Plots the absorption cross-sections&#39;)
    cross.add_argument(&#39;--absunit&#39;, default=&#39;angstroms&#39;,
                       choices=(&#39;angstroms&#39;, &#39;bohr&#39;, &#39;nm&#39;, &#39;cm&#39;, &#39;m&#39;),
                       help=&#39;The units of absorption cross-sections to plot. &#39;
                            &#34;The default is &#39;%(default)s&#39;.&#34;)
    modes.add_parser(&#39;molar&#39;, help=&#39;Plots the molar absorptivitty&#39;)
    absorbance = modes.add_parser(&#39;absorbance&#39;,
                                  help=&#39;Plots the unitless absorbance&#39;)
    transmittance = modes.add_parser(&#39;transmittance&#39;,
                                     help=&#39;Plots the normalized &#39;
                                          &#39;transmittance&#39;)
    for m in (absorbance, transmittance):
        m.add_argument(&#39;--conc&#39;, type=float, default=1E-6,
                       help=&#34;The Beer&#39;s law concentration in molarity, &#34;
                            &#34;The default is %(default)s&#34;)
        m.add_argument(&#39;--path&#39;, type=float, default=1.0,
                       help=&#34;The Beer&#39;s law pathlength in centimeters. &#34;
                            &#34;The default is %(default)s&#34;)
    parser.add_argument(&#39;--title&#39;, help=&#39;A title for the plot.  If your &#39;
                        &#39;title consists of multiple words you must quote it.&#39;)
    parser.add_argument(&#39;--points&#39;, action=&#39;store_true&#39;, default=False,
                        help=&#39;Plot the calculated datapoints over the &#39;
                        &#39;interpolated curve.&#39;)
    parser.add_argument(&#39;-u&#39;, &#39;--unit&#39;, choices=(&#39;au&#39;, &#39;ev&#39;, &#39;nm&#39;),
                        default=&#39;nm&#39;,
                        help=&#39;Chooses the unit of the frequencies (x-axis) &#39;
                        &#39;to print the frequencies in.  The choices are &#39;
                        &#34;&#39;au&#39;, &#39;nm&#39;, or &#39;ev&#39;, and the default is &#39;nm&#39;.&#34;)
    parser.add_argument(&#39;--xlimits&#39;, type=float, nargs=2, default=[None, None],
                        help=&#39;The plot limits on the X-axis.  By default the&#39;
                        &#39;limits are dictated by the data.&#39;)
    parser.add_argument(&#39;--ylimits&#39;, type=float, nargs=2, default=[None, None],
                        help=&#39;The plot limits on the Y-axis.  By default the&#39;
                        &#39;limits are dictated by the data.&#39;)
    parser.add_argument(&#39;--lw&#39;, &#39;--linewidth&#39;, type=float, default=2.0,
                        help=&#39;The width of the lines that are plotted. &#39;
                        &#39;The default is %(default)s.&#39;)
    parser.add_argument(&#39;--ls&#39;, &#39;--linestyle&#39;, default=&#39;-&#39;,
                        choices=line_dict, action=LineAction,
                        help=&#39;Specifies the line style of the plot. &#39;
                        &#39;The default is solid.&#39;)
    parser.add_argument(&#39;--ms&#39;, &#39;--pointsize&#39;, type=float, default=8.0,
                        help=&#39;The size of the points that are plotted. &#39;
                        &#39;The default is %(default)s.&#39;)
    parser.add_argument(&#39;--pt&#39;, &#39;--pointstyle&#39;, default=&#39;s&#39;,
                        choices=point_dict.keys(), action=PointAction,
                        help=&#39;Specifies the point style of the plot. &#39;
                        &#39;The default is square.&#39;)
    parser.add_argument(&#39;--co&#39;, &#39;--color&#39;, default=&#39;b&#39;,
                        choices=color_dict.keys(), action=ColorAction,
                        help=&#39;Defines the color of the line and points &#39;
                        &#39;of the plot. The default is blue&#39;)
    parser.add_argument(&#39;file&#39;, help=&#39;The DIM output file to read.&#39;)
    args = parser.parse_args()

    plot_dim(args)


def gui():
    &#34;&#34;&#34;Start the DIM GUI&#34;&#34;&#34;
    pass

if __name__ == &#39;__main__&#39;:
    try:
        main()
    except KeyboardInterrupt:
        exit(1)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="dimpy.dimpy.gui"><code class="name flex">
<span>def <span class="ident">gui</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Start the DIM GUI</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def gui():
    &#34;&#34;&#34;Start the DIM GUI&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="dimpy.dimpy.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Front-end for the DIM code.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34;\
    Front-end for the DIM code.
    &#34;&#34;&#34;

    # Assume that argparse exists and create an argument parser
    parser = ArgumentParser(description=&#34;Front-end for the DIM code.&#34;, prog=&#39;dim&#39;)
    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;,
                        version=&#39;%(prog)s {0}&#39;.format(__version__))
    parser.add_argument(&#39;file&#39;, help=&#39;The input file to read.&#39;)
    # Add the options
    parser.add_argument(&#39;-o&#39;, &#39;--out&#39;, help=&#39;Defines the file to output data &#39;
                        &#39;to.  If not given, the input name is used with a &#39;
                        &#39;.out extension.&#39;)
    parser.add_argument(&#39;--fix_binary&#39;, action=&#39;store_true&#39;,
                        default=False,
                        help=&#39;Distutils changes the mode &#39;
                        &#39;of the DIM binary to non-executable.  The first &#39;
                        &#39;time you run dim it will try to change this &#39;
                        &#39;back to executable for you, but if it cannot you &#39;
                        &#39;will need run with this mode as root to fix.&#39;)
    parser.add_argument
    if Parallel.is_parallel():
        parser.add_argument(&#39;-n&#39;, &#39;--nproc&#39;, **Parallel.nproc_opts())
    args = parser.parse_args()
    # Fix the binary if needed
    if args.fix_binary:
        fix_binary()

    # Determine output file name.
    # It has the same name as the input but with .out unless otherwise given
    if args.out is not None:
        outputname = args.out
    else:
        outputname = &#39;.&#39;.join([splitext(abs_file_path(args.file))[0], &#39;out&#39;])

    # Perform the actual calculation
    if Parallel.is_parallel():
        run(args.file, outputname, args.nproc)
    else:
        run(args.file, outputname)</code></pre>
</details>
</dd>
<dt id="dimpy.dimpy.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Easily plot DIM data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot():
    &#34;&#34;&#34;Easily plot DIM data&#34;&#34;&#34;
    from plot import plot_dim

    color_dict = {&#39;blue&#39;: &#39;b&#39;, &#39;green&#39;: &#39;g&#39;, &#39;red&#39;: &#39;r&#39;, &#39;cyan&#39;: &#39;c&#39;,
                  &#39;magenta&#39;: &#39;m&#39;, &#39;yellow&#39;: &#39;y&#39;, &#39;black&#39;: &#39;k&#39;, &#39;white&#39;: &#39;w&#39;}

    class ColorAction(Action):
        def __call__(self, parser, namespace, value, option_string=None):
            setattr(namespace, self.dest, color_dict[value])

    point_dict = {&#39;square&#39;: &#39;s&#39;, &#39;circle&#39;: &#39;o&#39;, &#39;tri_up&#39;: &#39;^&#39;,
                  &#39;tri_down&#39;: &#39;v&#39;, &#39;tri_right&#39;: &#39;&gt;&#39;, &#39;tri_left&#39;: &#39;&lt;&#39;,
                  &#39;plus&#39;: &#39;+&#39;, &#39;cross&#39;: &#39;x&#39;, &#39;star&#39;: &#39;*&#39;, &#39;diamond&#39;: &#39;D&#39;}

    class PointAction(Action):
        def __call__(self, parser, namespace, value, option_string=None):
            setattr(namespace, self.dest, point_dict[value])

    line_dict = {&#39;solid&#39;: &#39;-&#39;, &#39;dashed&#39;: &#39;--&#39;, &#39;dot_dash&#39;: &#39;-.&#39;, &#39;dotted&#39;: &#39;.&#39;}

    class LineAction(Action):
        def __call__(self, parser, namespace, value, option_string=None):
            setattr(namespace, self.dest, line_dict[value])

    parser = ArgumentParser(description=&#34;Plot DIM output data.&#34;,
                            prog=&#39;dim-plot&#39;)
    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;,
                        version=&#39;%(prog)s {0}&#39;.format(__version__))
    modes = parser.add_subparsers(title=&#39;plot modes&#39;,
                                  description=&#39;Choose the type of information &#39;
                                              &#39;to plot&#39;,
                                  help=&#39;Select the type of information to plot&#39;,
                                  dest=&#39;mode&#39;)
    pol = modes.add_parser(&#39;pol&#39;,
                           help=&#39;Plot the isotropic polarizability&#39;)
    pol.add_argument(&#39;--real&#39;, action=&#39;store_true&#39;, default=False,
                     help=&#39;If plotting polarizabilities, this will plot &#39;
                     &#39;only the real component.  By default both real and &#39;
                     &#39;imaginary are plotted.&#39;)
    pol.add_argument(&#39;--imag&#39;, action=&#39;store_true&#39;, default=False,
                     help=&#39;If plotting polarizabilities, this will plot &#39;
                     &#39;only the imaginary component.  By default both real &#39;
                     &#39;and imaginary are plotted.&#39;)
    pol.add_argument(&#39;--ylimits2&#39;, type=float, nargs=2,
                     default=[None, None],
                     help=&#39;The plot limits on the Y-axis.  By default the&#39;
                     &#39;limits are dictated by the data. This is only used &#39;
                     &#39;for the imaginary polarizability when both the &#39;
                     &#39;real and imaginary polarizabilities are plotted.&#39;)
    pol.add_argument(&#39;--color2&#39;, default=&#39;g&#39;, choices=color_dict.keys(),
                     action=ColorAction,
                     help=&#39;Defines the color of the line and points &#39;
                     &#39;of the plot for the imaginary polarizability if &#39;
                     &#39;both real and imaginary are plotted. The default &#39;
                     &#39;is green&#39;)
    pol.add_argument(&#39;--linestyle2&#39;, default=&#39;-&#39;,
                     choices=line_dict, action=LineAction,
                     help=&#39;Specifies the line style of the plot for the &#39;
                     &#39;for the imaginary polarizability if both real &#39;
                     &#39;and imaginary are plotted.  The default &#39;
                     &#39;is solid.&#39;)
    pol.add_argument(&#39;--pointstyle2&#39;, default=&#39;s&#39;,
                     choices=point_dict.keys(), action=PointAction,
                     help=&#39;Specifies the point style of the plot &#39;
                     &#39;for the imaginary polarizability if both real &#39;
                     &#39;and imaginary are plotted. &#39;
                     &#39;The default is square.&#39;)
    cross = modes.add_parser(&#39;cross&#39;,
                             help=&#39;Plots the absorption cross-sections&#39;)
    cross.add_argument(&#39;--absunit&#39;, default=&#39;angstroms&#39;,
                       choices=(&#39;angstroms&#39;, &#39;bohr&#39;, &#39;nm&#39;, &#39;cm&#39;, &#39;m&#39;),
                       help=&#39;The units of absorption cross-sections to plot. &#39;
                            &#34;The default is &#39;%(default)s&#39;.&#34;)
    modes.add_parser(&#39;molar&#39;, help=&#39;Plots the molar absorptivitty&#39;)
    absorbance = modes.add_parser(&#39;absorbance&#39;,
                                  help=&#39;Plots the unitless absorbance&#39;)
    transmittance = modes.add_parser(&#39;transmittance&#39;,
                                     help=&#39;Plots the normalized &#39;
                                          &#39;transmittance&#39;)
    for m in (absorbance, transmittance):
        m.add_argument(&#39;--conc&#39;, type=float, default=1E-6,
                       help=&#34;The Beer&#39;s law concentration in molarity, &#34;
                            &#34;The default is %(default)s&#34;)
        m.add_argument(&#39;--path&#39;, type=float, default=1.0,
                       help=&#34;The Beer&#39;s law pathlength in centimeters. &#34;
                            &#34;The default is %(default)s&#34;)
    parser.add_argument(&#39;--title&#39;, help=&#39;A title for the plot.  If your &#39;
                        &#39;title consists of multiple words you must quote it.&#39;)
    parser.add_argument(&#39;--points&#39;, action=&#39;store_true&#39;, default=False,
                        help=&#39;Plot the calculated datapoints over the &#39;
                        &#39;interpolated curve.&#39;)
    parser.add_argument(&#39;-u&#39;, &#39;--unit&#39;, choices=(&#39;au&#39;, &#39;ev&#39;, &#39;nm&#39;),
                        default=&#39;nm&#39;,
                        help=&#39;Chooses the unit of the frequencies (x-axis) &#39;
                        &#39;to print the frequencies in.  The choices are &#39;
                        &#34;&#39;au&#39;, &#39;nm&#39;, or &#39;ev&#39;, and the default is &#39;nm&#39;.&#34;)
    parser.add_argument(&#39;--xlimits&#39;, type=float, nargs=2, default=[None, None],
                        help=&#39;The plot limits on the X-axis.  By default the&#39;
                        &#39;limits are dictated by the data.&#39;)
    parser.add_argument(&#39;--ylimits&#39;, type=float, nargs=2, default=[None, None],
                        help=&#39;The plot limits on the Y-axis.  By default the&#39;
                        &#39;limits are dictated by the data.&#39;)
    parser.add_argument(&#39;--lw&#39;, &#39;--linewidth&#39;, type=float, default=2.0,
                        help=&#39;The width of the lines that are plotted. &#39;
                        &#39;The default is %(default)s.&#39;)
    parser.add_argument(&#39;--ls&#39;, &#39;--linestyle&#39;, default=&#39;-&#39;,
                        choices=line_dict, action=LineAction,
                        help=&#39;Specifies the line style of the plot. &#39;
                        &#39;The default is solid.&#39;)
    parser.add_argument(&#39;--ms&#39;, &#39;--pointsize&#39;, type=float, default=8.0,
                        help=&#39;The size of the points that are plotted. &#39;
                        &#39;The default is %(default)s.&#39;)
    parser.add_argument(&#39;--pt&#39;, &#39;--pointstyle&#39;, default=&#39;s&#39;,
                        choices=point_dict.keys(), action=PointAction,
                        help=&#39;Specifies the point style of the plot. &#39;
                        &#39;The default is square.&#39;)
    parser.add_argument(&#39;--co&#39;, &#39;--color&#39;, default=&#39;b&#39;,
                        choices=color_dict.keys(), action=ColorAction,
                        help=&#39;Defines the color of the line and points &#39;
                        &#39;of the plot. The default is blue&#39;)
    parser.add_argument(&#39;file&#39;, help=&#39;The DIM output file to read.&#39;)
    args = parser.parse_args()

    plot_dim(args)</code></pre>
</details>
</dd>
<dt id="dimpy.dimpy.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Front-end for the DIM printing commands.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show():
    &#34;&#34;&#34;\
    Front-end for the DIM printing commands.
    &#34;&#34;&#34;
    try:
        from dimclass import DIM
    except ImportError:
        exit(&#34;Cannot import the DIM tools... they may not have been compiled.&#34;)

    parser = ArgumentParser(description=&#34;Front-end for the DIM printing commands.&#34;,
                            prog=&#39;dim-show&#39;)
    parser.add_argument(&#39;--version&#39;, action=&#39;version&#39;,
                        version=&#39;%(prog)s {0}&#39;.format(__version__))
    modes = parser.add_subparsers(title=&#39;print modes&#39;,
                                  description=&#39;Choose the type of information &#39;
                                              &#39;to print to the screen&#39;,
                                  help=&#39;Select the type of information to print&#39;,
                                  dest=&#39;mode&#39;)
    coords = modes.add_parser(&#39;coords&#39;,
                              help=&#39;Print the atomic coordinates to &#39;
                                   &#39;standard output&#39;)
    coords.add_argument(&#39;-n&#39;, &#39;--num&#39;, action=&#39;store_true&#39;, default=False,
                        help=&#39;Prints the number of the atom with the &#39;
                             &#39;coordinates&#39;)

    pol = modes.add_parser(&#39;pol&#39;,
                           help=&#39;Print the polarizabiliy tensors to &#39;
                                &#39;standard output&#39;)
    pol.add_argument(&#39;--ani&#39;, action=&#39;store_true&#39;, default=False,
                     help=&#39;Includes the anisotropic polarizabiliy with &#39;
                          &#39;the tensor&#39;)
    pol.add_argument(&#39;-u&#39;, &#39;--unit&#39;, choices=(&#39;au&#39;, &#39;ev&#39;, &#39;nm&#39;),
                     default=&#39;au&#39;,
                     help=&#39;For frequency-dependent calculations, &#39;
                          &#39;specifies the unit to print the frequencies in. &#39;
                          &#34;The default is &#39;%(default)s&#39;.&#34;)
    cross = modes.add_parser(&#39;cross&#39;,
                             help=&#39;Prints the absorption cross-sections to &#39;
                                  &#39;the standard output&#39;)
    cross.add_argument(&#39;--absunit&#39;, default=&#39;angstroms&#39;,
                       choices=(&#39;angstroms&#39;, &#39;bohr&#39;, &#39;nm&#39;, &#39;cm&#39;, &#39;m&#39;),
                       help=&#39;The units of absorption cross-sections to print. &#39;
                            &#34;The default is &#39;%(default)s&#39;.&#34;)
    molar = modes.add_parser(&#39;molar&#39;,
                             help=&#39;Prints the molar absorptivitty to the &#39;
                                  &#39;standard output&#39;)
    absorbance = modes.add_parser(&#39;absorbance&#39;,
                                  help=&#39;Prints the unitless absorbance to the &#39;
                                       &#39;standard output&#39;)
    transmittance = modes.add_parser(&#39;transmittance&#39;,
                                     help=&#39;Prints the normalized &#39;
                                          &#39;transmittance to the &#39;
                                          &#39;standard output&#39;)
    # Add common arguments
    for m in (cross, molar, absorbance, transmittance):
        m.add_argument(&#39;-u&#39;, &#39;--unit&#39;, choices=(&#39;au&#39;, &#39;ev&#39;, &#39;nm&#39;),
                       default=&#39;au&#39;,
                       help=&#39;Specifies the unit &#39;
                            &#39;to print the frequencies in. &#39;
                            &#34;The default is &#39;%(default)s&#39;.&#34;)
        if m in (absorbance, transmittance):
            m.add_argument(&#39;--conc&#39;, type=float, default=1E-6,
                           help=&#34;The Beer&#39;s law concentration in molarity. &#34;
                                &#34;The default is %(default)s&#34;)
            m.add_argument(&#39;--path&#39;, type=float, default=1.0,
                           help=&#34;The Beer&#39;s law pathlength in centimeters. &#34;
                                &#34;The default is %(default)s&#34;)
    parser.add_argument(&#39;file&#39;, help=&#39;The DIM output file to read.&#39;)
    args = parser.parse_args()

    # Read the data
    data = DIM(args.file)
    data.collect()

    # Print out the information
    if args.mode == &#39;pol&#39;:
        data.printTensor(iso=True, ani=args.ani, unit=args.unit)
    elif args.mode == &#39;coords&#39;:
        if args.num:
            data.printCoords(mode=&#39;num&#39;)
        else:
            data.printCoords()
    elif args.mode == &#39;cross&#39;:
        data.printOptical(property=&#39;cross-section&#39;, unit=args.unit,
                          absunit=args.absunit)
    elif args.mode == &#39;molar&#39;:
        data.printOptical(property=&#39;absorptivitty&#39;, unit=args.unit)
    elif args.mode == &#39;absorbance&#39;:
        data.printOptical(property=&#39;absorbance&#39;, unit=args.unit,
                          concentration=args.conc, pathlength=args.path)
    elif args.mode == &#39;transmittance&#39;:
        data.printOptical(property=&#39;transmittance&#39;, unit=args.unit,
                          concentration=args.conc, pathlength=args.path)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dimpy" href="index.html">dimpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="dimpy.dimpy.gui" href="#dimpy.dimpy.gui">gui</a></code></li>
<li><code><a title="dimpy.dimpy.main" href="#dimpy.dimpy.main">main</a></code></li>
<li><code><a title="dimpy.dimpy.plot" href="#dimpy.dimpy.plot">plot</a></code></li>
<li><code><a title="dimpy.dimpy.show" href="#dimpy.dimpy.show">show</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>