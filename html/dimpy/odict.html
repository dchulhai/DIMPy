<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>dimpy.odict API documentation</title>
<meta name="description" content="odict
~~~~~ â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dimpy.odict</code></h1>
</header>
<section id="section-intro">
<p>odict
~~~~~</p>
<p>This module is an example implementation of an ordered dict for the
collections module.
It's not written for performance (it actually
performs pretty bad) but to show how the API works.</p>
<h1 id="questions-and-answers">Questions and Answers</h1>
<p>Why would anyone need ordered dicts?</p>
<pre><code>Dicts in python are unordered which means that the order of items when
iterating over dicts is undefined.  As a matter of fact it is most of
the time useless and differs from implementation to implementation.

Many developers stumble upon that problem sooner or later when
comparing the output of doctests which often does not match the order
the developer thought it would.

Also XML systems such as Genshi have their problems with unordered
dicts as the input and output ordering of tag attributes is often
mixed up because the ordering is lost when converting the data into
a dict.  Switching to lists is often not possible because the
complexity of a lookup is too high.

Another very common case is metaprogramming.  The default namespace
of a class in python is a dict.  With Python 3 it becomes possible
to replace it with a different object which could be an ordered dict.
Django is already doing something similar with a hack that assigns
numbers to some descriptors initialized in the class body of a
specific subclass to restore the ordering after class creation.

When porting code from programming languages such as PHP and Ruby
where the item-order in a dict is guaranteed it's also a great help
to have an equivalent data structure in Python to ease the transition.
</code></pre>
<p>Where are new keys added?</p>
<pre><code>At the end.  This behavior is consistent with Ruby 1.9 Hashmaps
and PHP Arrays.  It also matches what common ordered dict
implementations do currently.
</code></pre>
<p>What happens if an existing key is reassigned?</p>
<pre><code>The key is *not* moved.  This is consitent with existing
implementations and can be changed by a subclass very easily::

    class movingodict(odict):
        def __setitem__(self, key, value):
            self.pop(key, None)
            odict.__setitem__(self, key, value)

Moving keys to the end of a ordered dict on reassignment is not
very useful for most applications.
</code></pre>
<p>Does it mean the dict keys are sorted by a sort expression?</p>
<pre><code>That's not the case.  The odict only guarantees that there is an order
and that newly inserted keys are inserted at the end of the dict.  If
you want to sort it you can do so, but newly added keys are again added
at the end of the dict.
</code></pre>
<p>I initializes the odict with a dict literal but the keys are not
ordered like they should!</p>
<pre><code>Dict literals in Python generate dict objects and as such the order of
their items is not guaranteed.  Before they are passed to the odict
constructor they are already unordered.
</code></pre>
<p>What happens if keys appear multiple times in the list passed to the
constructor?</p>
<pre><code>The same as for the dict.  The latter item overrides the former.  This
has the side-effect that the position of the first key is used because
the key is actually overwritten:

&gt;&gt;&gt; odict([('a', 1), ('b', 2), ('a', 3)])
odict.odict([('a', 3), ('b', 2)])

This behavor is consistent with existing implementation in Python
and the PHP array and the hashmap in Ruby 1.9.
</code></pre>
<p>This odict doesn't scale!</p>
<pre><code>Yes it doesn't.  The delitem operation is O(n).  This is file is a
mockup of a real odict that could be implemented for collections
based on an linked list.
</code></pre>
<p>Why is there no .insert()?</p>
<pre><code>There are few situations where you really want to insert a key at
an specified index.  To now make the API too complex the proposed
solution for this situation is creating a list of items, manipulating
that and converting it back into an odict:

&gt;&gt;&gt; d = odict([('a', 42), ('b', 23), ('c', 19)])
&gt;&gt;&gt; l = d.items()
&gt;&gt;&gt; l.insert(1, ('x', 0))
&gt;&gt;&gt; odict(l)
odict.odict([('a', 42), ('x', 0), ('b', 23), ('c', 19)])
</code></pre>
<p>:copyright: (c) 2008 by Armin Ronacher and PEP 273 authors.
:license: modified BSD license.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># -*- coding: utf-8 -*-
&#34;&#34;&#34;
    odict
    ~~~~~

    This module is an example implementation of an ordered dict for the
    collections module.  It&#39;s not written for performance (it actually
    performs pretty bad) but to show how the API works.


    Questions and Answers
    =====================

    Why would anyone need ordered dicts?

        Dicts in python are unordered which means that the order of items when
        iterating over dicts is undefined.  As a matter of fact it is most of
        the time useless and differs from implementation to implementation.

        Many developers stumble upon that problem sooner or later when
        comparing the output of doctests which often does not match the order
        the developer thought it would.

        Also XML systems such as Genshi have their problems with unordered
        dicts as the input and output ordering of tag attributes is often
        mixed up because the ordering is lost when converting the data into
        a dict.  Switching to lists is often not possible because the
        complexity of a lookup is too high.

        Another very common case is metaprogramming.  The default namespace
        of a class in python is a dict.  With Python 3 it becomes possible
        to replace it with a different object which could be an ordered dict.
        Django is already doing something similar with a hack that assigns
        numbers to some descriptors initialized in the class body of a
        specific subclass to restore the ordering after class creation.

        When porting code from programming languages such as PHP and Ruby
        where the item-order in a dict is guaranteed it&#39;s also a great help
        to have an equivalent data structure in Python to ease the transition.

    Where are new keys added?

        At the end.  This behavior is consistent with Ruby 1.9 Hashmaps
        and PHP Arrays.  It also matches what common ordered dict
        implementations do currently.

    What happens if an existing key is reassigned?

        The key is *not* moved.  This is consitent with existing
        implementations and can be changed by a subclass very easily::

            class movingodict(odict):
                def __setitem__(self, key, value):
                    self.pop(key, None)
                    odict.__setitem__(self, key, value)

        Moving keys to the end of a ordered dict on reassignment is not
        very useful for most applications.

    Does it mean the dict keys are sorted by a sort expression?

        That&#39;s not the case.  The odict only guarantees that there is an order
        and that newly inserted keys are inserted at the end of the dict.  If
        you want to sort it you can do so, but newly added keys are again added
        at the end of the dict.

    I initializes the odict with a dict literal but the keys are not
    ordered like they should!

        Dict literals in Python generate dict objects and as such the order of
        their items is not guaranteed.  Before they are passed to the odict
        constructor they are already unordered.

    What happens if keys appear multiple times in the list passed to the
    constructor?

        The same as for the dict.  The latter item overrides the former.  This
        has the side-effect that the position of the first key is used because
        the key is actually overwritten:

        &gt;&gt;&gt; odict([(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;a&#39;, 3)])
        odict.odict([(&#39;a&#39;, 3), (&#39;b&#39;, 2)])

        This behavor is consistent with existing implementation in Python
        and the PHP array and the hashmap in Ruby 1.9.

    This odict doesn&#39;t scale!

        Yes it doesn&#39;t.  The delitem operation is O(n).  This is file is a
        mockup of a real odict that could be implemented for collections
        based on an linked list.

    Why is there no .insert()?

        There are few situations where you really want to insert a key at
        an specified index.  To now make the API too complex the proposed
        solution for this situation is creating a list of items, manipulating
        that and converting it back into an odict:

        &gt;&gt;&gt; d = odict([(&#39;a&#39;, 42), (&#39;b&#39;, 23), (&#39;c&#39;, 19)])
        &gt;&gt;&gt; l = d.items()
        &gt;&gt;&gt; l.insert(1, (&#39;x&#39;, 0))
        &gt;&gt;&gt; odict(l)
        odict.odict([(&#39;a&#39;, 42), (&#39;x&#39;, 0), (&#39;b&#39;, 23), (&#39;c&#39;, 19)])

    :copyright: (c) 2008 by Armin Ronacher and PEP 273 authors.
    :license: modified BSD license.
&#34;&#34;&#34;
from copy import deepcopy

missing = object()


class odict(dict):
    &#34;&#34;&#34;
    Ordered dict example implementation.

    This is the proposed interface for a an ordered dict as proposed on the
    Python mailinglist (proposal_).

    It&#39;s a dict subclass and provides some list functions.  The implementation
    of this class is inspired by the implementation of Babel but incorporates
    some ideas from the `ordereddict`_ and Django&#39;s ordered dict.

    The constructor and `update()` both accept iterables of tuples as well as
    mappings:

    &gt;&gt;&gt; d = odict([(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;)])
    &gt;&gt;&gt; d.update({&#39;foo&#39;: &#39;bar&#39;})
    &gt;&gt;&gt; d
    odict.odict([(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;)])
    
    Keep in mind that when updating from dict-literals the order is not
    preserved as these dicts are unsorted!

    You can copy an odict like a dict by using the constructor, `copy.copy`
    or the `copy` method and make deep copies with `copy.deepcopy`:

    &gt;&gt;&gt; from copy import copy, deepcopy
    &gt;&gt;&gt; copy(d)
    odict.odict([(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;)])
    &gt;&gt;&gt; d.copy()
    odict.odict([(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;)])
    &gt;&gt;&gt; odict(d)
    odict.odict([(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;)])
    &gt;&gt;&gt; d[&#39;spam&#39;] = []
    &gt;&gt;&gt; d2 = deepcopy(d)
    &gt;&gt;&gt; d2[&#39;spam&#39;].append(&#39;eggs&#39;)
    &gt;&gt;&gt; d
    odict.odict([(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;), (&#39;spam&#39;, [])])
    &gt;&gt;&gt; d2
    odict.odict([(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;), (&#39;spam&#39;, [&#39;eggs&#39;])])

    All iteration methods as well as `keys`, `values` and `items` return
    the values ordered by the the time the key-value pair is inserted:

    &gt;&gt;&gt; d.keys()
    [&#39;a&#39;, &#39;c&#39;, &#39;foo&#39;, &#39;spam&#39;]
    &gt;&gt;&gt; d.values()
    [&#39;b&#39;, &#39;d&#39;, &#39;bar&#39;, []]
    &gt;&gt;&gt; d.items()
    [(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;), (&#39;spam&#39;, [])]
    &gt;&gt;&gt; list(d.iterkeys())
    [&#39;a&#39;, &#39;c&#39;, &#39;foo&#39;, &#39;spam&#39;]
    &gt;&gt;&gt; list(d.itervalues())
    [&#39;b&#39;, &#39;d&#39;, &#39;bar&#39;, []]
    &gt;&gt;&gt; list(d.iteritems())
    [(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;), (&#39;spam&#39;, [])]

    Index based lookup is supported too by `byindex` which returns the
    key/value pair for an index:

    &gt;&gt;&gt; d.byindex(2)
    (&#39;foo&#39;, &#39;bar&#39;)

    You can reverse the odict as well:

    &gt;&gt;&gt; d.reverse()
    &gt;&gt;&gt; d
    odict.odict([(&#39;spam&#39;, []), (&#39;foo&#39;, &#39;bar&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;a&#39;, &#39;b&#39;)])
    
    And sort it like a list:

    &gt;&gt;&gt; d.sort(key=lambda x: x[0].lower())
    &gt;&gt;&gt; d
    odict.odict([(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;), (&#39;spam&#39;, [])])

    .. _proposal: http://thread.gmane.org/gmane.comp.python.devel/95316
    .. _ordereddict: http://www.xs4all.nl/~anthon/Python/ordereddict/
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        dict.__init__(self)
        self._keys = []
        self.update(*args, **kwargs)

    def __delitem__(self, key):
        dict.__delitem__(self, key)
        self._keys.remove(key)

    def __setitem__(self, key, item):
        if key not in self:
            self._keys.append(key)
        dict.__setitem__(self, key, item)

    def __deepcopy__(self, memo=None):
        if memo is None:
            memo = {}
        d = memo.get(id(self), missing)
        if d is not missing:
            return d
        memo[id(self)] = d = self.__class__()
        dict.__init__(d, deepcopy(self.items(), memo))
        d._keys = self._keys[:]
        return d

    def __getstate__(self):
        return {&#39;items&#39;: dict(self), &#39;keys&#39;: self._keys}

    def __setstate__(self, d):
        self._keys = d[&#39;keys&#39;]
        dict.update(d[&#39;items&#39;])

    def __reversed__(self):
        return reversed(self._keys)

    def __eq__(self, other):
        if isinstance(other, odict):
            if not dict.__eq__(self, other):
                return False
            return self.items() == other.items()
        return dict.__eq__(self, other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __cmp__(self, other):
        if isinstance(other, odict):
            return cmp(self.items(), other.items())
        elif isinstance(other, dict):
            return dict.__cmp__(self, other)
        return NotImplemented

    @classmethod
    def fromkeys(cls, iterable, default=None):
        return cls((key, default) for key in iterable)

    def clear(self):
        del self._keys[:]
        dict.clear(self)

    def copy(self):
        return self.__class__(self)

    def items(self):
        return zip(self._keys, self.values())

    def iteritems(self):
        return zip(self._keys, self.itervalues())

    def keys(self):
        return self._keys[:]

    def iterkeys(self):
        return iter(self._keys)

    def pop(self, key, default=missing):
        if default is missing:
            return dict.pop(self, key)
        elif key not in self:
            return default
        self._keys.remove(key)
        return dict.pop(self, key, default)

    def popitem(self, key):
        self._keys.remove(key)
        return dict.popitem(key)

    def setdefault(self, key, default=None):
        if key not in self:
            self._keys.append(key)
        dict.setdefault(self, key, default)

    def update(self, *args, **kwargs):
        sources = []
        if len(args) == 1:
            if hasattr(args[0], &#39;iteritems&#39;):
                sources.append(args[0].iteritems())
            else:
                sources.append(iter(args[0]))
        elif args:
            raise TypeError(&#39;expected at most one positional argument&#39;)
        if kwargs:
            sources.append(kwargs.iteritems())
        for iterable in sources:
            for key, val in iterable:
                self[key] = val

    def values(self):
        return map(self.get, self._keys)

    def itervalues(self):
        return map(self.get, self._keys)

    def index(self, item):
        return self._keys.index(item)

    def byindex(self, item):
        key = self._keys[item]
        return (key, dict.__getitem__(self, key))

    def reverse(self):
        self._keys.reverse()

    def sort(self, *args, **kwargs):
        self._keys.sort(*args, **kwargs)

    def __repr__(self):
        return &#39;odict.odict(%r)&#39; % self.items()

    __copy__ = copy
    __iter__ = iterkeys


if __name__ == &#39;__main__&#39;:
    import doctest
    doctest.testmod()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dimpy.odict.odict"><code class="flex name class">
<span>class <span class="ident">odict</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Ordered dict example implementation.</p>
<p>This is the proposed interface for a an ordered dict as proposed on the
Python mailinglist (proposal_).</p>
<p>It's a dict subclass and provides some list functions.
The implementation
of this class is inspired by the implementation of Babel but incorporates
some ideas from the <code>ordereddict</code>_ and Django's ordered dict.</p>
<p>The constructor and <code>update()</code> both accept iterables of tuples as well as
mappings:</p>
<pre><code class="python-repl">&gt;&gt;&gt; d = odict([('a', 'b'), ('c', 'd')])
&gt;&gt;&gt; d.update({'foo': 'bar'})
&gt;&gt;&gt; d
odict.odict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])
</code></pre>
<p>Keep in mind that when updating from dict-literals the order is not
preserved as these dicts are unsorted!</p>
<p>You can copy an odict like a dict by using the constructor, <code>copy.copy</code>
or the <code>copy</code> method and make deep copies with <code>copy.deepcopy</code>:</p>
<pre><code class="python-repl">&gt;&gt;&gt; from copy import copy, deepcopy
&gt;&gt;&gt; copy(d)
odict.odict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])
&gt;&gt;&gt; d.copy()
odict.odict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])
&gt;&gt;&gt; odict(d)
odict.odict([('a', 'b'), ('c', 'd'), ('foo', 'bar')])
&gt;&gt;&gt; d['spam'] = []
&gt;&gt;&gt; d2 = deepcopy(d)
&gt;&gt;&gt; d2['spam'].append('eggs')
&gt;&gt;&gt; d
odict.odict([('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', [])])
&gt;&gt;&gt; d2
odict.odict([('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', ['eggs'])])
</code></pre>
<p>All iteration methods as well as <code>keys</code>, <code>values</code> and <code>items</code> return
the values ordered by the the time the key-value pair is inserted:</p>
<pre><code class="python-repl">&gt;&gt;&gt; d.keys()
['a', 'c', 'foo', 'spam']
&gt;&gt;&gt; d.values()
['b', 'd', 'bar', []]
&gt;&gt;&gt; d.items()
[('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', [])]
&gt;&gt;&gt; list(d.iterkeys())
['a', 'c', 'foo', 'spam']
&gt;&gt;&gt; list(d.itervalues())
['b', 'd', 'bar', []]
&gt;&gt;&gt; list(d.iteritems())
[('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', [])]
</code></pre>
<p>Index based lookup is supported too by <code>byindex</code> which returns the
key/value pair for an index:</p>
<pre><code class="python-repl">&gt;&gt;&gt; d.byindex(2)
('foo', 'bar')
</code></pre>
<p>You can reverse the odict as well:</p>
<pre><code class="python-repl">&gt;&gt;&gt; d.reverse()
&gt;&gt;&gt; d
odict.odict([('spam', []), ('foo', 'bar'), ('c', 'd'), ('a', 'b')])
</code></pre>
<p>And sort it like a list:</p>
<pre><code class="python-repl">&gt;&gt;&gt; d.sort(key=lambda x: x[0].lower())
&gt;&gt;&gt; d
odict.odict([('a', 'b'), ('c', 'd'), ('foo', 'bar'), ('spam', [])])
</code></pre>
<p>.. _proposal: <a href="http://thread.gmane.org/gmane.comp.python.devel/95316">http://thread.gmane.org/gmane.comp.python.devel/95316</a>
.. _ordereddict: <a href="http://www.xs4all.nl/~anthon/Python/ordereddict/">http://www.xs4all.nl/~anthon/Python/ordereddict/</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class odict(dict):
    &#34;&#34;&#34;
    Ordered dict example implementation.

    This is the proposed interface for a an ordered dict as proposed on the
    Python mailinglist (proposal_).

    It&#39;s a dict subclass and provides some list functions.  The implementation
    of this class is inspired by the implementation of Babel but incorporates
    some ideas from the `ordereddict`_ and Django&#39;s ordered dict.

    The constructor and `update()` both accept iterables of tuples as well as
    mappings:

    &gt;&gt;&gt; d = odict([(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;)])
    &gt;&gt;&gt; d.update({&#39;foo&#39;: &#39;bar&#39;})
    &gt;&gt;&gt; d
    odict.odict([(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;)])
    
    Keep in mind that when updating from dict-literals the order is not
    preserved as these dicts are unsorted!

    You can copy an odict like a dict by using the constructor, `copy.copy`
    or the `copy` method and make deep copies with `copy.deepcopy`:

    &gt;&gt;&gt; from copy import copy, deepcopy
    &gt;&gt;&gt; copy(d)
    odict.odict([(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;)])
    &gt;&gt;&gt; d.copy()
    odict.odict([(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;)])
    &gt;&gt;&gt; odict(d)
    odict.odict([(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;)])
    &gt;&gt;&gt; d[&#39;spam&#39;] = []
    &gt;&gt;&gt; d2 = deepcopy(d)
    &gt;&gt;&gt; d2[&#39;spam&#39;].append(&#39;eggs&#39;)
    &gt;&gt;&gt; d
    odict.odict([(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;), (&#39;spam&#39;, [])])
    &gt;&gt;&gt; d2
    odict.odict([(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;), (&#39;spam&#39;, [&#39;eggs&#39;])])

    All iteration methods as well as `keys`, `values` and `items` return
    the values ordered by the the time the key-value pair is inserted:

    &gt;&gt;&gt; d.keys()
    [&#39;a&#39;, &#39;c&#39;, &#39;foo&#39;, &#39;spam&#39;]
    &gt;&gt;&gt; d.values()
    [&#39;b&#39;, &#39;d&#39;, &#39;bar&#39;, []]
    &gt;&gt;&gt; d.items()
    [(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;), (&#39;spam&#39;, [])]
    &gt;&gt;&gt; list(d.iterkeys())
    [&#39;a&#39;, &#39;c&#39;, &#39;foo&#39;, &#39;spam&#39;]
    &gt;&gt;&gt; list(d.itervalues())
    [&#39;b&#39;, &#39;d&#39;, &#39;bar&#39;, []]
    &gt;&gt;&gt; list(d.iteritems())
    [(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;), (&#39;spam&#39;, [])]

    Index based lookup is supported too by `byindex` which returns the
    key/value pair for an index:

    &gt;&gt;&gt; d.byindex(2)
    (&#39;foo&#39;, &#39;bar&#39;)

    You can reverse the odict as well:

    &gt;&gt;&gt; d.reverse()
    &gt;&gt;&gt; d
    odict.odict([(&#39;spam&#39;, []), (&#39;foo&#39;, &#39;bar&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;a&#39;, &#39;b&#39;)])
    
    And sort it like a list:

    &gt;&gt;&gt; d.sort(key=lambda x: x[0].lower())
    &gt;&gt;&gt; d
    odict.odict([(&#39;a&#39;, &#39;b&#39;), (&#39;c&#39;, &#39;d&#39;), (&#39;foo&#39;, &#39;bar&#39;), (&#39;spam&#39;, [])])

    .. _proposal: http://thread.gmane.org/gmane.comp.python.devel/95316
    .. _ordereddict: http://www.xs4all.nl/~anthon/Python/ordereddict/
    &#34;&#34;&#34;

    def __init__(self, *args, **kwargs):
        dict.__init__(self)
        self._keys = []
        self.update(*args, **kwargs)

    def __delitem__(self, key):
        dict.__delitem__(self, key)
        self._keys.remove(key)

    def __setitem__(self, key, item):
        if key not in self:
            self._keys.append(key)
        dict.__setitem__(self, key, item)

    def __deepcopy__(self, memo=None):
        if memo is None:
            memo = {}
        d = memo.get(id(self), missing)
        if d is not missing:
            return d
        memo[id(self)] = d = self.__class__()
        dict.__init__(d, deepcopy(self.items(), memo))
        d._keys = self._keys[:]
        return d

    def __getstate__(self):
        return {&#39;items&#39;: dict(self), &#39;keys&#39;: self._keys}

    def __setstate__(self, d):
        self._keys = d[&#39;keys&#39;]
        dict.update(d[&#39;items&#39;])

    def __reversed__(self):
        return reversed(self._keys)

    def __eq__(self, other):
        if isinstance(other, odict):
            if not dict.__eq__(self, other):
                return False
            return self.items() == other.items()
        return dict.__eq__(self, other)

    def __ne__(self, other):
        return not self.__eq__(other)

    def __cmp__(self, other):
        if isinstance(other, odict):
            return cmp(self.items(), other.items())
        elif isinstance(other, dict):
            return dict.__cmp__(self, other)
        return NotImplemented

    @classmethod
    def fromkeys(cls, iterable, default=None):
        return cls((key, default) for key in iterable)

    def clear(self):
        del self._keys[:]
        dict.clear(self)

    def copy(self):
        return self.__class__(self)

    def items(self):
        return zip(self._keys, self.values())

    def iteritems(self):
        return zip(self._keys, self.itervalues())

    def keys(self):
        return self._keys[:]

    def iterkeys(self):
        return iter(self._keys)

    def pop(self, key, default=missing):
        if default is missing:
            return dict.pop(self, key)
        elif key not in self:
            return default
        self._keys.remove(key)
        return dict.pop(self, key, default)

    def popitem(self, key):
        self._keys.remove(key)
        return dict.popitem(key)

    def setdefault(self, key, default=None):
        if key not in self:
            self._keys.append(key)
        dict.setdefault(self, key, default)

    def update(self, *args, **kwargs):
        sources = []
        if len(args) == 1:
            if hasattr(args[0], &#39;iteritems&#39;):
                sources.append(args[0].iteritems())
            else:
                sources.append(iter(args[0]))
        elif args:
            raise TypeError(&#39;expected at most one positional argument&#39;)
        if kwargs:
            sources.append(kwargs.iteritems())
        for iterable in sources:
            for key, val in iterable:
                self[key] = val

    def values(self):
        return map(self.get, self._keys)

    def itervalues(self):
        return map(self.get, self._keys)

    def index(self, item):
        return self._keys.index(item)

    def byindex(self, item):
        key = self._keys[item]
        return (key, dict.__getitem__(self, key))

    def reverse(self):
        self._keys.reverse()

    def sort(self, *args, **kwargs):
        self._keys.sort(*args, **kwargs)

    def __repr__(self):
        return &#39;odict.odict(%r)&#39; % self.items()

    __copy__ = copy
    __iter__ = iterkeys</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="dimpy.odict.odict.fromkeys"><code class="name flex">
<span>def <span class="ident">fromkeys</span></span>(<span>iterable, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a new dict with keys from iterable and values equal to value.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def fromkeys(cls, iterable, default=None):
    return cls((key, default) for key in iterable)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dimpy.odict.odict.byindex"><code class="name flex">
<span>def <span class="ident">byindex</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def byindex(self, item):
    key = self._keys[item]
    return (key, dict.__getitem__(self, key))</code></pre>
</details>
</dd>
<dt id="dimpy.odict.odict.clear"><code class="name flex">
<span>def <span class="ident">clear</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>D.clear() -&gt; None.
Remove all items from D.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear(self):
    del self._keys[:]
    dict.clear(self)</code></pre>
</details>
</dd>
<dt id="dimpy.odict.odict.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>D.copy() -&gt; a shallow copy of D</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    return self.__class__(self)</code></pre>
</details>
</dd>
<dt id="dimpy.odict.odict.index"><code class="name flex">
<span>def <span class="ident">index</span></span>(<span>self, item)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def index(self, item):
    return self._keys.index(item)</code></pre>
</details>
</dd>
<dt id="dimpy.odict.odict.items"><code class="name flex">
<span>def <span class="ident">items</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>D.items() -&gt; a set-like object providing a view on D's items</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def items(self):
    return zip(self._keys, self.values())</code></pre>
</details>
</dd>
<dt id="dimpy.odict.odict.iteritems"><code class="name flex">
<span>def <span class="ident">iteritems</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iteritems(self):
    return zip(self._keys, self.itervalues())</code></pre>
</details>
</dd>
<dt id="dimpy.odict.odict.iterkeys"><code class="name flex">
<span>def <span class="ident">iterkeys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def iterkeys(self):
    return iter(self._keys)</code></pre>
</details>
</dd>
<dt id="dimpy.odict.odict.itervalues"><code class="name flex">
<span>def <span class="ident">itervalues</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def itervalues(self):
    return map(self.get, self._keys)</code></pre>
</details>
</dd>
<dt id="dimpy.odict.odict.keys"><code class="name flex">
<span>def <span class="ident">keys</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>D.keys() -&gt; a set-like object providing a view on D's keys</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def keys(self):
    return self._keys[:]</code></pre>
</details>
</dd>
<dt id="dimpy.odict.odict.pop"><code class="name flex">
<span>def <span class="ident">pop</span></span>(<span>self, key, default=&lt;object object&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.
If key is not found, d is returned if given, otherwise KeyError is raised</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pop(self, key, default=missing):
    if default is missing:
        return dict.pop(self, key)
    elif key not in self:
        return default
    self._keys.remove(key)
    return dict.pop(self, key, default)</code></pre>
</details>
</dd>
<dt id="dimpy.odict.odict.popitem"><code class="name flex">
<span>def <span class="ident">popitem</span></span>(<span>self, key)</span>
</code></dt>
<dd>
<div class="desc"><p>D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a
2-tuple; but raise KeyError if D is empty.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def popitem(self, key):
    self._keys.remove(key)
    return dict.popitem(key)</code></pre>
</details>
</dd>
<dt id="dimpy.odict.odict.reverse"><code class="name flex">
<span>def <span class="ident">reverse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reverse(self):
    self._keys.reverse()</code></pre>
</details>
</dd>
<dt id="dimpy.odict.odict.setdefault"><code class="name flex">
<span>def <span class="ident">setdefault</span></span>(<span>self, key, default=None)</span>
</code></dt>
<dd>
<div class="desc"><p>D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setdefault(self, key, default=None):
    if key not in self:
        self._keys.append(key)
    dict.setdefault(self, key, default)</code></pre>
</details>
</dd>
<dt id="dimpy.odict.odict.sort"><code class="name flex">
<span>def <span class="ident">sort</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sort(self, *args, **kwargs):
    self._keys.sort(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="dimpy.odict.odict.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>D.update([E, ]**F) -&gt; None.
Update D from dict/iterable E and F.
If E is present and has a .keys() method, then does:
for k in E: D[k] = E[k]
If E is present and lacks a .keys() method, then does:
for k, v in E: D[k] = v
In either case, this is followed by: for k in F:
D[k] = F[k]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, *args, **kwargs):
    sources = []
    if len(args) == 1:
        if hasattr(args[0], &#39;iteritems&#39;):
            sources.append(args[0].iteritems())
        else:
            sources.append(iter(args[0]))
    elif args:
        raise TypeError(&#39;expected at most one positional argument&#39;)
    if kwargs:
        sources.append(kwargs.iteritems())
    for iterable in sources:
        for key, val in iterable:
            self[key] = val</code></pre>
</details>
</dd>
<dt id="dimpy.odict.odict.values"><code class="name flex">
<span>def <span class="ident">values</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>D.values() -&gt; an object providing a view on D's values</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def values(self):
    return map(self.get, self._keys)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul>
<li><a href="#questions-and-answers">Questions and Answers</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dimpy" href="index.html">dimpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dimpy.odict.odict" href="#dimpy.odict.odict">odict</a></code></h4>
<ul class="two-column">
<li><code><a title="dimpy.odict.odict.byindex" href="#dimpy.odict.odict.byindex">byindex</a></code></li>
<li><code><a title="dimpy.odict.odict.clear" href="#dimpy.odict.odict.clear">clear</a></code></li>
<li><code><a title="dimpy.odict.odict.copy" href="#dimpy.odict.odict.copy">copy</a></code></li>
<li><code><a title="dimpy.odict.odict.fromkeys" href="#dimpy.odict.odict.fromkeys">fromkeys</a></code></li>
<li><code><a title="dimpy.odict.odict.index" href="#dimpy.odict.odict.index">index</a></code></li>
<li><code><a title="dimpy.odict.odict.items" href="#dimpy.odict.odict.items">items</a></code></li>
<li><code><a title="dimpy.odict.odict.iteritems" href="#dimpy.odict.odict.iteritems">iteritems</a></code></li>
<li><code><a title="dimpy.odict.odict.iterkeys" href="#dimpy.odict.odict.iterkeys">iterkeys</a></code></li>
<li><code><a title="dimpy.odict.odict.itervalues" href="#dimpy.odict.odict.itervalues">itervalues</a></code></li>
<li><code><a title="dimpy.odict.odict.keys" href="#dimpy.odict.odict.keys">keys</a></code></li>
<li><code><a title="dimpy.odict.odict.pop" href="#dimpy.odict.odict.pop">pop</a></code></li>
<li><code><a title="dimpy.odict.odict.popitem" href="#dimpy.odict.odict.popitem">popitem</a></code></li>
<li><code><a title="dimpy.odict.odict.reverse" href="#dimpy.odict.odict.reverse">reverse</a></code></li>
<li><code><a title="dimpy.odict.odict.setdefault" href="#dimpy.odict.odict.setdefault">setdefault</a></code></li>
<li><code><a title="dimpy.odict.odict.sort" href="#dimpy.odict.odict.sort">sort</a></code></li>
<li><code><a title="dimpy.odict.odict.update" href="#dimpy.odict.odict.update">update</a></code></li>
<li><code><a title="dimpy.odict.odict.values" href="#dimpy.odict.odict.values">values</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>