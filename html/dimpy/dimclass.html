<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>dimpy.dimclass API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dimpy.dimclass</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from copy import deepcopy
from os.path import splitext
from .constants import elem, atomic_mass, atomic_radius, \
    HART2EV, HART2NM, AVOGADRO, PI, LIGHT_AU, NOCONV, ANGSTROM2BOHR, \
    ANGSTROM2NM, ANGSTROM2CM, ANGSTROM2M
from numpy import where, concatenate, vectorize, average, dot, eye, array, \
    sum, trace, empty, zeros, absolute, power, diagflat, zeros_like, \
    asarray, argsort, errstate
from numpy import sqrt as npsqrt
from numpy.linalg import eig, LinAlgError
from math import radians, cos, sin, sqrt
from .dimtools import calc_bonds, minmax_pdist
import sys
import os
import re


class DIMError(Exception):
    &#39;&#39;&#39;Error class for DIM errors.

    Parameters
    ----------
    msg : :obj:`str`
        The message to give to the user.

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; try:
        ...     filedata = dim.quick_test(&#39;file.dim&#39;)
        ... except dim.DIMError as d:
        ...     sys.exit(str(d))

    &#39;&#39;&#39;
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg


class DIM(object):
    &#39;&#39;&#39;\
    Stores the DIM output data.

    The :class:`DIM` class reads in the data of a DIM output file and
    provides a high-level interface to help with data manipulation
    and displaying the data.

    Parameters
    ----------
    name : :obj:`str`
        The name of the DIM output file to associate with this class.

    Attributes
    ----------
    filename : :obj:`str`
        The name if the DIM output file associated with this class.
    filetype : :obj:`str`
        The file type, { &#39;input&#39;, &#39;output&#39; }
    key : :obj:`dict`
        A dictionary containing the input keys from the input block
    calctype : :obj:`str`
        The type of calculation that was run { &#39;STATIC&#39;, &#39;FD&#39; }
    natoms : :obj:`int`
        The number of atoms in the nanoparticle.
    coordinates : :obj:`numpy.ndarray` of shape ``natoms`` x 3
        The cartesian coordinates of the atoms in the nanoparticle
    atoms : :obj:`numpy.ndarray` of length ``natoms``
        The name of each atom in the nanoparticle
    elements : :obj:`set`
        The elements in the nanoparticle
    npol : :obj:`int`
        The number of frequency-dependent (FD) polarizabilities calculated.
    e_frequencies : :obj:`numpy.ndarray` of length ``npol``
        The electric frequencies the polarizabilities were calculated at
    polarizability : :obj:`numpy.ndarray` of shape ``npol`` x 3 x 3
        The polarizability tensor for each frequency.
    efficiencies : :obj:`numpy.ndarray` of shape ``npol`` x 3
        The spectral efficiencies.  For each frequency, the first
        element is the scattering, the second is the absorbance, and
        the third is the exctinction. This is only valid for FD
        calculations.
    cross_sections : :obj:`numpy.ndarray` of shape ``npol`` x 3
        The spectral cross sections.  For each frequency, the first
        element is the scattering, the second is the absorbance, and the
        third is the exctinction. This is only valid for FD calculations.
    dipoles : :obj:`numpy.ndarray` of shape ``npol`` x ``natoms`` x 3
        The dipole on each atom of the nanoparticle.
        Only available if these were printed in the output file
    charges : :obj:`numpy.ndarray` of shape ``npol`` x ``natoms``
        The charge on each atom of the nanoparticle.
        Only available if these were printed in the output file
        and the calculation was CPIM
    start : :obj:`datetime.datetime`
        The starting time of the calculation
    real_time : :obj:`datetime.timedelta`
        The wall time of the calculation
    cpu_time : :obj:`datetime.timedelta`
        The cpu time of the calculation
    routine_time : :obj:`dict`
        The time it took to perform each routine in the DIM calculation.
    termination : :obj:`str`
        A message that indicates how the DIM calculation ended
    host : :obj:`str`
        The host the calculation was run on
    nprocs : :obj:`int`
        The number of processors used to perform the calculation

    Methods
    -------
    tensor_isotropic(tensors)
        Return the isotropic polarizability for each given polarizability
        tensor
    tensor_anisotropic2(tensors)
        Return the anisotropic polarizability squared for each given
        polarizability tensor

    .. note:: The above two methods are static methods of the DIM class.

    Examples
    --------
    When you instantiate a new DIM class, every field is empty except
    for the filename and filetype attributes

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; static.filename
        &#39;...out&#39;
        &gt;&gt;&gt; static.filetype
        &#39;output&#39;

    .. note:: All :class:`DIM` examples use the :func:`quick_test` function
              to generate the test cases.

    &#39;&#39;&#39;

    def __init__(self, name):
        &#39;&#39;&#39;\
        Initiallize the DIM class.

        :param name: The name of the DIM output file to associate with this class.
        &#39;&#39;&#39;
        # Find extention
        ftype = splitext(name)[1]
        if ftype not in (&#39;.out&#39;, &#39;.inp&#39;, &#39;.dim&#39;):
            raise ValueError(ftype+&#39; not a recognized extention&#39;)
        self.filetype = &#39;output&#39; if ftype == &#39;.out&#39; else &#39;input&#39;
        self.filename = name

        # List of input keys.
        self.blockkeys = (&#39;XYZ&#39;,)
        # Each element is a possible key
        for e in elem[1:]:
            self.blockkeys += (e.upper(),)
        self.linekeys = (&#39;TOLERANCE&#39;, &#39;TOTALCHARGE&#39;, &#39;DAMPING&#39;, &#39;PRINTLEVEL&#39;,
                         &#39;ALGORITHM&#39;, &#39;NOPRINT&#39;, &#39;PRINT&#39;, &#39;FREQRANGE&#39;,
                         &#39;FREQUENCY&#39;, &#39;OUTPUT&#39;,)
        self.singlekeys = (&#39;CPIM&#39;, &#39;PIM&#39;, &#39;NOPOL&#39;, &#39;NOCHAR&#39;, &#39;NONINTERACTING&#39;,
                           &#39;DEBUG&#39;, &#39;BOHR&#39;,)

        self.calctype = set()
        self.subkey = set()
        self.key = {}
        self.natoms = None
        self.coordinates = None
        self.atoms = None
        self.elements = None
        self.npol = None
        self.e_frequencies = None
        self.polarizability = None
        self.efficiencies = None
        self.cross_sections = None
        self.dipoles = None
        self.charges = None
        self.start = None
        self.real_time = None
        self.cpu_time = None
        self.routine_time = None
        self.termination = None
        self.host = None
        self.nprocs = None
        self._diagonalized = False
        self._minmax = None
        self._bonds = None

    def collect(self, abort=False):
        &#39;&#39;&#39;\
        Read the data from a :class:`DIM` input or output file

        Parameters
        ----------
        abort : :obj:`bool`
            If :obj:`True`, the collector will raise an error when an collection
            error is encountered.  If :obj:`False`, the error will be
            ignored and it will continue collection the remainder of the file.

        Raises
        ------
        DIMError
            An expected section of the output was missing.
            (Other exceptions may also be raised, but are difficult to predict
            because of the nature of parsing an open-ended text file.)

        Examples
        --------
        The :meth:`collect()` method can collect output files:

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; # .collect() is called as the last step of quick_test()
            &gt;&gt;&gt; # Example
            &gt;&gt;&gt; # run(inputfile, outputfile)
            &gt;&gt;&gt; # data = DIM(outputfile)
            &gt;&gt;&gt; # data.collect()
            &gt;&gt;&gt;
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; static.atoms # doctest: +NORMALIZE_WHITESPACE
            array([&#39;Ag&#39;, &#39;Ag&#39;], dtype=&#39;|S2&#39;)
            &gt;&gt;&gt; static.natoms
            2
            &gt;&gt;&gt; static.elements
            set([&#39;Ag&#39;])
            &gt;&gt;&gt; static.nelements
            1
            &gt;&gt;&gt; static.key[&#39;XYZ&#39;]
            (&#39;Ag 0.0 0.0 0.0&#39;, &#39;Ag 0.0 0.0 4.0&#39;)

        Note that the results of a static and frequency-dependent calculation will be
        in a slightly different format.

            &gt;&gt;&gt; static.npol
            1
            &gt;&gt;&gt; static.e_frequencies
            array([ 0.])
            &gt;&gt;&gt; static.polarizability
            array([[[ 71.324,   0.   ,   0.   ],
                    [  0.   ,  71.324,   0.   ],
                    [  0.   ,   0.   ,  93.755]]])
            &gt;&gt;&gt; static.efficiencies
            &gt;&gt;&gt; static.cross_sections
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.npol
            2
            &gt;&gt;&gt; fd.e_frequencies
            array([ 0.128623,  0.135972])
            &gt;&gt;&gt; fd.polarizability
            array([[[ 200.794+264.06j ,    0.000  +0.j   ,    0.000  +0.j   ],
                    [   0.000  +0.j   ,  200.794+264.06j ,    0.000  +0.j   ],
                    [   0.000  +0.j   ,    0.000  +0.j   , -188.906+296.316j]],
            &lt;BLANKLINE&gt;
                   [[ -81.283 +99.26j ,    0.000  +0.j   ,    0.000  +0.j   ],
                    [   0.000  +0.j   ,  -81.283 +99.26j ,    0.000  +0.j   ],
                    [   0.000  +0.j   ,    0.000  +0.j   ,  -78.875 +57.359j]]])
            &gt;&gt;&gt; # The following are only collected for FD
            &gt;&gt;&gt; # and if &#39;PRINT EFF&#39; was included in input file
            &gt;&gt;&gt; fd.efficiencies
            array([  8.09150000e-02,   1.84020000e-12])
            &gt;&gt;&gt; fd.cross_sections
            array([  7.22310000e-04,   1.64260000e-14])

        &#39;&#39;&#39;

        # Collect from file
        try:
            # Set the abort flag
            self._abort = abort
            # Read in file
            from .read_file import read_file
            f, indices = read_file(self)
            # Read input block
            from .input_block import collect_input
            collect_input(self, f, indices)
            # Determine calculation type
            self.__det_calc_type()
            # Techical properties
            from .dimproperties import collect_technical
            collect_technical(self, f, indices)
            # Collect all exciting information
            from .dimproperties import collect_dim
            collect_dim(self, f, indices)
            # Collect timing
            from .dimproperties import collect_timing
            collect_timing(self, f, indices)
        # If a known error occured
        except DIMError as d:
            if abort:
                raise DIMError(str(d) + &#39;: &#39; + self.filename)
        # If a known unknown error occured.
        except (IndexError, StopIteration, KeyError):
            msg = &#39;Did the calculation end prematurely?&#39;
            if abort:
                print(&#39;/\\&#39;*int(len(msg)/2), file=sys.stderr)
                print(msg, file=sys.stderr)
                print(&#39;/\\&#39;*int(len(msg)/2), file=sys.stderr)
                print(file=sys.stderr)
                raise
        except ValueError:
            msg = &#39;Possibly a number too large for the format (********)\n&#39;
            msg += &#39;or a string and number running together (WORD1.785)&#39;
            if abort:
                print(&#39;/\\&#39;*27, file=sys.stderr)
                print(msg, file=sys.stderr)
                print(&#39;/\\&#39;*27, file=sys.stderr)
                print(file=sys.stderr)
                raise

    def copy(self):
        &#39;&#39;&#39;\
        Returns a copy of the current instance.
        Equivalent to :obj:`copy.deepcopy` (self).

        Returns
        -------
        copy : :class:`DIM`
            A copy of the current :class:`DIM` instance.

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; example1 = static
            &gt;&gt;&gt; example1 is static
            True
            &gt;&gt;&gt; example2 = static.copy()
            &gt;&gt;&gt; example2 is static
            False

        &#39;&#39;&#39;
        return deepcopy(self)

    def printCoords(self, mode=None, a1=1, a2=None, file=None, latex=False):
        &#39;&#39;&#39;Prints the geometry coordinates to screen.

        Parameters
        ----------
        mode : {&#39;xyz&#39;, &#39;xyz_title&#39;, &#39;num&#39;, &#39;dimblock&#39;}
            Determines how the coordinates will be printed.  If
            omitted, the coordinates will be printed without numbers.

            Valid options are:

                - &#39;num&#39;:       Prints the number of each atom with the element.
                - &#39;xyz&#39;:       Prints the total number of atoms, then a space, then the coordinates.
                - &#39;xyz_title&#39;: Same as &#39;xyz&#39;, but prints the title instead of a space, if a title is available.
                - &#39;dimblock&#39;:  Same as &#39;xyz&#39;, but omits the space altogether.

        a1 : :obj:`int`
            The number of the lowest atom to print
        a2 : :obj:`int`, :obj:`None`
            The number of the highest atom to print.
            If given :obj:`None`, the number of the last atom is used
        file : :obj:`str`, :obj:`file`
            Where to print to.  If omitted, it will print to standard
            output.  You may give the name of a file or an already open
            :obj:`file` object to write to. Or, if `file` is &#39;xyz&#39;, then
            it will create a ``.xyz`` file based on the :attr:`filename`
            attribute and print there.
        latex : :obj:`bool`
            Causes the output to be printed in a LaTeX table type of format.

        Raises
        ------
        ValueError
            An invalid mode is entered

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.printCoords()
            Ag    0.00000000    0.00000000    0.00000000
            Ag    0.00000000    0.00000000    4.00000000
            &gt;&gt;&gt; static.printCoords(mode=&#39;num&#39;)
            1 Ag    0.00000000    0.00000000    0.00000000
            2 Ag    0.00000000    0.00000000    4.00000000
            &gt;&gt;&gt; static.printCoords(mode=&#39;xyz&#39;)
            2
            &lt;BLANKLINE&gt;
            Ag    0.00000000    0.00000000    0.00000000
            Ag    0.00000000    0.00000000    4.00000000
            &gt;&gt;&gt; static.printCoords(latex=True)
             Ag   &amp;    0.000000 &amp;    0.000000 &amp;    0.000000\\\\
             \\hline
             Ag   &amp;    0.000000 &amp;    0.000000 &amp;    4.000000\\\\
             \\hline

        &#39;&#39;&#39;
        valid_modes = (&#39;xyz&#39;, &#39;xyz_title&#39;, &#39;num&#39;, &#39;dimblock&#39;)
        if mode is not None and (mode not in valid_modes):
            raise ValueError(&#39;printCoords(): Invalid mode: &#39;+mode)

        # Create an xyz file if file is True
        if file == &#39;xyz&#39;:
            # Split current extention off filename, then replace with .xyz
            file = &#39;.&#39;.join([os.path.splitext(self.filename)[0], &#39;xyz&#39;])
            # Open, and remember we need to close after
            file = open(file, &#39;w&#39;)
            closebool = True
        # If file is None, use standard out
        elif file is None:
            file = sys.stdout
            closebool = False
        # Otherwise, try to open the file
        else:
            try:
                file = open(file, &#39;w&#39;)
            # If it fails, then it was already an open file
            except TypeError:
                closebool = False
            # If it suceeds, then remmeber that we must close the file
            else:
                closebool = True

        # Convert atom number to index
        a1 -= 1
        # Default to all.
        if a2 is None:
            a2 = len(self.atoms)

        # Determine how to format the line, and make numbers correct
        if mode == &#39;num&#39;:
            # Find string length of largest number to be printed and make that
            # number a string
            maxlen = str(len(str((a2 - a1) + 1)))
            fmt = &#39;{0:&lt;&#39;+maxlen+&#39;} {1:&lt;2}{2[0]:14.8f}{2[1]:14.8f}{2[2]:14.8f}&#39;
            num = 1
        else:
            if latex:
                fmt = &#39;{0:&gt;3}{2:&gt;4}{1[0]:12.6f}{2:&gt;2}{1[1]:12.6f}{2:&gt;2}{1[2]:12.6f}{3:&lt;2}&#39;
            else:
                fmt = &#39;{0:&lt;2}{1[0]:14.8f}{1[1]:14.8f}{1[2]:14.8f}&#39;

        # Make number of atoms
        natoms = len(self.atoms[a1:a2])

        # Print the number of atoms if the mode calls for it
        if mode in (&#39;xyz&#39;, &#39;xyz_title&#39;, &#39;dimblock&#39;):
            print(natoms, file=file)

        # Print a space if &#39;xyz&#39;, or if &#39;xyz_title&#39; and there is no title
        if mode == &#39;xyz&#39; or (mode == &#39;xyz_title&#39; and (&#39;title&#39; not in self or not self.title)):
            print(file=file)
        # Print the title if &#39;xyz_title&#39; and there is a title
        elif mode == &#39;xyz_title&#39;:
            print(self.title, file=file)

        # Print the coordinates
        for i in range(a1, a2):
            if mode == &#39;num&#39;:
                print(fmt.format(num, self.atoms[i], self.coordinates[i]), file=file)
                num += 1
            else:
                if latex:
                    print(fmt.format(self.atoms[i], self.coordinates[i], &#39;&amp;&#39;, r&#39;\\&#39;), file=file)
                    print(r&#39; \hline&#39;, file=file)
                else:
                    print(fmt.format(self.atoms[i], self.coordinates[i]), file=file)

        # Close the file if appropriate
        if closebool:
            file.close()

    def writeCoords(self, a1=1, a2=None):
        &#39;&#39;&#39;This is a shortcut for
        :func:`printCoords(mode=&#39;xyz&#39;, file=&#39;xyz&#39;) &lt;printCoords&gt;`.

        This will write the coordinates to a .xyz file based on the
        name in the filename attribute.

        &#39;&#39;&#39;
        self.printCoords(mode=&#39;xyz&#39;, file=&#39;xyz&#39;, a1=a1, a2=a2)

    def writePDB(self, a1=1, a2=None):
        &#39;&#39;&#39;Writes the coordinates to a .pdb file with the same name
        as the current file.

        Parameters
        ----------
        a1 : :obj:`int`
            The number of the lowest atom to print
        a2 : :obj:`int`, :obj:`None`
            The number of the highest atom to print.
            If given :obj:`None`, the number of the last atom is used

        &#39;&#39;&#39;

        # Define title format
        ft = &#39;CMPND  {0}&#39;
        # Define coordinate format
        fc = (&#39;HETATM{0:&gt;5d}{1:&gt;3}   LIG     1    &#39;
              &#39;{2[0]:&gt;8.3f}{2[1]:&gt;8.3f}{2[2]:&gt;8.3f}  1.00  0.00          &#39;
              &#39;{1:&gt;2}  &#39;)
        # Define bond format
        fb = &#39;CONECT{0:&gt;5d}&#39;

        # Convert atom number to index
        a1 -= 1
        # Default to all.
        if a2 is None:
            a2 = len(self.atoms)

        # Open the file as pdb with same name
        filename = &#39;.&#39;.join([os.path.splitext(self.filename)[0], &#39;pdb&#39;])
        with open(filename, &#39;w&#39;) as fl:

            # pbd Starts with some info.  Give the title if there is one
            if &#39;title&#39; in self and self.title:
                title = ft.format(&#39;MOLECULE: &#39;+self.title)
            else:
                title = ft.format(&#39;UNNAMED&#39;)
            print(title, file=fl)

            # Place the coordinates in the file
            i = 1
            for atom, coord in zip(self.atoms[a1:a2], self.coordinates[a1:a2]):
                print(fc.format(i, atom, coord), file=fl)
                i += 1

            # Place the bonds in the file.  The bonding is redundant, so each
            # atom must be specified and bonds will be listed mutlitple times.
            for i in xrange(self.natoms):

                # Skip atoms we don&#39;t want to show a bond to
                if i &lt; a1 or i &gt; a2:
                    continue

                # Print the bonding keyword
                print(fb.format(i+1), end=&#39;&#39;, file=fl)

                # Find everywhere that this atoms is in the first column
                indx = where(self.bonds[:, 0] == i)[0]

                # Print off all atoms this one is bonded to
                for j in indx:
                    # Skip atoms we don&#39;t want to show a bond to
                    if self.bonds[j, 1] &lt; a1 or self.bonds[j, 1] &gt; a2:
                        continue
                    print(&#39;{0:&gt;5d}&#39;.format(self.bonds[j, 1]+1), end=&#39;&#39;, file=fl)

                # Repeat for the second column
                indx = where(self.bonds[:, 1] == i)[0]
                for j in indx:
                    # Skip atoms we don&#39;t want to show a bond to
                    if self.bonds[j, 0] &lt; a1 or self.bonds[j, 0] &gt; a2:
                        continue
                    print(&#39;{0:&gt;5d}&#39;.format(self.bonds[j, 0]+1), end=&#39;&#39;, file=fl)

                # New line
                print(file=fl)

            # End the file
            print(&#39;END   &#39;, file=fl)

    def join(self, other):
        &#39;&#39;&#39;Concatenates one molecule into the current one.

        The attributes that are concatenated are:

          - :attr:`~.coordinates`
          - :attr:`~.atoms`
          - ``natoms``
          - :attr:`~.elements`
          - :attr:`~.nelements`

        All other properties would be unphysical to concatenate
        and are emptied.

        Parameters
        ----------
        other : :class:`DIM`
            The other :class:`DIM` object to concatenate with this one

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; np1 = dim.quick_test()
            &gt;&gt;&gt; np1.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; np2 = dim.quick_test()
            &gt;&gt;&gt; np2.translate_coordinates([3.0, 0.0, 0.0])
            &gt;&gt;&gt; np2.coordinates
            array([[ 3.,  0.,  0.],
                   [ 3.,  0.,  4.]])
            &gt;&gt;&gt; np1.join(np2)
            &gt;&gt;&gt; np1.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.],
                   [ 3.,  0.,  0.],
                   [ 3.,  0.,  4.]])
            &gt;&gt;&gt; np1.atoms
            array([&#39;Ag&#39;, &#39;Ag&#39;, &#39;Ag&#39;, &#39;Ag&#39;], 
                  dtype=&#39;|S2&#39;)

        &#39;&#39;&#39;
        self.coordinates = concatenate((self.coordinates, other.coordinates))
        self.atoms = concatenate((self.atoms, other.atoms))
        self.natoms = len(self.atoms)
        self.elements.update(other.elements)
        self.nelements = len(self.elements)
        self.empty(ignore=[&#39;coordinates&#39;, &#39;atoms&#39;, &#39;natoms&#39;,
                           &#39;elements&#39;, &#39;nelements&#39;])
        self._bonds = None
        self._minmax = None

    def find_center(self, type=&#39;geometrical&#39;):
        &#39;&#39;&#39;Locates the center of the nanoparticle.

        Parameters
        ----------
        type : {&#39;geometrical&#39;, &#39;center-of-mass&#39;}
            The type of the center-of-mass to locate

        Returns
        -------
        center : :obj:`float`
            The center-of-mass of the nanoparticle

        Raises
        -------
        ValueError
            An invalid type is given.

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; static.find_center()
            array([ 0.,  0.,  2.])

        &#39;&#39;&#39;

        if type == &#39;center-of-mass&#39;:
            wt = self.masses
        elif type == &#39;geometrical&#39;:
            wt = None
        else:
            raise ValueError(&#39;find_center(): Invalid type: &#39;+type)

        # Now find the center of mass
        return average(self.coordinates, axis=0, weights=wt)

    def shift_to_origin(self, type=&#39;geometrical&#39;):
        &#39;&#39;&#39;\
        Shifts the coordinates in place so that the center of the
        molecule is at the origin.

        Parameters
        ----------
        type : {&#39;geometrical&#39;, &#39;center-of-mass&#39;}
            Determines the center type.  See :meth:`find_center`.

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; static.shift_to_origin()
            &gt;&gt;&gt; static.coordinates
            array([[ 0.,  0., -2.],
                   [ 0.,  0.,  2.]])

        &#39;&#39;&#39;
        self.translate_coordinates(-self.find_center(type))

    def radii(self, set):
        &#39;&#39;&#39;\
        Returns the radii for each atom in the nanoparticle.

        Parameters
        ----------
        set : {&#39;vis&#39;, &#39;vdw&#39;}
            Specifies from which set of data you wish
            to collect the radii.  The options are:

                -vis: These radii are good for molecular visualizations but are not physical
                -vdw: These use the van Der Waals radii and are intended to be physical, however not all elements are available.

        Returns
        -------
        radii : :obj:`numpy.ndarray` of length ``natoms``.
            The radii for each atom

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.atoms
            array([&#39;Ag&#39;, &#39;Ag&#39;], 
                  dtype=&#39;|S2&#39;)
            &gt;&gt;&gt; static.radii(&#39;vis&#39;)
            array([ 1.44,  1.44])

        &#39;&#39;&#39;

        # Find radii for each atom
        rad = zeros(self.natoms)
        for i in xrange(self.natoms):
            rad[i] = atomic_radius(self.atoms[i], set)
        return rad

    def translate_coordinates(self, transvec):
        &#39;&#39;&#39;\
        Translates the coordinates in place.

        Parameters
        ----------
        transvec : :obj:`numpy.ndarray` of length 3
            The translation vector by which to translate the coordinates

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; static.translate_coordinates([3.0, 1.0, 0.0])
            &gt;&gt;&gt; static.coordinates
            array([[ 3.,  1.,  0.],
                   [ 3.,  1.,  4.]])

        &#39;&#39;&#39;
        self.coordinates += transvec

    def rotate_coordinates(self, rotmat=None, angle=None, dir=None, rad=False):
        &#39;&#39;&#39;Rotates the coordinates.

        Parameters
        ----------
        rotmat : :obj:`numpy.ndarray` of shape 3 x 3
            The rotation matrix to use to rotate the nanoparticle.
            Mutually exclusive with the `angle` parameter.
        angle : :obj:`float`, :obj:`list` of :obj:`float`
            An angle by which to rotate the coordinates.  If given
            as a :obj:`list`, the coordinates are rotated by each
            angle in the order they are given.
            Mutually exclusive with the `rotmat` parameter.
        dir : {&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;}
            The direction in which to rotate the coordinates
            for a given angle. Required when the `angle` parameter
            is given. If `angle` is given as a :obj:`list`, `dir`
            must be a :obj:`list` of the same length
        rad : :obj:`bool`
            Tells if the angle is in radians or note.

        Raises
        ------
        ValueError
            Invalid arguments are given

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; import numpy
            &gt;&gt;&gt; np1 = dim.quick_test()
            &gt;&gt;&gt; np1.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; np1.rotate_coordinates(angle=90, dir=&#39;X&#39;)
            &gt;&gt;&gt; numpy.around(np1.coordinates)
            array([[ 0.,  0.,  0.],
                   [ 0.,  4.,  0.]])
            &gt;&gt;&gt; np2 = dim.quick_test()
            &gt;&gt;&gt; np2.rotate_coordinates(angle=[45, 45], dir=[&#39;X&#39;, &#39;Z&#39;])
            &gt;&gt;&gt; numpy.around(np2.coordinates, decimals=5)
            array([[ 0.     ,  0.     ,  0.     ],
                   [ 0.     ,  2.82843,  2.82843]])
            &gt;&gt;&gt; np3 = dim.quick_test()
            &gt;&gt;&gt; np3.rotate_coordinates(rotmat=numpy.array([[0.5, 1.0, 1.0],
            ...                                            [1.0, 0.5, 0.0],
            ...                                            [1.0, 0.0, 0.5]]))
            &gt;&gt;&gt; numpy.around(np3.coordinates, decimals=5)
            array([[ 0.,  0.,  0.],
                   [ 4.,  0.,  2.]])

        &#39;&#39;&#39;

        if rotmat is None and angle is None:
            ValueError(&#34;rotate_coordinates(): &#34;
                       &#34;Must choose one of &#39;rotmat&#39; or &#39;angle&#39;&#34;)
        if rotmat is not None and angle is not None:
            ValueError(&#34;rotate_coordinates(): &#34;
                       &#34;Must choose only one of &#39;rotmat&#39; or &#39;angle&#39;&#34;)

        # Create matrix if not given explicitly
        # Create a general 3-D rotation
        if rotmat is None:
            if dir is None:
                raise ValueError(&#34;rotate_coordinates(): &#34;
                                 &#34;&#39;dir&#39; must not be empty with &#39;angle&#39;&#34;)
            if isinstance(angle, list) and not isinstance(dir, list):
                raise ValueError(&#34;rotate_coordinates(): &#34;
                                 &#34;&#39;angle&#39; and &#39;dir&#39; must both be either &#34;
                                 &#34;a &#39;list&#39; or &#39;str&#39;&#34;)
            if not isinstance(angle, list) and isinstance(dir, list):
                raise ValueError(&#34;rotate_coordinates(): &#34;
                                 &#34;&#39;angle&#39; and &#39;dir&#39; must both be either &#34;
                                 &#34;a &#39;list&#39; or &#39;str&#39;&#34;)
            # Make sure lists are the same length, and turn non-list in to list
            if isinstance(angle, list):
                if len(angle) != len(dir):
                    raise ValueError(&#34;rotate_coordinates(): &#34;
                                     &#34;&#39;angle&#39; and &#39;dir&#39; must be the same length&#34;)
            else:
                angle = [angle]
                dir = [dir]

            # Generate the general rotation matrix
            rotmat = eye(3)
            for a, d in zip(angle, dir):
                if not rad:
                    a = radians(a)
                c = cos(a)
                s = sin(a)
                if d.lower() == &#39;x&#39;:
                    temp = array([[ 1,  0,  0 ],
                                  [ 0,  c, -s ],
                                  [ 0,  s,  c ]], dtype=float)
                elif d.lower() == &#39;y&#39;:
                    temp = array([[ c,  0,  s ],
                                  [ 0,  1,  0 ],
                                  [-s,  0,  c ]], dtype=float)
                elif d.lower() == &#39;z&#39;:
                    temp = array([[ c, -s,  0 ],
                                  [ s,  c,  0 ],
                                  [ 0,  0,  1 ]], dtype=float)
                else:
                    raise ValueError(&#34;Unknown value for &#39;dir&#39;: &#34;+str(d))

                # Create the rotmat in rotation order. Not that this is
                # backwards from what you would expect because internally the
                # rotation is done with the coordinates first.
                rotmat = dot(temp, rotmat)

        # Rotate. Use fast MKL routine to do so
        #self.coordinates = rotate(rotmat, self.coordinates)
        self.coordinates = dot(self.coordinates, rotmat)

    def order_coords(self, atom=None, coord=None):
        &#39;&#39;&#39;\
        Reorders the coordinates according to proximity to either
        a specific atom or a point in space.

        Parameters
        ----------
        atom : :obj:`int`
            The atom to reorder by.
        coord : :obj:`numpy.ndarray` of length 3
            The point in space to reorder with respect to.

        Raises
        ------
        ValueError
            One and only one of `atom` and `coord` is not given.

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; np1 = dim.quick_test()
            &gt;&gt;&gt; np1.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; np1.order_coords(coord=[0.0, 0.0, 5.0])
            &gt;&gt;&gt; np1.coordinates
            array([[ 0.,  0.,  4.],
                   [ 0.,  0.,  0.]])
            &gt;&gt;&gt; np2 = dim.quick_test()
            &gt;&gt;&gt; np2.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; np2.order_coords(atom=2)
            &gt;&gt;&gt; np2.coordinates
            array([[ 0.,  0.,  4.],
                   [ 0.,  0.,  0.]])

        &#39;&#39;&#39;

        if atom is None and coord is None:
            raise ValueError(&#39;order_coords(): Must choose one of atoms or coords.&#39;)
        if atom and coord:
            raise ValueError(&#39;order_coords(): Cannot use both atoms and coords.&#39;)

        # First determine the distance from the points
        if atom is not None:
            c = self.coordinates[atom-1]
        else:
            c = coord

        # Sort the distances and return the sorted indices.
        index = argsort(npsqrt(sum((c - self.coordinates)**2, axis=1)))
        # Sort atoms coodinates and modes.
        self.atoms = self.atoms[index]
        self.coordinates = self.coordinates[index]
        self._bonds = None

    def printTensor(self, iso=False, ani=False, unit=&#39;au&#39;, p1=1, p2=None):
        &#39;&#39;&#39;\
        Pretty print the polarizability tensor to standard output.  One
        tensor is printed for each frequency.

        If the calculation was FD,
        then the real and imaginary tensors are printed alongside each other.

        Parameters
        ----------
        iso : :obj:`bool`
            Prints the isotropic polarizability along with the tensor
        ani : :obj:`bool`
            Prints the anisotropic polarizability along with the tensor
        unit : {&#39;au&#39;, &#39;ev&#39;, &#39;nm&#39;}
            Specifies the unit to print the frequency that corresponds
            to each polarizability tensor.
        p1 : :obj:`int`
            The number of the lowest polarizability tensor to print
        a2 : :obj:`int`, :obj:`None`
            The number of the highest polarizability tensor to print.
            If given :obj:`None`, the number of the last atom is used

        Raises
        ------
        DIMError
            No polarizabilities were collected.

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.printTensor(iso=True, ani=True, unit=&#39;ev&#39;)
            &lt;BLANKLINE&gt;
            Static Polarizability
                            X               Y               Z
               X          71.324           0.000           0.000
               Y           0.000          71.324           0.000
               Z           0.000           0.000          93.755
            &lt;BLANKLINE&gt;
            ISOTROPIC PART    =       78.801
            ANISOTROPIC PART  =       22.431
            &lt;BLANKLINE&gt;
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.printTensor(iso=True, ani=True, unit=&#39;ev&#39;)
            &lt;BLANKLINE&gt;
            FD Polarizability: Energy 3.50001 eV
                                           Real                                                Imaginary
                            X               Y               Z                      X               Y               Z
               X         200.794           0.000           0.000      X         264.060           0.000           0.000
               Y           0.000         200.794           0.000      Y           0.000         264.060           0.000
               Z           0.000           0.000        -188.906      Z           0.000           0.000         296.316
            &lt;BLANKLINE&gt;
            ISOTROPIC PART    =       70.894 + 274.812j
            ANISOTROPIC PART  =      391.033
            &lt;BLANKLINE&gt;
            FD Polarizability: Energy 3.69999 eV
                                           Real                                                Imaginary
                            X               Y               Z                      X               Y               Z
               X         -81.283           0.000           0.000      X          99.260           0.000           0.000
               Y           0.000         -81.283           0.000      Y           0.000          99.260           0.000
               Z           0.000           0.000         -78.875      Z           0.000           0.000          57.359
            &lt;BLANKLINE&gt;
            ISOTROPIC PART    =     -80.4803 +  85.293j
            ANISOTROPIC PART  =      41.9701
            &lt;BLANKLINE&gt;

        &#39;&#39;&#39;
        if &#39;polarizability&#39; not in self:
            raise ValueError(&#39;printTensor(): &#39;
                             &#39;No polarizabilities were collected.&#39;)
        # Convert pol number to index
        p1 -= 1
        # Default to all.
        if p2 is None:
            p2 = self.npol

        # Set the unit and energy type
        if not re.match(r&#39;au|ev|nm&#39;, unit, re.I):
            raise ValueError(&#39;printTensor() : Invalid unit: &#39;+unit)
        else:
            unit = {&#39;au&#39;: &#39;a.u.&#39;, &#39;ev&#39;: &#39;eV&#39;, &#39;nm&#39;: &#39;nm&#39;}[unit.lower()]
            etyp = {&#39;a.u.&#39;: &#39;Frequency&#39;,
                    &#39;eV&#39;: &#39;Energy&#39;,
                    &#39;nm&#39;: &#39;Wavelength&#39;}[unit]

        # Set the tensor
        prop = &#39;Polarizability&#39;

        # Start the formatting of the label
        if &#39;RAMAN&#39; in self.calctype:
            lbl = self.v_frequencies
        else:
            with errstate(divide=&#39;ignore&#39;):
                lbl = {&#39;a.u.&#39;: self.e_frequencies,
                       &#39;eV&#39;: HART2EV(self.e_frequencies),
                       &#39;nm&#39;: HART2NM(self.e_frequencies)}[unit]

        # Diagonalized or not
        d = &#39;, Diagonalized&#39; if self._diagonalized else &#39;&#39;

        # Print selected tensors in class
        print()
        for n in range(p1, p2):

            t = self.polarizability[n]
            r = t.real
            i = t.imag

            # Prints out the proper heading depending on the energy type
            # and the unit.
            # First, make the number at most 7 digits with &#39;good&#39; formatting
            # Strip off whitespace
            s = &#39;{0:7g}&#39;.format(lbl[n]).strip()
            # Now place this number in the heading
            head = &#39;FD {4}: {0} {1} {2}{3}&#39;.format(etyp, s, unit, d, prop)
            # Replace the heading if this was a static calculation
            if s == &#39;0&#39;:
                head = &#39;Static {0}&#39;.format(prop)
            print(head)

            # Pretty-print the tensor
            if self.calctype == &#39;FD&#39;:
                label = &#39;{0:&gt;35}{1:35}{2:&gt;22}&#39;
                head = &#39;{0:&gt;17}{1:&gt;16}{2:&gt;16}{3:6}{0:&gt;17}{1:&gt;16}{2:&gt;16}&#39;
                fr = &#39;{0:&gt;4}{1[0]:16.3f}{1[1]:16.3f}{1[2]:16.3f}  &#39;
                fi = &#39;{0:&gt;4}{1[0]:16.3f}{1[1]:16.3f}{1[2]:16.3f}&#39;
                print(label.format(&#39;Real&#39;, &#39;&#39;, &#39;Imaginary&#39;))
                print(head.format(&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;&#39;))
                print(fr.format(&#39;X&#39;, r[0, :]), fi.format(&#39;X&#39;, i[0, :]))
                print(fr.format(&#39;Y&#39;, r[1, :]), fi.format(&#39;Y&#39;, i[1, :]))
                print(fr.format(&#39;Z&#39;, r[2, :]), fi.format(&#39;Z&#39;, i[2, :]))
            else:
                head = &#39;{0:&gt;17}{1:&gt;16}{2:&gt;16}&#39;
                f = &#39;{0:&gt;4}{1[0]:16.3f}{1[1]:16.3f}{1[2]:16.3f}&#39;
                print(head.format(&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;))
                print(f.format(&#39;X&#39;, r[0, :]))
                print(f.format(&#39;Y&#39;, r[1, :]))
                print(f.format(&#39;Z&#39;, r[2, :]))

            # Add the invariants at the end if requested
            if iso or ani:
                print()
            if iso:
                print(&#39;ISOTROPIC PART    = &#39;, end=&#39;&#39;)
                iso = self.isotropic[n]
                if &#39;FD&#39; in self.calctype:
                    print(&#39;{0:12g} + {1:7g}j&#39;.format(iso.real, iso.imag))
                else:
                    print(&#39;{0:12g}&#39;.format(iso))
            if ani:
                ani = self.anisotropic2[n]
                print(&#39;ANISOTROPIC PART  = {0:12g}&#39;.format(sqrt(ani)))

            print()

    def printOptical(self, property=&#39;cross-section&#39;,
                     pathlength=None, concentration=None, unit=&#39;au&#39;,
                     absunit=&#39;angstroms&#39;):
        &#39;&#39;&#39;Prints a list of optical properties.

        Parameters
        ----------
        property : {&#39;absorption&#39;, &#39;absorptivitty&#39;, &#39;absorbance&#39;, &#39;transmittance&#39;}
            Specifies the optical property to print.
            The choices are:

                - cross-section-&gt; :meth:`cross_section`
                - absorptivitty -&gt; :meth:`molar_absorptivitty`
                - absorbance -&gt; :meth:`absorbance`
                - transmittance -&gt; :meth:`transmittance`

        pathlength : :obj:`float`
            If the `property` is &#39;absorbance&#39; or &#39;transmission&#39;,
            you will need to specify the pathlength for Beer&#39;s
            law in centimeters.
        concentration : :obj:`float`
            If the `property` is &#39;absorbance&#39; or &#39;transmission&#39;,
            you will need to specify the concentration for Beer&#39;s
            law in molarity.
        unit : {&#39;au&#39;, &#39;ev&#39;, &#39;nm&#39;}
            This is the unit to print the frequencies. The options are:

                - &#39;au&#39; -&gt; atomic units, Hartrees
                - &#39;ev&#39; -&gt; electron volts
                - &#39;nm&#39; -&gt; nanometers

        absunit : :obj:`str`
            This is the unit that that absorption cross section
            is calculated at.  See :meth:`cross_section`.

        Raises
        ------
        ValueError
            Invalid arguments given

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.printOptical(property=&#39;cross-section&#39;, unit=&#39;nm&#39;, absunit=&#39;cm&#39;)  # doctest: +NORMALIZE_WHITESPACE
            Wavelength (nm)   Absorption Cross-Section (cm^2/molecule)
                354.2395                       3.24138E-02
                335.0936                       1.06350E-02
            &gt;&gt;&gt; fd.printOptical(property=&#39;transmittance&#39;, pathlength=1.0, concentration=1e-6)  # doctest: +NORMALIZE_WHITESPACE
            Pathlength=1.00 cm, Concentration=1.000E-06 M
             Frequency (a.u.)            Transmittance (unitless)
               1.2862E-01                      8.22670E-01
               1.3597E-01                      9.37962E-01

        &#39;&#39;&#39;

        # Prep for printing
        if property == &#39;cross-section&#39;:
            values = self.cross_section(unit=absunit)
            label = &#39;Absorption Cross-Section&#39;
            if absunit == &#39;angstroms&#39;:
                u = unicode(u&#39;\u212B^2/molecule&#39;)
            elif absunit == &#39;bohr&#39;:
                u = &#39;bohr^2/molecule&#39;
            elif absunit == &#39;nm&#39;:
                u = &#39;nm^2/molecule&#39;
            elif absunit == &#39;cm&#39;:
                u = &#39;cm^2/molecule&#39;
            elif absunit == &#39;m&#39;:
                u = &#39;m^2/molecule&#39;
        elif property == &#39;absorptivitty&#39;:
            values = self.molar_absorptivitty()
            label, u = &#39;Molar Absorptivitty&#39;, &#39;L mol^{-1} cm^{-1}&#39;
        elif property == &#39;absorbance&#39;:
            values = self.absorbance(pathlength, concentration)
            label, u = &#39;Absorbance&#39;, &#39;unitless&#39;
        elif property == &#39;transmittance&#39;:
            values = self.transmittance(pathlength, concentration)
            label, u = &#39;Transmittance&#39;, &#39;unitless&#39;
        else:
            raise ValueError(&#39;printOptical(): &#39;
                             &#39;invalid property (&#39;+property+&#39;)&#39;)

        # Choose frequency unit
        if not re.match(r&#39;au|ev|nm&#39;, unit, re.I):
            raise ValueError(&#39;printTensor() : Invalid unit: &#39;+unit)
        unit = {&#39;au&#39;: &#39;a.u.&#39;, &#39;ev&#39;: &#39;eV&#39;, &#39;nm&#39;: &#39;nm&#39;}[unit.lower()]
        etyp = {&#39;a.u.&#39;: &#39;Frequency&#39;,
                &#39;eV&#39;: &#39;Energy&#39;,
                &#39;nm&#39;: &#39;Wavelength&#39;}[unit]
        frequencies = {&#39;a.u.&#39;: self.e_frequencies,
                       &#39;eV&#39;: HART2EV(self.e_frequencies),
                       &#39;nm&#39;: HART2NM(self.e_frequencies)}[unit]

        # Title
        if property in (&#39;absorbance&#39;, &#39;transmittance&#39;):
            string = &#39;Pathlength={0:.2f} cm, Concentration={1:.3E} M&#39;
            print(string.format(pathlength, concentration))
        string = unicode(u&#39;{0:&gt;10} {1:&lt;6} {2:&gt;24} {3:&lt;20}&#39;)
        print(string.format(etyp, &#39;(&#39;+unit+&#39;)&#39;, label, &#39;(&#39;+u+&#39;)&#39;))

        # A format string
        if unit == &#39;a.u.&#39;:
            fmt = &#39;{0:^17.4E} {1:^45.5E}&#39;
        else:
            fmt = &#39;{0:^17.4f} {1:^45.5E}&#39;

        # Print the properties
        for freq, val in zip(frequencies, values):
            print(fmt.format(freq, val))

    def cross_section(self, unit=&#39;angstroms&#39;):
        &#39;&#39;&#39;Returns the absorption cross-section of the system.

        Parameters
        ----------
        unit : {&#39;angstroms&#39;, &#39;nm&#39;, &#39;bohr&#39;, &#39;cm&#39;, &#39;m&#39;}
            The unit in which the cross section will be returned

                - &#39;angstroms&#39; -&gt; angstroms^2/molecule
                - &#39;nm&#39; -&gt; nm^2/molecule
                - &#39;bohr&#39; -&gt; bohr^2/molecule
                - &#39;cm&#39; -&gt; cm^2/molecule
                - &#39;m&#39; -&gt; m^2/molecule

        Returns
        -------
        cross_section : :obj:`numpy.ndarray` of length :attr:`~.npol`
            The absorption cross section for each frequency

        Raises
        ------
        ValueError
            Invalid arguments given
        DIMError
            Not an FD calculation

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.cross_section()
            array([ 3.24137681,  1.06350141])
            &gt;&gt;&gt; fd.cross_section(unit=&#39;nm&#39;)
            array([ 0.03241377,  0.01063501])
            &gt;&gt;&gt; fd.cross_section(unit=&#39;cm&#39;)
            array([  3.24137681e-16,   1.06350141e-16])

        &#39;&#39;&#39;

        # Assign the correct unit converter
        if unit.lower() == &#39;angstroms&#39;:
            conv = NOCONV
        elif unit.lower() == &#39;bohr&#39;:
            conv = ANGSTROM2BOHR
        elif unit.lower() == &#39;nm&#39;:
            conv = ANGSTROM2NM
        elif unit.lower() == &#39;cm&#39;:
            conv = ANGSTROM2CM
        elif unit.lower() == &#39;m&#39;:
            conv = ANGSTROM2M
        else:
            raise ValueError(&#39;cross_section(): Invalid unit (&#39;+unit.lower()+&#39;)&#39;)

        if self.calctype == &#39;FD&#39;:
            iso = self.isotropic.imag
            # Conversion is performed twice because the property is squared
            return conv(conv((4 * PI * self.e_frequencies / LIGHT_AU) * iso))
        else:
            raise DIMError(&#39;cross_section(): Not a FD calculation&#39;)

    def molar_absorptivitty(self):
        &#39;&#39;&#39;Calculates the molar absorptivitty of the system in units of
        L mol^{-1} cm^{-1} or M^{-1} cm^{-1} (these are equivalent).

        Returns
        -------
        molar_absorptivitty : :obj:`numpy.ndarray` of length :attr:`~.npol`
            The molar absorptivitty for each frequency in

        Raises
        ------
        ValueError
            Invalid arguments given
        DIMError
            Not an FD calculation

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.molar_absorptivitty()
            array([ 84774.41649881,  27814.63448711])

        &#39;&#39;&#39;
        from math import log as ln

        # Conversion factor to get from angstroms^2 to L/cm.
        # L == dm^3
        # dm^2 == 1E18 angstroms^2
        # dm^2 == 0.1 dm^3/cm
        # 0.1 dm^3/cm = 1E18 angstroms^2
        # 1E-19 = dm^3/(cm*angstroms^2)
        CONVFACTOR = 1E-19

        # Get the absorption cross-section in angstroms^2/molecule
        acs = self.cross_section()
        # Use this to calculate the molar absorptivity
        # LN(10) accounts for Beer&#39;s law
        return AVOGADRO * CONVFACTOR * acs / ln(10)

    def absorbance(self, pathlength, concentration):
        &#39;&#39;&#39;\
        Calculates the (unitless) absorbance of the system using
        Beer&#39;s law.

        Parameters
        ----------
        pathlength : :obj:`float`
            The pathlength in centimeters of the light
        concentration : :obj:`float`
            The solution concentration in molarity

        Returns
        -------
        absorbance : :obj:`numpy.ndarray` of length :attr:`~.npol`
            The unitless absorbance for each frequency

        Raises
        ------
        ValueError
            Invalid arguments given
        DIMError
            Not an FD calculation

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.absorbance(1.5, 1.5e-6)
            array([ 0.19074244,  0.06258293])

        &#39;&#39;&#39;
        eps = self.molar_absorptivitty()
        return eps * pathlength * concentration

    def transmittance(self, pathlength, concentration):
        &#39;&#39;&#39;\
        Calculates the transmittance from the absorbance on a scale
        from 0 to 1.  The user must convert to percent if she so desires.

        Parameters
        ----------
        pathlength : :obj:`float`
            The pathlength in centimeters of the light
        concentration : :obj:`float`
            The solution concentration in molarity

        Returns
        -------
        transmittance : :obj:`numpy.ndarray` of length :attr:`~.npol`
            The normalized transmittance for each frequency in

        Raises
        ------
        ValueError
            Invalid arguments given
        DIMError
            Not an FD calculation

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.transmittance(1.5, 1.5e-6)
            array([ 0.64455141,  0.86579899])

        &#39;&#39;&#39;
        absorb = self.absorbance(pathlength, concentration)
        return power(10, -absorb)

    def pol_minmax(self):
        &#39;&#39;&#39;\
        Finds the minimum and maximum isotropic polarizabilities

        Returns
        -------
        pol_min : :obj:`float`
            Minimum isotropic polarizability
        pol_max : :obj:`float`
            Maximum isotropic polarizability

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; minmax = fd.pol_minmax()
            &gt;&gt;&gt; fd.isotropic
            array([ 70.89400000+274.812j, -80.48033333 +85.293j])
            &gt;&gt;&gt; round(minmax[0].real, 4)
            -80.4803
            &gt;&gt;&gt; round(minmax[0].imag, 4)
            85.293
            &gt;&gt;&gt; round(minmax[1].real, 4)
            70.894
            &gt;&gt;&gt; round(minmax[1].imag, 4)
            274.812

        &#39;&#39;&#39;
        return (self.isotropic.min(),
                self.isotropic.max())

    def pol_diagonalize(self):
        &#39;&#39;&#39;Diagonalizes the polarizability tensors in place.

        Returns
        -------
        rotmat : :obj:`numpy.ndarray` of shape :attr:`~.npol` x 3 x 3
            Rotation matrix after diagonalization

        Raises
        ------
        DIMError
            Diagonalization does not converge

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.polarizability
            array([[[ 71.324,   0.   ,   0.   ],
                    [  0.   ,  71.324,   0.   ],
                    [  0.   ,   0.   ,  93.755]]])
            &gt;&gt;&gt; static.pol_diagonalize()
            array([[[ 1.,  0.,  0.],
                    [ 0.,  1.,  0.],
                    [ 0.,  0.,  1.]]])
            &gt;&gt;&gt; static.polarizability
            array([[[ 71.324,   0.   ,   0.   ],
                    [  0.   ,  71.324,   0.   ],
                    [  0.   ,   0.   ,  93.755]]])
            &gt;&gt;&gt; # Note: This example shows no difference  before and
            &gt;&gt;&gt; # after diagonalization because the tensor was already
            &gt;&gt;&gt; # diagonalized because the nanoparticle is linear on the
            &gt;&gt;&gt; # z-axis.

        &#39;&#39;&#39;

        # Find the eigenvector and eigenvalues of the tensor
        # The eigenvector is the diagonal of the tensor, and the
        # eigenvalues are the rotation matrix.
        rotation = zeros_like(self.polarizability)

        for n in range(self.npol):
            try:
                eigenvec, eigenval = eig(self.polarizability[n])
            except LinAlgError:
                raise DIMError(&#39;Diagonalization of polarizability &#39;
                               &#39;tensor does not converge&#39;)
            else:
                self.polarizability[n] = diagflat(eigenvec)
                rotation[n] = eigenval

        # Remember the state
        self._diagonalized = True

        return rotation

    def absorb(self, other, ignore=set()):
        &#39;&#39;&#39;\
        Method to &#34;absorb&#34; all of the data from another
        :py:class:`DIM` instance to the current DIM instance.

        Data in `other` overwrite data in `self`.
        Empty parameters in `other` will be ignored.

        Parameters
        ----------
        other : :class:`DIM`
            The :class:`DIM` object to be absorbed.
        ignore : :obj:`set`
            Attributes that will **NOT** be absorbed.

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)

        &#39;&#39;&#39;
        # Not DIM instance
        if not isinstance(other, DIM):
            raise DIMError(&#39;absorb(): other != DIM()&#39;)
        # Make sure ignore is a set
        ignore = set(ignore)

        # Set of attributes to absorb
        attr = set([&#39;calctype&#39;, &#39;subkey&#39;, &#39;key&#39;, &#39;natoms&#39;, &#39;coordinates&#39;,
                    &#39;atoms&#39;, &#39;elements&#39;, &#39;npol&#39;, &#39;e_frequencies&#39;,
                    &#39;polarizability&#39;, &#39;efficiencies&#39;, &#39;cross_section&#39;,
                    &#39;dipoles&#39;, &#39;charges&#39;, &#39;start&#39;, &#39;real_time&#39;, &#39;cpu_time&#39;,
                    &#39;routine_time&#39;, &#39;termination&#39;, &#39;host&#39;, &#39;nprocs&#39;])

        # Run over all attributes on the attribute list (minus the ones
        # in ignore) and copy into this instance.
        # Don&#39;t copy things that are None.
        for k in attr.difference(ignore):
            if k not in other:
                continue
            setattr(self, k, deepcopy(getattr(other, k)))
        if &#39;coordinates&#39; not in ignore:
            self._minmax = None
            self._bonds = None

    def empty(self, ignore=set()):
        &#39;&#39;&#39;\
        Empties all attributes in the current :class:`DIM` instance
        except those on the ignore list.

        Parameters
        ----------
        ignore : :obj:`set`
            A set of attributes to **NOT** empty

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)

        &#39;&#39;&#39;
        # Make sure ignore is a set
        ignore = set(ignore)

        # Set of attributes to empty
        attr = set([&#39;calctype&#39;, &#39;subkey&#39;, &#39;key&#39;, &#39;natoms&#39;, &#39;coordinates&#39;,
                    &#39;atoms&#39;, &#39;elements&#39;, &#39;npol&#39;, &#39;e_frequencies&#39;,
                    &#39;polarizability&#39;, &#39;efficiencies&#39;, &#39;cross_section&#39;,
                    &#39;dipoles&#39;, &#39;charges&#39;, &#39;start&#39;, &#39;real_time&#39;, &#39;cpu_time&#39;,
                    &#39;routine_time&#39;, &#39;termination&#39;, &#39;host&#39;, &#39;nprocs&#39;])

        # Run over all attributes and empty them, except for the ones
        # in ignore.
        for k in attr.difference(ignore):
            if k in (&#39;calctype&#39;, &#39;subkey&#39;):
                setattr(self, k, set())
            elif k == &#39;key&#39;:
                setattr(self, k, {})
            else:
                setattr(self, k, None)
        if &#39;coordinates&#39; not in ignore:
            self._minmax = None
            self._bonds = None


    #################
    # MANAGED METHODS
    #################

    @property
    def masses(self):
        &#34;&#34;&#34;The atomic mass of each atom in the nanoparticle

        .. note:: This is a property method, meaning that this is called
                  as though it were an attribute of :class:`DIM`, so
                  no parentheses are used.

        Returns
        -------
        masses : :obj:`numpy.ndarray` of length ``natoms``
            The atomic masses in the system

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.masses
            array([ 106.905093,  106.905093])

        &#34;&#34;&#34;
        # Make the atomic mass function broadcastable on a numpy array
        atm_mass = vectorize(atomic_mass)
        # Return the mass for each atom
        return atm_mass(self.atoms)

    @property
    def molecular_mass(self):
        &#34;&#34;&#34;The total mass of the nanoparticle

        .. note:: This is a property method, meaning that this is called
                  as though it were an attribute of :class:`DIM`, so
                  no parentheses are used.

        Returns
        -------
        molecular_mass : :obj:`float`
            The molecular mass of the nanoparticle

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; round(static.molecular_mass, 6)
            213.810186

        &#34;&#34;&#34;
        # Sum masses and return the total molecular mass
        return self.masses.sum()

    @property
    def bonds(self):
        &#34;&#34;&#34;Returns a list of the bonds in the system

        Given that ``N`` is the number of bonds, this is an ``N`` x 2 numpy
        array containing the index of atom 1 and atom 2 of each bond.
        Therefore, bond ``i`` goes from ``self.coordinates[self.bonds[i,0]]``
        to ``self.coordinates[self.bonds[i,1]]``

         .. note:: This is a property method, meaning that this is called
                  as though it were an attribute of :class:`DIM`, so
                  no parentheses are used.

        Returns
        -------
        bonds :  :obj:`numpy.ndarray` of shape ``N`` x 2
            The array of bonds

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.bonds
            array([], shape=(0, 2), dtype=int64)
            &gt;&gt;&gt; # This is empty because the atoms in this
            &gt;&gt;&gt; # example are too far apart to be considered bonding

        &#34;&#34;&#34;
        # Use a C subroutine to find bonds.
        if self._bonds is None:
            try:
                self._bonds = asarray(calc_bonds(self.coordinates,
                                                 self.radii(&#39;vis&#39;), 1.1).T, dtype=int)
            except AttributeError:
                return None
        return self._bonds

    @property
    def maxdist(self):
        &#34;&#34;&#34;The maximum distance between two atoms in the nanoparticle

        .. note:: This is a property method, meaning that this is called
                  as though it were an attribute of :class:`DIM`, so
                  no parentheses are used.

        Returns
        -------
        maxdist : :obj:`float`
            The distance

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.natoms
            2
            &gt;&gt;&gt; # Only 2 atoms, so maxdist is the distance between those two
            &gt;&gt;&gt; static.maxdist
            4.0

        &#34;&#34;&#34;
        # Return the maximum distance between atoms in the system.
        if self._minmax is None:
            self._minmax = minmax_pdist(self.coordinates)
        return self._minmax[1]

    @property
    def mindist(self):
        &#34;&#34;&#34;The minimum distance between two atoms in the nanoparticle

        .. note:: This is a property method, meaning that this is called
                  as though it were an attribute of :class:`DIM`, so
                  no parentheses are used.

        Returns
        -------
        mindist : :obj:`float`
            The distance

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.natoms
            2
            &gt;&gt;&gt; # Only 2 atoms, so mindist is the distance between those two
            &gt;&gt;&gt; static.mindist
            4.0

        &#34;&#34;&#34;
        # Return the mimimum distance between atoms in the system.
        if self._minmax is None:
            self._minmax = minmax_pdist(self.coordinates)
        return self._minmax[0]

    @property
    def isotropic(self):
        &#34;&#34;&#34;The isotropic polarizability for each polarizability tensor.

        .. note:: This is a property method, meaning that this is called
                  as though it were an attribute of :class:`DIM`, so
                  no parentheses are used.

        Returns
        -------
        iso : :obj:`numpy.ndarray` of length :attr:`~.npol`
            Isotropic polarizabilities

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.npol
            1
            &gt;&gt;&gt; static.isotropic
            array([ 78.801])
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.npol
            2
            &gt;&gt;&gt; fd.isotropic
            array([ 70.89400000+274.812j, -80.48033333 +85.293j])

        &#34;&#34;&#34;
        return self.tensor_isotropic(self.polarizability)

    @property
    def anisotropic2(self):
        &#34;&#34;&#34;The anisotropic polarizability squared for each
        polarizability tensor.

        .. note:: This is a property method, meaning that this is called
                  as though it were an attribute of :class:`DIM`, so
                  no parentheses are used.

        Returns
        -------
        ani : :obj:`numpy.ndarray` of length :attr:`~.npol`
            Anisotropic polarizabilities squared

        Examples
        --------

            import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.npol
            1
            &gt;&gt;&gt; static.anisotropic2
            array([ 503.149761])
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.npol
            2
            &gt;&gt;&gt; fd.anisotropic2
            array([ 152906.539536,    1761.492265])

        &#34;&#34;&#34;

        # Calculates the anisotropic polarizability squared
        return self.tensor_anisotropic2(self.polarizability)

    ####################
    # OPERATOR OVERRIDES
    ####################

    def __str__(self):
        &#39;&#39;&#39;Defines what is printed when the class is printed.&#39;&#39;&#39;
        return &#39;DIM object for file {0}&#39;.format(self.filename)

    def __contains__(self, key):
        &#39;&#39;&#39;\
        Boolean for if a field is filled or not.

        Parameters
        ----------
        key : :obj:`str`
            The :class:`DIM` attribute to check

        Returns
        -------
        contains : :obj:`bool`
            :obj:`True` if the field is not empty, :obj:`False` otherwise

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; &#39;efficiencies&#39; in static
            False
            &gt;&gt;&gt; &#39;coordinates&#39; in static
            True

        &#39;&#39;&#39;
        if getattr(self, key, None) is not None:
            try:
                return bool(getattr(self, key, None))
            except ValueError:
                return True
        else:
            return False

    def __add__(self, other):
        &#39;&#39;&#39;\
        Concatenates two nanoparticles together and returns the new molecule.

        The attributes that are concatenated are:

          - :attr:`coordinates`
          - :attr:`atoms`
          - :attr:`natoms`
          - :attr:`elements`
          - :attr:`nelements`

        All other properties would be unphysical to concatenate
        and are emptied.

        Parameters
        ----------
        other : :class:`DIM`
            The other nanoparticle

        Returns
        -------
        new : :class:`DIM`
            The new :class:`DIM` instance with the data
            concatenated together

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; np1 = dim.quick_test()
            &gt;&gt;&gt; np1.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; np2 = dim.quick_test()
            &gt;&gt;&gt; np2.translate_coordinates([3.0, 0.0, 0.0])
            &gt;&gt;&gt; np2.coordinates
            array([[ 3.,  0.,  0.],
                   [ 3.,  0.,  4.]])
            &gt;&gt;&gt; np3 = np1 + np2
            &gt;&gt;&gt; np3.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.],
                   [ 3.,  0.,  0.],
                   [ 3.,  0.,  4.]])
            &gt;&gt;&gt; np3.atoms
            array([&#39;Ag&#39;, &#39;Ag&#39;, &#39;Ag&#39;, &#39;Ag&#39;], 
                  dtype=&#39;|S2&#39;)

        &#39;&#39;&#39;
        from numpy import concatenate
        from dimpy import DIM
        new = DIM(self.filename)
        new.coordinates = concatenate((self.coordinates, other.coordinates))
        new.atoms = concatenate((self.atoms, other.atoms))
        new.elements = self.elements.union(other.elements)
        new.natoms = len(new.atoms)
        new.nelements = len(new.elements)

        return new

    def __iadd__(self, other):
        &#39;&#39;&#39;\
        Alternative syntax to :meth:`~.join`

        Parameters
        ----------
        other : :class:`DIM`
            The other nanoparticle

        Returns
        -------
        new : :class:`DIM`
            The new :class:`DIM` instance with the data
            concatenated together

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; np1 = dim.quick_test()
            &gt;&gt;&gt; np1.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; np2 = dim.quick_test()
            &gt;&gt;&gt; np2.translate_coordinates([3.0, 0.0, 0.0])
            &gt;&gt;&gt; np2.coordinates
            array([[ 3.,  0.,  0.],
                   [ 3.,  0.,  4.]])
            &gt;&gt;&gt; np1 += np2
            &gt;&gt;&gt; np1.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.],
                   [ 3.,  0.,  0.],
                   [ 3.,  0.,  4.]])
            &gt;&gt;&gt; np1.atoms
            array([&#39;Ag&#39;, &#39;Ag&#39;, &#39;Ag&#39;, &#39;Ag&#39;], 
                  dtype=&#39;|S2&#39;)
        &#39;&#39;&#39;
        self.join(other)

    #################
    # PRIVATE METHODS
    #################

    def __det_calc_type(self):
        &#39;&#39;&#39;Determine the calculation type based on what is found in the keys&#39;&#39;&#39;
        if &#39;PRINT&#39; in self.key:
            if &#39;ATMDIP&#39; in self.key[&#39;PRINT&#39;]:
                self.subkey.add(&#39;ATMDIP&#39;)
            if &#39;ENERGY&#39; in self.key[&#39;PRINT&#39;]:
                self.subkey.add(&#39;ENERGY&#39;)
        if &#39;NOPRINT&#39; in self.key:
            if &#39;ATMDIP&#39; in self.key[&#39;NOPRINT&#39;]:
                self.subkey.discard(&#39;ATMDIP&#39;)
            if &#39;ENERGY&#39; in self.key[&#39;NOPRINT&#39;]:
                self.subkey.discard(&#39;ENERGY&#39;)
        if &#39;CPIM&#39; in self.key:
            self.subkey.add(&#39;CPIM&#39;)
        elif &#39;PIM&#39; in self.key:
            self.subkey.add(&#39;PIM&#39;)
        if &#39;FREQRANGE&#39; in self.key or &#39;FREQUENCY&#39; in self.key:
            self.calctype = &#39;FD&#39;
        else:
            self.calctype = &#39;STATIC&#39;

    def _raise_or_pass(self, msg):
        &#39;&#39;&#39;Subroutine to pass or raise on collection error.
        Makes termination more specific by adding error message.

        &#39;&#39;&#39;
        if self.termination is None or &#39;ERROR:&#39; not in self.termination:
            self.termination = msg
        if self._abort:
            raise DIMError(msg)
        else:
            pass

    @staticmethod
    def tensor_isotropic(tn):
        return trace(tn, axis1=1, axis2=2) / 3

    @staticmethod
    def tensor_anisotropic2(tn):
        # Calculate anisotripoc polarizability squared using eq.14 from
        # J. Chem. Phys, 75, 5615:
        # \frac{3}{4}\left[\sum_{ij}\alpha_{ij}\alpha_{ij)^\ast
        #                + \sum_{ij}\alpha_{ij}\alpha_{ji)^\ast\right]
        # - \frac{1}{2}\sum_{ij}\alpha_{ii}\alpha_{jj}^\ast

        # It should be noted that there is no complex anisotropic
        # polarizability like there is isotropic polarizability.  This is due
        # to the fact that the anisotropic polarizaibiltiy is instrinsically
        # a magnatude due to the squared factor, and as such must be real.
        cj = tn.conjugate()
        r = range(3)
        t = empty(len(tn), dtype=float)
        for n in xrange(len(tn)):
            cross1 = sum([tn[n, i, j] * cj[n, i, j] for i in r for j in r])
            cross2 = sum([tn[n, i, j] * cj[n, j, i] for i in r for j in r])
            diag = sum([tn[n, i, i] * cj[n, j, j] for i in r for j in r])
            t[n] = absolute((3 / 4) * (cross1 + cross2) - (1 / 2) * diag)
        return t</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dimpy.dimclass.DIM"><code class="flex name class">
<span>class <span class="ident">DIM</span></span>
<span>(</span><span>name)</span>
</code></dt>
<dd>
<div class="desc"><p>Stores the DIM output data.</p>
<p>The :class:<code><a title="dimpy.dimclass.DIM" href="#dimpy.dimclass.DIM">DIM</a></code> class reads in the data of a DIM output file and
provides a high-level interface to help with data manipulation
and displaying the data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>:obj:</code>str``</dt>
<dd>The name of the DIM output file to associate with this class.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>filename</code></strong> :&ensp;<code>:obj:</code>str``</dt>
<dd>The name if the DIM output file associated with this class.</dd>
<dt><strong><code>filetype</code></strong> :&ensp;<code>:obj:</code>str``</dt>
<dd>The file type, { 'input', 'output' }</dd>
<dt><strong><code>key</code></strong> :&ensp;<code>:obj:</code>dict``</dt>
<dd>A dictionary containing the input keys from the input block</dd>
<dt><strong><code>calctype</code></strong> :&ensp;<code>:obj:</code>str``</dt>
<dd>The type of calculation that was run { 'STATIC', 'FD' }</dd>
<dt><strong><code>natoms</code></strong> :&ensp;<code>:obj:</code>int``</dt>
<dd>The number of atoms in the nanoparticle.</dd>
<dt><strong><code>coordinates</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code> of <code>shape &lt;/code&gt;natoms&lt;code&gt;</code> x 3</code></dt>
<dd>The cartesian coordinates of the atoms in the nanoparticle</dd>
<dt><strong><code>atoms</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code> of `length </code>natoms```</dt>
<dd>The name of each atom in the nanoparticle</dd>
<dt><strong><code>elements</code></strong> :&ensp;<code>:obj:</code>set``</dt>
<dd>The elements in the nanoparticle</dd>
<dt><strong><code>npol</code></strong> :&ensp;<code>:obj:</code>int``</dt>
<dd>The number of frequency-dependent (FD) polarizabilities calculated.</dd>
<dt><strong><code>e_frequencies</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code> of `length </code>npol```</dt>
<dd>The electric frequencies the polarizabilities were calculated at</dd>
<dt><strong><code>polarizability</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code> of <code>shape &lt;/code&gt;npol&lt;code&gt;</code> x 3 x 3</code></dt>
<dd>The polarizability tensor for each frequency.</dd>
<dt><strong><code>efficiencies</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code> of <code>shape &lt;/code&gt;npol&lt;code&gt;</code> x 3</code></dt>
<dd>The spectral efficiencies.
For each frequency, the first
element is the scattering, the second is the absorbance, and
the third is the exctinction. This is only valid for FD
calculations.</dd>
<dt><strong><code>cross_sections</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code> of <code>shape &lt;/code&gt;npol&lt;code&gt;</code> x 3</code></dt>
<dd>The spectral cross sections.
For each frequency, the first
element is the scattering, the second is the absorbance, and the
third is the exctinction. This is only valid for FD calculations.</dd>
<dt><strong><code>dipoles</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code> of <code>shape &lt;/code&gt;npol&lt;code&gt; x &lt;/code&gt;natoms&lt;code&gt;</code> x 3</code></dt>
<dd>The dipole on each atom of the nanoparticle.
Only available if these were printed in the output file</dd>
<dt><strong><code>charges</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code> of `shape </code>npol<code> x </code>natoms```</dt>
<dd>The charge on each atom of the nanoparticle.
Only available if these were printed in the output file
and the calculation was CPIM</dd>
<dt><strong><code>start</code></strong> :&ensp;<code>:obj:</code>datetime.datetime``</dt>
<dd>The starting time of the calculation</dd>
<dt><strong><code>real_time</code></strong> :&ensp;<code>:obj:</code>datetime.timedelta``</dt>
<dd>The wall time of the calculation</dd>
<dt><strong><code>cpu_time</code></strong> :&ensp;<code>:obj:</code>datetime.timedelta``</dt>
<dd>The cpu time of the calculation</dd>
<dt><strong><code>routine_time</code></strong> :&ensp;<code>:obj:</code>dict``</dt>
<dd>The time it took to perform each routine in the DIM calculation.</dd>
<dt><strong><code>termination</code></strong> :&ensp;<code>:obj:</code>str``</dt>
<dd>A message that indicates how the DIM calculation ended</dd>
<dt><strong><code>host</code></strong> :&ensp;<code>:obj:</code>str``</dt>
<dd>The host the calculation was run on</dd>
<dt><strong><code>nprocs</code></strong> :&ensp;<code>:obj:</code>int``</dt>
<dd>The number of processors used to perform the calculation</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>tensor_isotropic(tensors)
Return the isotropic polarizability for each given polarizability
tensor
tensor_anisotropic2(tensors)
Return the anisotropic polarizability squared for each given
polarizability tensor</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;The above two methods are static methods of the DIM class.</p>
</div>
<h2 id="examples">Examples</h2>
<p>When you instantiate a new DIM class, every field is empty except
for the filename and filetype attributes</p>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; static.filename
'...out'
&gt;&gt;&gt; static.filetype
'output'
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;All :class:<code><a title="dimpy.dimclass.DIM" href="#dimpy.dimclass.DIM">DIM</a></code> examples use the :func:<code>quick_test</code> function</p>
<p>to generate the test cases.</p>
</div>
<p>Initiallize the DIM class.</p>
<p>:param name: The name of the DIM output file to associate with this class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DIM(object):
    &#39;&#39;&#39;\
    Stores the DIM output data.

    The :class:`DIM` class reads in the data of a DIM output file and
    provides a high-level interface to help with data manipulation
    and displaying the data.

    Parameters
    ----------
    name : :obj:`str`
        The name of the DIM output file to associate with this class.

    Attributes
    ----------
    filename : :obj:`str`
        The name if the DIM output file associated with this class.
    filetype : :obj:`str`
        The file type, { &#39;input&#39;, &#39;output&#39; }
    key : :obj:`dict`
        A dictionary containing the input keys from the input block
    calctype : :obj:`str`
        The type of calculation that was run { &#39;STATIC&#39;, &#39;FD&#39; }
    natoms : :obj:`int`
        The number of atoms in the nanoparticle.
    coordinates : :obj:`numpy.ndarray` of shape ``natoms`` x 3
        The cartesian coordinates of the atoms in the nanoparticle
    atoms : :obj:`numpy.ndarray` of length ``natoms``
        The name of each atom in the nanoparticle
    elements : :obj:`set`
        The elements in the nanoparticle
    npol : :obj:`int`
        The number of frequency-dependent (FD) polarizabilities calculated.
    e_frequencies : :obj:`numpy.ndarray` of length ``npol``
        The electric frequencies the polarizabilities were calculated at
    polarizability : :obj:`numpy.ndarray` of shape ``npol`` x 3 x 3
        The polarizability tensor for each frequency.
    efficiencies : :obj:`numpy.ndarray` of shape ``npol`` x 3
        The spectral efficiencies.  For each frequency, the first
        element is the scattering, the second is the absorbance, and
        the third is the exctinction. This is only valid for FD
        calculations.
    cross_sections : :obj:`numpy.ndarray` of shape ``npol`` x 3
        The spectral cross sections.  For each frequency, the first
        element is the scattering, the second is the absorbance, and the
        third is the exctinction. This is only valid for FD calculations.
    dipoles : :obj:`numpy.ndarray` of shape ``npol`` x ``natoms`` x 3
        The dipole on each atom of the nanoparticle.
        Only available if these were printed in the output file
    charges : :obj:`numpy.ndarray` of shape ``npol`` x ``natoms``
        The charge on each atom of the nanoparticle.
        Only available if these were printed in the output file
        and the calculation was CPIM
    start : :obj:`datetime.datetime`
        The starting time of the calculation
    real_time : :obj:`datetime.timedelta`
        The wall time of the calculation
    cpu_time : :obj:`datetime.timedelta`
        The cpu time of the calculation
    routine_time : :obj:`dict`
        The time it took to perform each routine in the DIM calculation.
    termination : :obj:`str`
        A message that indicates how the DIM calculation ended
    host : :obj:`str`
        The host the calculation was run on
    nprocs : :obj:`int`
        The number of processors used to perform the calculation

    Methods
    -------
    tensor_isotropic(tensors)
        Return the isotropic polarizability for each given polarizability
        tensor
    tensor_anisotropic2(tensors)
        Return the anisotropic polarizability squared for each given
        polarizability tensor

    .. note:: The above two methods are static methods of the DIM class.

    Examples
    --------
    When you instantiate a new DIM class, every field is empty except
    for the filename and filetype attributes

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; static.filename
        &#39;...out&#39;
        &gt;&gt;&gt; static.filetype
        &#39;output&#39;

    .. note:: All :class:`DIM` examples use the :func:`quick_test` function
              to generate the test cases.

    &#39;&#39;&#39;

    def __init__(self, name):
        &#39;&#39;&#39;\
        Initiallize the DIM class.

        :param name: The name of the DIM output file to associate with this class.
        &#39;&#39;&#39;
        # Find extention
        ftype = splitext(name)[1]
        if ftype not in (&#39;.out&#39;, &#39;.inp&#39;, &#39;.dim&#39;):
            raise ValueError(ftype+&#39; not a recognized extention&#39;)
        self.filetype = &#39;output&#39; if ftype == &#39;.out&#39; else &#39;input&#39;
        self.filename = name

        # List of input keys.
        self.blockkeys = (&#39;XYZ&#39;,)
        # Each element is a possible key
        for e in elem[1:]:
            self.blockkeys += (e.upper(),)
        self.linekeys = (&#39;TOLERANCE&#39;, &#39;TOTALCHARGE&#39;, &#39;DAMPING&#39;, &#39;PRINTLEVEL&#39;,
                         &#39;ALGORITHM&#39;, &#39;NOPRINT&#39;, &#39;PRINT&#39;, &#39;FREQRANGE&#39;,
                         &#39;FREQUENCY&#39;, &#39;OUTPUT&#39;,)
        self.singlekeys = (&#39;CPIM&#39;, &#39;PIM&#39;, &#39;NOPOL&#39;, &#39;NOCHAR&#39;, &#39;NONINTERACTING&#39;,
                           &#39;DEBUG&#39;, &#39;BOHR&#39;,)

        self.calctype = set()
        self.subkey = set()
        self.key = {}
        self.natoms = None
        self.coordinates = None
        self.atoms = None
        self.elements = None
        self.npol = None
        self.e_frequencies = None
        self.polarizability = None
        self.efficiencies = None
        self.cross_sections = None
        self.dipoles = None
        self.charges = None
        self.start = None
        self.real_time = None
        self.cpu_time = None
        self.routine_time = None
        self.termination = None
        self.host = None
        self.nprocs = None
        self._diagonalized = False
        self._minmax = None
        self._bonds = None

    def collect(self, abort=False):
        &#39;&#39;&#39;\
        Read the data from a :class:`DIM` input or output file

        Parameters
        ----------
        abort : :obj:`bool`
            If :obj:`True`, the collector will raise an error when an collection
            error is encountered.  If :obj:`False`, the error will be
            ignored and it will continue collection the remainder of the file.

        Raises
        ------
        DIMError
            An expected section of the output was missing.
            (Other exceptions may also be raised, but are difficult to predict
            because of the nature of parsing an open-ended text file.)

        Examples
        --------
        The :meth:`collect()` method can collect output files:

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; # .collect() is called as the last step of quick_test()
            &gt;&gt;&gt; # Example
            &gt;&gt;&gt; # run(inputfile, outputfile)
            &gt;&gt;&gt; # data = DIM(outputfile)
            &gt;&gt;&gt; # data.collect()
            &gt;&gt;&gt;
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; static.atoms # doctest: +NORMALIZE_WHITESPACE
            array([&#39;Ag&#39;, &#39;Ag&#39;], dtype=&#39;|S2&#39;)
            &gt;&gt;&gt; static.natoms
            2
            &gt;&gt;&gt; static.elements
            set([&#39;Ag&#39;])
            &gt;&gt;&gt; static.nelements
            1
            &gt;&gt;&gt; static.key[&#39;XYZ&#39;]
            (&#39;Ag 0.0 0.0 0.0&#39;, &#39;Ag 0.0 0.0 4.0&#39;)

        Note that the results of a static and frequency-dependent calculation will be
        in a slightly different format.

            &gt;&gt;&gt; static.npol
            1
            &gt;&gt;&gt; static.e_frequencies
            array([ 0.])
            &gt;&gt;&gt; static.polarizability
            array([[[ 71.324,   0.   ,   0.   ],
                    [  0.   ,  71.324,   0.   ],
                    [  0.   ,   0.   ,  93.755]]])
            &gt;&gt;&gt; static.efficiencies
            &gt;&gt;&gt; static.cross_sections
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.npol
            2
            &gt;&gt;&gt; fd.e_frequencies
            array([ 0.128623,  0.135972])
            &gt;&gt;&gt; fd.polarizability
            array([[[ 200.794+264.06j ,    0.000  +0.j   ,    0.000  +0.j   ],
                    [   0.000  +0.j   ,  200.794+264.06j ,    0.000  +0.j   ],
                    [   0.000  +0.j   ,    0.000  +0.j   , -188.906+296.316j]],
            &lt;BLANKLINE&gt;
                   [[ -81.283 +99.26j ,    0.000  +0.j   ,    0.000  +0.j   ],
                    [   0.000  +0.j   ,  -81.283 +99.26j ,    0.000  +0.j   ],
                    [   0.000  +0.j   ,    0.000  +0.j   ,  -78.875 +57.359j]]])
            &gt;&gt;&gt; # The following are only collected for FD
            &gt;&gt;&gt; # and if &#39;PRINT EFF&#39; was included in input file
            &gt;&gt;&gt; fd.efficiencies
            array([  8.09150000e-02,   1.84020000e-12])
            &gt;&gt;&gt; fd.cross_sections
            array([  7.22310000e-04,   1.64260000e-14])

        &#39;&#39;&#39;

        # Collect from file
        try:
            # Set the abort flag
            self._abort = abort
            # Read in file
            from .read_file import read_file
            f, indices = read_file(self)
            # Read input block
            from .input_block import collect_input
            collect_input(self, f, indices)
            # Determine calculation type
            self.__det_calc_type()
            # Techical properties
            from .dimproperties import collect_technical
            collect_technical(self, f, indices)
            # Collect all exciting information
            from .dimproperties import collect_dim
            collect_dim(self, f, indices)
            # Collect timing
            from .dimproperties import collect_timing
            collect_timing(self, f, indices)
        # If a known error occured
        except DIMError as d:
            if abort:
                raise DIMError(str(d) + &#39;: &#39; + self.filename)
        # If a known unknown error occured.
        except (IndexError, StopIteration, KeyError):
            msg = &#39;Did the calculation end prematurely?&#39;
            if abort:
                print(&#39;/\\&#39;*int(len(msg)/2), file=sys.stderr)
                print(msg, file=sys.stderr)
                print(&#39;/\\&#39;*int(len(msg)/2), file=sys.stderr)
                print(file=sys.stderr)
                raise
        except ValueError:
            msg = &#39;Possibly a number too large for the format (********)\n&#39;
            msg += &#39;or a string and number running together (WORD1.785)&#39;
            if abort:
                print(&#39;/\\&#39;*27, file=sys.stderr)
                print(msg, file=sys.stderr)
                print(&#39;/\\&#39;*27, file=sys.stderr)
                print(file=sys.stderr)
                raise

    def copy(self):
        &#39;&#39;&#39;\
        Returns a copy of the current instance.
        Equivalent to :obj:`copy.deepcopy` (self).

        Returns
        -------
        copy : :class:`DIM`
            A copy of the current :class:`DIM` instance.

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; example1 = static
            &gt;&gt;&gt; example1 is static
            True
            &gt;&gt;&gt; example2 = static.copy()
            &gt;&gt;&gt; example2 is static
            False

        &#39;&#39;&#39;
        return deepcopy(self)

    def printCoords(self, mode=None, a1=1, a2=None, file=None, latex=False):
        &#39;&#39;&#39;Prints the geometry coordinates to screen.

        Parameters
        ----------
        mode : {&#39;xyz&#39;, &#39;xyz_title&#39;, &#39;num&#39;, &#39;dimblock&#39;}
            Determines how the coordinates will be printed.  If
            omitted, the coordinates will be printed without numbers.

            Valid options are:

                - &#39;num&#39;:       Prints the number of each atom with the element.
                - &#39;xyz&#39;:       Prints the total number of atoms, then a space, then the coordinates.
                - &#39;xyz_title&#39;: Same as &#39;xyz&#39;, but prints the title instead of a space, if a title is available.
                - &#39;dimblock&#39;:  Same as &#39;xyz&#39;, but omits the space altogether.

        a1 : :obj:`int`
            The number of the lowest atom to print
        a2 : :obj:`int`, :obj:`None`
            The number of the highest atom to print.
            If given :obj:`None`, the number of the last atom is used
        file : :obj:`str`, :obj:`file`
            Where to print to.  If omitted, it will print to standard
            output.  You may give the name of a file or an already open
            :obj:`file` object to write to. Or, if `file` is &#39;xyz&#39;, then
            it will create a ``.xyz`` file based on the :attr:`filename`
            attribute and print there.
        latex : :obj:`bool`
            Causes the output to be printed in a LaTeX table type of format.

        Raises
        ------
        ValueError
            An invalid mode is entered

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.printCoords()
            Ag    0.00000000    0.00000000    0.00000000
            Ag    0.00000000    0.00000000    4.00000000
            &gt;&gt;&gt; static.printCoords(mode=&#39;num&#39;)
            1 Ag    0.00000000    0.00000000    0.00000000
            2 Ag    0.00000000    0.00000000    4.00000000
            &gt;&gt;&gt; static.printCoords(mode=&#39;xyz&#39;)
            2
            &lt;BLANKLINE&gt;
            Ag    0.00000000    0.00000000    0.00000000
            Ag    0.00000000    0.00000000    4.00000000
            &gt;&gt;&gt; static.printCoords(latex=True)
             Ag   &amp;    0.000000 &amp;    0.000000 &amp;    0.000000\\\\
             \\hline
             Ag   &amp;    0.000000 &amp;    0.000000 &amp;    4.000000\\\\
             \\hline

        &#39;&#39;&#39;
        valid_modes = (&#39;xyz&#39;, &#39;xyz_title&#39;, &#39;num&#39;, &#39;dimblock&#39;)
        if mode is not None and (mode not in valid_modes):
            raise ValueError(&#39;printCoords(): Invalid mode: &#39;+mode)

        # Create an xyz file if file is True
        if file == &#39;xyz&#39;:
            # Split current extention off filename, then replace with .xyz
            file = &#39;.&#39;.join([os.path.splitext(self.filename)[0], &#39;xyz&#39;])
            # Open, and remember we need to close after
            file = open(file, &#39;w&#39;)
            closebool = True
        # If file is None, use standard out
        elif file is None:
            file = sys.stdout
            closebool = False
        # Otherwise, try to open the file
        else:
            try:
                file = open(file, &#39;w&#39;)
            # If it fails, then it was already an open file
            except TypeError:
                closebool = False
            # If it suceeds, then remmeber that we must close the file
            else:
                closebool = True

        # Convert atom number to index
        a1 -= 1
        # Default to all.
        if a2 is None:
            a2 = len(self.atoms)

        # Determine how to format the line, and make numbers correct
        if mode == &#39;num&#39;:
            # Find string length of largest number to be printed and make that
            # number a string
            maxlen = str(len(str((a2 - a1) + 1)))
            fmt = &#39;{0:&lt;&#39;+maxlen+&#39;} {1:&lt;2}{2[0]:14.8f}{2[1]:14.8f}{2[2]:14.8f}&#39;
            num = 1
        else:
            if latex:
                fmt = &#39;{0:&gt;3}{2:&gt;4}{1[0]:12.6f}{2:&gt;2}{1[1]:12.6f}{2:&gt;2}{1[2]:12.6f}{3:&lt;2}&#39;
            else:
                fmt = &#39;{0:&lt;2}{1[0]:14.8f}{1[1]:14.8f}{1[2]:14.8f}&#39;

        # Make number of atoms
        natoms = len(self.atoms[a1:a2])

        # Print the number of atoms if the mode calls for it
        if mode in (&#39;xyz&#39;, &#39;xyz_title&#39;, &#39;dimblock&#39;):
            print(natoms, file=file)

        # Print a space if &#39;xyz&#39;, or if &#39;xyz_title&#39; and there is no title
        if mode == &#39;xyz&#39; or (mode == &#39;xyz_title&#39; and (&#39;title&#39; not in self or not self.title)):
            print(file=file)
        # Print the title if &#39;xyz_title&#39; and there is a title
        elif mode == &#39;xyz_title&#39;:
            print(self.title, file=file)

        # Print the coordinates
        for i in range(a1, a2):
            if mode == &#39;num&#39;:
                print(fmt.format(num, self.atoms[i], self.coordinates[i]), file=file)
                num += 1
            else:
                if latex:
                    print(fmt.format(self.atoms[i], self.coordinates[i], &#39;&amp;&#39;, r&#39;\\&#39;), file=file)
                    print(r&#39; \hline&#39;, file=file)
                else:
                    print(fmt.format(self.atoms[i], self.coordinates[i]), file=file)

        # Close the file if appropriate
        if closebool:
            file.close()

    def writeCoords(self, a1=1, a2=None):
        &#39;&#39;&#39;This is a shortcut for
        :func:`printCoords(mode=&#39;xyz&#39;, file=&#39;xyz&#39;) &lt;printCoords&gt;`.

        This will write the coordinates to a .xyz file based on the
        name in the filename attribute.

        &#39;&#39;&#39;
        self.printCoords(mode=&#39;xyz&#39;, file=&#39;xyz&#39;, a1=a1, a2=a2)

    def writePDB(self, a1=1, a2=None):
        &#39;&#39;&#39;Writes the coordinates to a .pdb file with the same name
        as the current file.

        Parameters
        ----------
        a1 : :obj:`int`
            The number of the lowest atom to print
        a2 : :obj:`int`, :obj:`None`
            The number of the highest atom to print.
            If given :obj:`None`, the number of the last atom is used

        &#39;&#39;&#39;

        # Define title format
        ft = &#39;CMPND  {0}&#39;
        # Define coordinate format
        fc = (&#39;HETATM{0:&gt;5d}{1:&gt;3}   LIG     1    &#39;
              &#39;{2[0]:&gt;8.3f}{2[1]:&gt;8.3f}{2[2]:&gt;8.3f}  1.00  0.00          &#39;
              &#39;{1:&gt;2}  &#39;)
        # Define bond format
        fb = &#39;CONECT{0:&gt;5d}&#39;

        # Convert atom number to index
        a1 -= 1
        # Default to all.
        if a2 is None:
            a2 = len(self.atoms)

        # Open the file as pdb with same name
        filename = &#39;.&#39;.join([os.path.splitext(self.filename)[0], &#39;pdb&#39;])
        with open(filename, &#39;w&#39;) as fl:

            # pbd Starts with some info.  Give the title if there is one
            if &#39;title&#39; in self and self.title:
                title = ft.format(&#39;MOLECULE: &#39;+self.title)
            else:
                title = ft.format(&#39;UNNAMED&#39;)
            print(title, file=fl)

            # Place the coordinates in the file
            i = 1
            for atom, coord in zip(self.atoms[a1:a2], self.coordinates[a1:a2]):
                print(fc.format(i, atom, coord), file=fl)
                i += 1

            # Place the bonds in the file.  The bonding is redundant, so each
            # atom must be specified and bonds will be listed mutlitple times.
            for i in xrange(self.natoms):

                # Skip atoms we don&#39;t want to show a bond to
                if i &lt; a1 or i &gt; a2:
                    continue

                # Print the bonding keyword
                print(fb.format(i+1), end=&#39;&#39;, file=fl)

                # Find everywhere that this atoms is in the first column
                indx = where(self.bonds[:, 0] == i)[0]

                # Print off all atoms this one is bonded to
                for j in indx:
                    # Skip atoms we don&#39;t want to show a bond to
                    if self.bonds[j, 1] &lt; a1 or self.bonds[j, 1] &gt; a2:
                        continue
                    print(&#39;{0:&gt;5d}&#39;.format(self.bonds[j, 1]+1), end=&#39;&#39;, file=fl)

                # Repeat for the second column
                indx = where(self.bonds[:, 1] == i)[0]
                for j in indx:
                    # Skip atoms we don&#39;t want to show a bond to
                    if self.bonds[j, 0] &lt; a1 or self.bonds[j, 0] &gt; a2:
                        continue
                    print(&#39;{0:&gt;5d}&#39;.format(self.bonds[j, 0]+1), end=&#39;&#39;, file=fl)

                # New line
                print(file=fl)

            # End the file
            print(&#39;END   &#39;, file=fl)

    def join(self, other):
        &#39;&#39;&#39;Concatenates one molecule into the current one.

        The attributes that are concatenated are:

          - :attr:`~.coordinates`
          - :attr:`~.atoms`
          - ``natoms``
          - :attr:`~.elements`
          - :attr:`~.nelements`

        All other properties would be unphysical to concatenate
        and are emptied.

        Parameters
        ----------
        other : :class:`DIM`
            The other :class:`DIM` object to concatenate with this one

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; np1 = dim.quick_test()
            &gt;&gt;&gt; np1.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; np2 = dim.quick_test()
            &gt;&gt;&gt; np2.translate_coordinates([3.0, 0.0, 0.0])
            &gt;&gt;&gt; np2.coordinates
            array([[ 3.,  0.,  0.],
                   [ 3.,  0.,  4.]])
            &gt;&gt;&gt; np1.join(np2)
            &gt;&gt;&gt; np1.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.],
                   [ 3.,  0.,  0.],
                   [ 3.,  0.,  4.]])
            &gt;&gt;&gt; np1.atoms
            array([&#39;Ag&#39;, &#39;Ag&#39;, &#39;Ag&#39;, &#39;Ag&#39;], 
                  dtype=&#39;|S2&#39;)

        &#39;&#39;&#39;
        self.coordinates = concatenate((self.coordinates, other.coordinates))
        self.atoms = concatenate((self.atoms, other.atoms))
        self.natoms = len(self.atoms)
        self.elements.update(other.elements)
        self.nelements = len(self.elements)
        self.empty(ignore=[&#39;coordinates&#39;, &#39;atoms&#39;, &#39;natoms&#39;,
                           &#39;elements&#39;, &#39;nelements&#39;])
        self._bonds = None
        self._minmax = None

    def find_center(self, type=&#39;geometrical&#39;):
        &#39;&#39;&#39;Locates the center of the nanoparticle.

        Parameters
        ----------
        type : {&#39;geometrical&#39;, &#39;center-of-mass&#39;}
            The type of the center-of-mass to locate

        Returns
        -------
        center : :obj:`float`
            The center-of-mass of the nanoparticle

        Raises
        -------
        ValueError
            An invalid type is given.

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; static.find_center()
            array([ 0.,  0.,  2.])

        &#39;&#39;&#39;

        if type == &#39;center-of-mass&#39;:
            wt = self.masses
        elif type == &#39;geometrical&#39;:
            wt = None
        else:
            raise ValueError(&#39;find_center(): Invalid type: &#39;+type)

        # Now find the center of mass
        return average(self.coordinates, axis=0, weights=wt)

    def shift_to_origin(self, type=&#39;geometrical&#39;):
        &#39;&#39;&#39;\
        Shifts the coordinates in place so that the center of the
        molecule is at the origin.

        Parameters
        ----------
        type : {&#39;geometrical&#39;, &#39;center-of-mass&#39;}
            Determines the center type.  See :meth:`find_center`.

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; static.shift_to_origin()
            &gt;&gt;&gt; static.coordinates
            array([[ 0.,  0., -2.],
                   [ 0.,  0.,  2.]])

        &#39;&#39;&#39;
        self.translate_coordinates(-self.find_center(type))

    def radii(self, set):
        &#39;&#39;&#39;\
        Returns the radii for each atom in the nanoparticle.

        Parameters
        ----------
        set : {&#39;vis&#39;, &#39;vdw&#39;}
            Specifies from which set of data you wish
            to collect the radii.  The options are:

                -vis: These radii are good for molecular visualizations but are not physical
                -vdw: These use the van Der Waals radii and are intended to be physical, however not all elements are available.

        Returns
        -------
        radii : :obj:`numpy.ndarray` of length ``natoms``.
            The radii for each atom

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.atoms
            array([&#39;Ag&#39;, &#39;Ag&#39;], 
                  dtype=&#39;|S2&#39;)
            &gt;&gt;&gt; static.radii(&#39;vis&#39;)
            array([ 1.44,  1.44])

        &#39;&#39;&#39;

        # Find radii for each atom
        rad = zeros(self.natoms)
        for i in xrange(self.natoms):
            rad[i] = atomic_radius(self.atoms[i], set)
        return rad

    def translate_coordinates(self, transvec):
        &#39;&#39;&#39;\
        Translates the coordinates in place.

        Parameters
        ----------
        transvec : :obj:`numpy.ndarray` of length 3
            The translation vector by which to translate the coordinates

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; static.translate_coordinates([3.0, 1.0, 0.0])
            &gt;&gt;&gt; static.coordinates
            array([[ 3.,  1.,  0.],
                   [ 3.,  1.,  4.]])

        &#39;&#39;&#39;
        self.coordinates += transvec

    def rotate_coordinates(self, rotmat=None, angle=None, dir=None, rad=False):
        &#39;&#39;&#39;Rotates the coordinates.

        Parameters
        ----------
        rotmat : :obj:`numpy.ndarray` of shape 3 x 3
            The rotation matrix to use to rotate the nanoparticle.
            Mutually exclusive with the `angle` parameter.
        angle : :obj:`float`, :obj:`list` of :obj:`float`
            An angle by which to rotate the coordinates.  If given
            as a :obj:`list`, the coordinates are rotated by each
            angle in the order they are given.
            Mutually exclusive with the `rotmat` parameter.
        dir : {&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;}
            The direction in which to rotate the coordinates
            for a given angle. Required when the `angle` parameter
            is given. If `angle` is given as a :obj:`list`, `dir`
            must be a :obj:`list` of the same length
        rad : :obj:`bool`
            Tells if the angle is in radians or note.

        Raises
        ------
        ValueError
            Invalid arguments are given

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; import numpy
            &gt;&gt;&gt; np1 = dim.quick_test()
            &gt;&gt;&gt; np1.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; np1.rotate_coordinates(angle=90, dir=&#39;X&#39;)
            &gt;&gt;&gt; numpy.around(np1.coordinates)
            array([[ 0.,  0.,  0.],
                   [ 0.,  4.,  0.]])
            &gt;&gt;&gt; np2 = dim.quick_test()
            &gt;&gt;&gt; np2.rotate_coordinates(angle=[45, 45], dir=[&#39;X&#39;, &#39;Z&#39;])
            &gt;&gt;&gt; numpy.around(np2.coordinates, decimals=5)
            array([[ 0.     ,  0.     ,  0.     ],
                   [ 0.     ,  2.82843,  2.82843]])
            &gt;&gt;&gt; np3 = dim.quick_test()
            &gt;&gt;&gt; np3.rotate_coordinates(rotmat=numpy.array([[0.5, 1.0, 1.0],
            ...                                            [1.0, 0.5, 0.0],
            ...                                            [1.0, 0.0, 0.5]]))
            &gt;&gt;&gt; numpy.around(np3.coordinates, decimals=5)
            array([[ 0.,  0.,  0.],
                   [ 4.,  0.,  2.]])

        &#39;&#39;&#39;

        if rotmat is None and angle is None:
            ValueError(&#34;rotate_coordinates(): &#34;
                       &#34;Must choose one of &#39;rotmat&#39; or &#39;angle&#39;&#34;)
        if rotmat is not None and angle is not None:
            ValueError(&#34;rotate_coordinates(): &#34;
                       &#34;Must choose only one of &#39;rotmat&#39; or &#39;angle&#39;&#34;)

        # Create matrix if not given explicitly
        # Create a general 3-D rotation
        if rotmat is None:
            if dir is None:
                raise ValueError(&#34;rotate_coordinates(): &#34;
                                 &#34;&#39;dir&#39; must not be empty with &#39;angle&#39;&#34;)
            if isinstance(angle, list) and not isinstance(dir, list):
                raise ValueError(&#34;rotate_coordinates(): &#34;
                                 &#34;&#39;angle&#39; and &#39;dir&#39; must both be either &#34;
                                 &#34;a &#39;list&#39; or &#39;str&#39;&#34;)
            if not isinstance(angle, list) and isinstance(dir, list):
                raise ValueError(&#34;rotate_coordinates(): &#34;
                                 &#34;&#39;angle&#39; and &#39;dir&#39; must both be either &#34;
                                 &#34;a &#39;list&#39; or &#39;str&#39;&#34;)
            # Make sure lists are the same length, and turn non-list in to list
            if isinstance(angle, list):
                if len(angle) != len(dir):
                    raise ValueError(&#34;rotate_coordinates(): &#34;
                                     &#34;&#39;angle&#39; and &#39;dir&#39; must be the same length&#34;)
            else:
                angle = [angle]
                dir = [dir]

            # Generate the general rotation matrix
            rotmat = eye(3)
            for a, d in zip(angle, dir):
                if not rad:
                    a = radians(a)
                c = cos(a)
                s = sin(a)
                if d.lower() == &#39;x&#39;:
                    temp = array([[ 1,  0,  0 ],
                                  [ 0,  c, -s ],
                                  [ 0,  s,  c ]], dtype=float)
                elif d.lower() == &#39;y&#39;:
                    temp = array([[ c,  0,  s ],
                                  [ 0,  1,  0 ],
                                  [-s,  0,  c ]], dtype=float)
                elif d.lower() == &#39;z&#39;:
                    temp = array([[ c, -s,  0 ],
                                  [ s,  c,  0 ],
                                  [ 0,  0,  1 ]], dtype=float)
                else:
                    raise ValueError(&#34;Unknown value for &#39;dir&#39;: &#34;+str(d))

                # Create the rotmat in rotation order. Not that this is
                # backwards from what you would expect because internally the
                # rotation is done with the coordinates first.
                rotmat = dot(temp, rotmat)

        # Rotate. Use fast MKL routine to do so
        #self.coordinates = rotate(rotmat, self.coordinates)
        self.coordinates = dot(self.coordinates, rotmat)

    def order_coords(self, atom=None, coord=None):
        &#39;&#39;&#39;\
        Reorders the coordinates according to proximity to either
        a specific atom or a point in space.

        Parameters
        ----------
        atom : :obj:`int`
            The atom to reorder by.
        coord : :obj:`numpy.ndarray` of length 3
            The point in space to reorder with respect to.

        Raises
        ------
        ValueError
            One and only one of `atom` and `coord` is not given.

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; np1 = dim.quick_test()
            &gt;&gt;&gt; np1.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; np1.order_coords(coord=[0.0, 0.0, 5.0])
            &gt;&gt;&gt; np1.coordinates
            array([[ 0.,  0.,  4.],
                   [ 0.,  0.,  0.]])
            &gt;&gt;&gt; np2 = dim.quick_test()
            &gt;&gt;&gt; np2.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; np2.order_coords(atom=2)
            &gt;&gt;&gt; np2.coordinates
            array([[ 0.,  0.,  4.],
                   [ 0.,  0.,  0.]])

        &#39;&#39;&#39;

        if atom is None and coord is None:
            raise ValueError(&#39;order_coords(): Must choose one of atoms or coords.&#39;)
        if atom and coord:
            raise ValueError(&#39;order_coords(): Cannot use both atoms and coords.&#39;)

        # First determine the distance from the points
        if atom is not None:
            c = self.coordinates[atom-1]
        else:
            c = coord

        # Sort the distances and return the sorted indices.
        index = argsort(npsqrt(sum((c - self.coordinates)**2, axis=1)))
        # Sort atoms coodinates and modes.
        self.atoms = self.atoms[index]
        self.coordinates = self.coordinates[index]
        self._bonds = None

    def printTensor(self, iso=False, ani=False, unit=&#39;au&#39;, p1=1, p2=None):
        &#39;&#39;&#39;\
        Pretty print the polarizability tensor to standard output.  One
        tensor is printed for each frequency.

        If the calculation was FD,
        then the real and imaginary tensors are printed alongside each other.

        Parameters
        ----------
        iso : :obj:`bool`
            Prints the isotropic polarizability along with the tensor
        ani : :obj:`bool`
            Prints the anisotropic polarizability along with the tensor
        unit : {&#39;au&#39;, &#39;ev&#39;, &#39;nm&#39;}
            Specifies the unit to print the frequency that corresponds
            to each polarizability tensor.
        p1 : :obj:`int`
            The number of the lowest polarizability tensor to print
        a2 : :obj:`int`, :obj:`None`
            The number of the highest polarizability tensor to print.
            If given :obj:`None`, the number of the last atom is used

        Raises
        ------
        DIMError
            No polarizabilities were collected.

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.printTensor(iso=True, ani=True, unit=&#39;ev&#39;)
            &lt;BLANKLINE&gt;
            Static Polarizability
                            X               Y               Z
               X          71.324           0.000           0.000
               Y           0.000          71.324           0.000
               Z           0.000           0.000          93.755
            &lt;BLANKLINE&gt;
            ISOTROPIC PART    =       78.801
            ANISOTROPIC PART  =       22.431
            &lt;BLANKLINE&gt;
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.printTensor(iso=True, ani=True, unit=&#39;ev&#39;)
            &lt;BLANKLINE&gt;
            FD Polarizability: Energy 3.50001 eV
                                           Real                                                Imaginary
                            X               Y               Z                      X               Y               Z
               X         200.794           0.000           0.000      X         264.060           0.000           0.000
               Y           0.000         200.794           0.000      Y           0.000         264.060           0.000
               Z           0.000           0.000        -188.906      Z           0.000           0.000         296.316
            &lt;BLANKLINE&gt;
            ISOTROPIC PART    =       70.894 + 274.812j
            ANISOTROPIC PART  =      391.033
            &lt;BLANKLINE&gt;
            FD Polarizability: Energy 3.69999 eV
                                           Real                                                Imaginary
                            X               Y               Z                      X               Y               Z
               X         -81.283           0.000           0.000      X          99.260           0.000           0.000
               Y           0.000         -81.283           0.000      Y           0.000          99.260           0.000
               Z           0.000           0.000         -78.875      Z           0.000           0.000          57.359
            &lt;BLANKLINE&gt;
            ISOTROPIC PART    =     -80.4803 +  85.293j
            ANISOTROPIC PART  =      41.9701
            &lt;BLANKLINE&gt;

        &#39;&#39;&#39;
        if &#39;polarizability&#39; not in self:
            raise ValueError(&#39;printTensor(): &#39;
                             &#39;No polarizabilities were collected.&#39;)
        # Convert pol number to index
        p1 -= 1
        # Default to all.
        if p2 is None:
            p2 = self.npol

        # Set the unit and energy type
        if not re.match(r&#39;au|ev|nm&#39;, unit, re.I):
            raise ValueError(&#39;printTensor() : Invalid unit: &#39;+unit)
        else:
            unit = {&#39;au&#39;: &#39;a.u.&#39;, &#39;ev&#39;: &#39;eV&#39;, &#39;nm&#39;: &#39;nm&#39;}[unit.lower()]
            etyp = {&#39;a.u.&#39;: &#39;Frequency&#39;,
                    &#39;eV&#39;: &#39;Energy&#39;,
                    &#39;nm&#39;: &#39;Wavelength&#39;}[unit]

        # Set the tensor
        prop = &#39;Polarizability&#39;

        # Start the formatting of the label
        if &#39;RAMAN&#39; in self.calctype:
            lbl = self.v_frequencies
        else:
            with errstate(divide=&#39;ignore&#39;):
                lbl = {&#39;a.u.&#39;: self.e_frequencies,
                       &#39;eV&#39;: HART2EV(self.e_frequencies),
                       &#39;nm&#39;: HART2NM(self.e_frequencies)}[unit]

        # Diagonalized or not
        d = &#39;, Diagonalized&#39; if self._diagonalized else &#39;&#39;

        # Print selected tensors in class
        print()
        for n in range(p1, p2):

            t = self.polarizability[n]
            r = t.real
            i = t.imag

            # Prints out the proper heading depending on the energy type
            # and the unit.
            # First, make the number at most 7 digits with &#39;good&#39; formatting
            # Strip off whitespace
            s = &#39;{0:7g}&#39;.format(lbl[n]).strip()
            # Now place this number in the heading
            head = &#39;FD {4}: {0} {1} {2}{3}&#39;.format(etyp, s, unit, d, prop)
            # Replace the heading if this was a static calculation
            if s == &#39;0&#39;:
                head = &#39;Static {0}&#39;.format(prop)
            print(head)

            # Pretty-print the tensor
            if self.calctype == &#39;FD&#39;:
                label = &#39;{0:&gt;35}{1:35}{2:&gt;22}&#39;
                head = &#39;{0:&gt;17}{1:&gt;16}{2:&gt;16}{3:6}{0:&gt;17}{1:&gt;16}{2:&gt;16}&#39;
                fr = &#39;{0:&gt;4}{1[0]:16.3f}{1[1]:16.3f}{1[2]:16.3f}  &#39;
                fi = &#39;{0:&gt;4}{1[0]:16.3f}{1[1]:16.3f}{1[2]:16.3f}&#39;
                print(label.format(&#39;Real&#39;, &#39;&#39;, &#39;Imaginary&#39;))
                print(head.format(&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;&#39;))
                print(fr.format(&#39;X&#39;, r[0, :]), fi.format(&#39;X&#39;, i[0, :]))
                print(fr.format(&#39;Y&#39;, r[1, :]), fi.format(&#39;Y&#39;, i[1, :]))
                print(fr.format(&#39;Z&#39;, r[2, :]), fi.format(&#39;Z&#39;, i[2, :]))
            else:
                head = &#39;{0:&gt;17}{1:&gt;16}{2:&gt;16}&#39;
                f = &#39;{0:&gt;4}{1[0]:16.3f}{1[1]:16.3f}{1[2]:16.3f}&#39;
                print(head.format(&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;))
                print(f.format(&#39;X&#39;, r[0, :]))
                print(f.format(&#39;Y&#39;, r[1, :]))
                print(f.format(&#39;Z&#39;, r[2, :]))

            # Add the invariants at the end if requested
            if iso or ani:
                print()
            if iso:
                print(&#39;ISOTROPIC PART    = &#39;, end=&#39;&#39;)
                iso = self.isotropic[n]
                if &#39;FD&#39; in self.calctype:
                    print(&#39;{0:12g} + {1:7g}j&#39;.format(iso.real, iso.imag))
                else:
                    print(&#39;{0:12g}&#39;.format(iso))
            if ani:
                ani = self.anisotropic2[n]
                print(&#39;ANISOTROPIC PART  = {0:12g}&#39;.format(sqrt(ani)))

            print()

    def printOptical(self, property=&#39;cross-section&#39;,
                     pathlength=None, concentration=None, unit=&#39;au&#39;,
                     absunit=&#39;angstroms&#39;):
        &#39;&#39;&#39;Prints a list of optical properties.

        Parameters
        ----------
        property : {&#39;absorption&#39;, &#39;absorptivitty&#39;, &#39;absorbance&#39;, &#39;transmittance&#39;}
            Specifies the optical property to print.
            The choices are:

                - cross-section-&gt; :meth:`cross_section`
                - absorptivitty -&gt; :meth:`molar_absorptivitty`
                - absorbance -&gt; :meth:`absorbance`
                - transmittance -&gt; :meth:`transmittance`

        pathlength : :obj:`float`
            If the `property` is &#39;absorbance&#39; or &#39;transmission&#39;,
            you will need to specify the pathlength for Beer&#39;s
            law in centimeters.
        concentration : :obj:`float`
            If the `property` is &#39;absorbance&#39; or &#39;transmission&#39;,
            you will need to specify the concentration for Beer&#39;s
            law in molarity.
        unit : {&#39;au&#39;, &#39;ev&#39;, &#39;nm&#39;}
            This is the unit to print the frequencies. The options are:

                - &#39;au&#39; -&gt; atomic units, Hartrees
                - &#39;ev&#39; -&gt; electron volts
                - &#39;nm&#39; -&gt; nanometers

        absunit : :obj:`str`
            This is the unit that that absorption cross section
            is calculated at.  See :meth:`cross_section`.

        Raises
        ------
        ValueError
            Invalid arguments given

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.printOptical(property=&#39;cross-section&#39;, unit=&#39;nm&#39;, absunit=&#39;cm&#39;)  # doctest: +NORMALIZE_WHITESPACE
            Wavelength (nm)   Absorption Cross-Section (cm^2/molecule)
                354.2395                       3.24138E-02
                335.0936                       1.06350E-02
            &gt;&gt;&gt; fd.printOptical(property=&#39;transmittance&#39;, pathlength=1.0, concentration=1e-6)  # doctest: +NORMALIZE_WHITESPACE
            Pathlength=1.00 cm, Concentration=1.000E-06 M
             Frequency (a.u.)            Transmittance (unitless)
               1.2862E-01                      8.22670E-01
               1.3597E-01                      9.37962E-01

        &#39;&#39;&#39;

        # Prep for printing
        if property == &#39;cross-section&#39;:
            values = self.cross_section(unit=absunit)
            label = &#39;Absorption Cross-Section&#39;
            if absunit == &#39;angstroms&#39;:
                u = unicode(u&#39;\u212B^2/molecule&#39;)
            elif absunit == &#39;bohr&#39;:
                u = &#39;bohr^2/molecule&#39;
            elif absunit == &#39;nm&#39;:
                u = &#39;nm^2/molecule&#39;
            elif absunit == &#39;cm&#39;:
                u = &#39;cm^2/molecule&#39;
            elif absunit == &#39;m&#39;:
                u = &#39;m^2/molecule&#39;
        elif property == &#39;absorptivitty&#39;:
            values = self.molar_absorptivitty()
            label, u = &#39;Molar Absorptivitty&#39;, &#39;L mol^{-1} cm^{-1}&#39;
        elif property == &#39;absorbance&#39;:
            values = self.absorbance(pathlength, concentration)
            label, u = &#39;Absorbance&#39;, &#39;unitless&#39;
        elif property == &#39;transmittance&#39;:
            values = self.transmittance(pathlength, concentration)
            label, u = &#39;Transmittance&#39;, &#39;unitless&#39;
        else:
            raise ValueError(&#39;printOptical(): &#39;
                             &#39;invalid property (&#39;+property+&#39;)&#39;)

        # Choose frequency unit
        if not re.match(r&#39;au|ev|nm&#39;, unit, re.I):
            raise ValueError(&#39;printTensor() : Invalid unit: &#39;+unit)
        unit = {&#39;au&#39;: &#39;a.u.&#39;, &#39;ev&#39;: &#39;eV&#39;, &#39;nm&#39;: &#39;nm&#39;}[unit.lower()]
        etyp = {&#39;a.u.&#39;: &#39;Frequency&#39;,
                &#39;eV&#39;: &#39;Energy&#39;,
                &#39;nm&#39;: &#39;Wavelength&#39;}[unit]
        frequencies = {&#39;a.u.&#39;: self.e_frequencies,
                       &#39;eV&#39;: HART2EV(self.e_frequencies),
                       &#39;nm&#39;: HART2NM(self.e_frequencies)}[unit]

        # Title
        if property in (&#39;absorbance&#39;, &#39;transmittance&#39;):
            string = &#39;Pathlength={0:.2f} cm, Concentration={1:.3E} M&#39;
            print(string.format(pathlength, concentration))
        string = unicode(u&#39;{0:&gt;10} {1:&lt;6} {2:&gt;24} {3:&lt;20}&#39;)
        print(string.format(etyp, &#39;(&#39;+unit+&#39;)&#39;, label, &#39;(&#39;+u+&#39;)&#39;))

        # A format string
        if unit == &#39;a.u.&#39;:
            fmt = &#39;{0:^17.4E} {1:^45.5E}&#39;
        else:
            fmt = &#39;{0:^17.4f} {1:^45.5E}&#39;

        # Print the properties
        for freq, val in zip(frequencies, values):
            print(fmt.format(freq, val))

    def cross_section(self, unit=&#39;angstroms&#39;):
        &#39;&#39;&#39;Returns the absorption cross-section of the system.

        Parameters
        ----------
        unit : {&#39;angstroms&#39;, &#39;nm&#39;, &#39;bohr&#39;, &#39;cm&#39;, &#39;m&#39;}
            The unit in which the cross section will be returned

                - &#39;angstroms&#39; -&gt; angstroms^2/molecule
                - &#39;nm&#39; -&gt; nm^2/molecule
                - &#39;bohr&#39; -&gt; bohr^2/molecule
                - &#39;cm&#39; -&gt; cm^2/molecule
                - &#39;m&#39; -&gt; m^2/molecule

        Returns
        -------
        cross_section : :obj:`numpy.ndarray` of length :attr:`~.npol`
            The absorption cross section for each frequency

        Raises
        ------
        ValueError
            Invalid arguments given
        DIMError
            Not an FD calculation

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.cross_section()
            array([ 3.24137681,  1.06350141])
            &gt;&gt;&gt; fd.cross_section(unit=&#39;nm&#39;)
            array([ 0.03241377,  0.01063501])
            &gt;&gt;&gt; fd.cross_section(unit=&#39;cm&#39;)
            array([  3.24137681e-16,   1.06350141e-16])

        &#39;&#39;&#39;

        # Assign the correct unit converter
        if unit.lower() == &#39;angstroms&#39;:
            conv = NOCONV
        elif unit.lower() == &#39;bohr&#39;:
            conv = ANGSTROM2BOHR
        elif unit.lower() == &#39;nm&#39;:
            conv = ANGSTROM2NM
        elif unit.lower() == &#39;cm&#39;:
            conv = ANGSTROM2CM
        elif unit.lower() == &#39;m&#39;:
            conv = ANGSTROM2M
        else:
            raise ValueError(&#39;cross_section(): Invalid unit (&#39;+unit.lower()+&#39;)&#39;)

        if self.calctype == &#39;FD&#39;:
            iso = self.isotropic.imag
            # Conversion is performed twice because the property is squared
            return conv(conv((4 * PI * self.e_frequencies / LIGHT_AU) * iso))
        else:
            raise DIMError(&#39;cross_section(): Not a FD calculation&#39;)

    def molar_absorptivitty(self):
        &#39;&#39;&#39;Calculates the molar absorptivitty of the system in units of
        L mol^{-1} cm^{-1} or M^{-1} cm^{-1} (these are equivalent).

        Returns
        -------
        molar_absorptivitty : :obj:`numpy.ndarray` of length :attr:`~.npol`
            The molar absorptivitty for each frequency in

        Raises
        ------
        ValueError
            Invalid arguments given
        DIMError
            Not an FD calculation

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.molar_absorptivitty()
            array([ 84774.41649881,  27814.63448711])

        &#39;&#39;&#39;
        from math import log as ln

        # Conversion factor to get from angstroms^2 to L/cm.
        # L == dm^3
        # dm^2 == 1E18 angstroms^2
        # dm^2 == 0.1 dm^3/cm
        # 0.1 dm^3/cm = 1E18 angstroms^2
        # 1E-19 = dm^3/(cm*angstroms^2)
        CONVFACTOR = 1E-19

        # Get the absorption cross-section in angstroms^2/molecule
        acs = self.cross_section()
        # Use this to calculate the molar absorptivity
        # LN(10) accounts for Beer&#39;s law
        return AVOGADRO * CONVFACTOR * acs / ln(10)

    def absorbance(self, pathlength, concentration):
        &#39;&#39;&#39;\
        Calculates the (unitless) absorbance of the system using
        Beer&#39;s law.

        Parameters
        ----------
        pathlength : :obj:`float`
            The pathlength in centimeters of the light
        concentration : :obj:`float`
            The solution concentration in molarity

        Returns
        -------
        absorbance : :obj:`numpy.ndarray` of length :attr:`~.npol`
            The unitless absorbance for each frequency

        Raises
        ------
        ValueError
            Invalid arguments given
        DIMError
            Not an FD calculation

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.absorbance(1.5, 1.5e-6)
            array([ 0.19074244,  0.06258293])

        &#39;&#39;&#39;
        eps = self.molar_absorptivitty()
        return eps * pathlength * concentration

    def transmittance(self, pathlength, concentration):
        &#39;&#39;&#39;\
        Calculates the transmittance from the absorbance on a scale
        from 0 to 1.  The user must convert to percent if she so desires.

        Parameters
        ----------
        pathlength : :obj:`float`
            The pathlength in centimeters of the light
        concentration : :obj:`float`
            The solution concentration in molarity

        Returns
        -------
        transmittance : :obj:`numpy.ndarray` of length :attr:`~.npol`
            The normalized transmittance for each frequency in

        Raises
        ------
        ValueError
            Invalid arguments given
        DIMError
            Not an FD calculation

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.transmittance(1.5, 1.5e-6)
            array([ 0.64455141,  0.86579899])

        &#39;&#39;&#39;
        absorb = self.absorbance(pathlength, concentration)
        return power(10, -absorb)

    def pol_minmax(self):
        &#39;&#39;&#39;\
        Finds the minimum and maximum isotropic polarizabilities

        Returns
        -------
        pol_min : :obj:`float`
            Minimum isotropic polarizability
        pol_max : :obj:`float`
            Maximum isotropic polarizability

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; minmax = fd.pol_minmax()
            &gt;&gt;&gt; fd.isotropic
            array([ 70.89400000+274.812j, -80.48033333 +85.293j])
            &gt;&gt;&gt; round(minmax[0].real, 4)
            -80.4803
            &gt;&gt;&gt; round(minmax[0].imag, 4)
            85.293
            &gt;&gt;&gt; round(minmax[1].real, 4)
            70.894
            &gt;&gt;&gt; round(minmax[1].imag, 4)
            274.812

        &#39;&#39;&#39;
        return (self.isotropic.min(),
                self.isotropic.max())

    def pol_diagonalize(self):
        &#39;&#39;&#39;Diagonalizes the polarizability tensors in place.

        Returns
        -------
        rotmat : :obj:`numpy.ndarray` of shape :attr:`~.npol` x 3 x 3
            Rotation matrix after diagonalization

        Raises
        ------
        DIMError
            Diagonalization does not converge

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.polarizability
            array([[[ 71.324,   0.   ,   0.   ],
                    [  0.   ,  71.324,   0.   ],
                    [  0.   ,   0.   ,  93.755]]])
            &gt;&gt;&gt; static.pol_diagonalize()
            array([[[ 1.,  0.,  0.],
                    [ 0.,  1.,  0.],
                    [ 0.,  0.,  1.]]])
            &gt;&gt;&gt; static.polarizability
            array([[[ 71.324,   0.   ,   0.   ],
                    [  0.   ,  71.324,   0.   ],
                    [  0.   ,   0.   ,  93.755]]])
            &gt;&gt;&gt; # Note: This example shows no difference  before and
            &gt;&gt;&gt; # after diagonalization because the tensor was already
            &gt;&gt;&gt; # diagonalized because the nanoparticle is linear on the
            &gt;&gt;&gt; # z-axis.

        &#39;&#39;&#39;

        # Find the eigenvector and eigenvalues of the tensor
        # The eigenvector is the diagonal of the tensor, and the
        # eigenvalues are the rotation matrix.
        rotation = zeros_like(self.polarizability)

        for n in range(self.npol):
            try:
                eigenvec, eigenval = eig(self.polarizability[n])
            except LinAlgError:
                raise DIMError(&#39;Diagonalization of polarizability &#39;
                               &#39;tensor does not converge&#39;)
            else:
                self.polarizability[n] = diagflat(eigenvec)
                rotation[n] = eigenval

        # Remember the state
        self._diagonalized = True

        return rotation

    def absorb(self, other, ignore=set()):
        &#39;&#39;&#39;\
        Method to &#34;absorb&#34; all of the data from another
        :py:class:`DIM` instance to the current DIM instance.

        Data in `other` overwrite data in `self`.
        Empty parameters in `other` will be ignored.

        Parameters
        ----------
        other : :class:`DIM`
            The :class:`DIM` object to be absorbed.
        ignore : :obj:`set`
            Attributes that will **NOT** be absorbed.

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)

        &#39;&#39;&#39;
        # Not DIM instance
        if not isinstance(other, DIM):
            raise DIMError(&#39;absorb(): other != DIM()&#39;)
        # Make sure ignore is a set
        ignore = set(ignore)

        # Set of attributes to absorb
        attr = set([&#39;calctype&#39;, &#39;subkey&#39;, &#39;key&#39;, &#39;natoms&#39;, &#39;coordinates&#39;,
                    &#39;atoms&#39;, &#39;elements&#39;, &#39;npol&#39;, &#39;e_frequencies&#39;,
                    &#39;polarizability&#39;, &#39;efficiencies&#39;, &#39;cross_section&#39;,
                    &#39;dipoles&#39;, &#39;charges&#39;, &#39;start&#39;, &#39;real_time&#39;, &#39;cpu_time&#39;,
                    &#39;routine_time&#39;, &#39;termination&#39;, &#39;host&#39;, &#39;nprocs&#39;])

        # Run over all attributes on the attribute list (minus the ones
        # in ignore) and copy into this instance.
        # Don&#39;t copy things that are None.
        for k in attr.difference(ignore):
            if k not in other:
                continue
            setattr(self, k, deepcopy(getattr(other, k)))
        if &#39;coordinates&#39; not in ignore:
            self._minmax = None
            self._bonds = None

    def empty(self, ignore=set()):
        &#39;&#39;&#39;\
        Empties all attributes in the current :class:`DIM` instance
        except those on the ignore list.

        Parameters
        ----------
        ignore : :obj:`set`
            A set of attributes to **NOT** empty

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)

        &#39;&#39;&#39;
        # Make sure ignore is a set
        ignore = set(ignore)

        # Set of attributes to empty
        attr = set([&#39;calctype&#39;, &#39;subkey&#39;, &#39;key&#39;, &#39;natoms&#39;, &#39;coordinates&#39;,
                    &#39;atoms&#39;, &#39;elements&#39;, &#39;npol&#39;, &#39;e_frequencies&#39;,
                    &#39;polarizability&#39;, &#39;efficiencies&#39;, &#39;cross_section&#39;,
                    &#39;dipoles&#39;, &#39;charges&#39;, &#39;start&#39;, &#39;real_time&#39;, &#39;cpu_time&#39;,
                    &#39;routine_time&#39;, &#39;termination&#39;, &#39;host&#39;, &#39;nprocs&#39;])

        # Run over all attributes and empty them, except for the ones
        # in ignore.
        for k in attr.difference(ignore):
            if k in (&#39;calctype&#39;, &#39;subkey&#39;):
                setattr(self, k, set())
            elif k == &#39;key&#39;:
                setattr(self, k, {})
            else:
                setattr(self, k, None)
        if &#39;coordinates&#39; not in ignore:
            self._minmax = None
            self._bonds = None


    #################
    # MANAGED METHODS
    #################

    @property
    def masses(self):
        &#34;&#34;&#34;The atomic mass of each atom in the nanoparticle

        .. note:: This is a property method, meaning that this is called
                  as though it were an attribute of :class:`DIM`, so
                  no parentheses are used.

        Returns
        -------
        masses : :obj:`numpy.ndarray` of length ``natoms``
            The atomic masses in the system

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.masses
            array([ 106.905093,  106.905093])

        &#34;&#34;&#34;
        # Make the atomic mass function broadcastable on a numpy array
        atm_mass = vectorize(atomic_mass)
        # Return the mass for each atom
        return atm_mass(self.atoms)

    @property
    def molecular_mass(self):
        &#34;&#34;&#34;The total mass of the nanoparticle

        .. note:: This is a property method, meaning that this is called
                  as though it were an attribute of :class:`DIM`, so
                  no parentheses are used.

        Returns
        -------
        molecular_mass : :obj:`float`
            The molecular mass of the nanoparticle

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; round(static.molecular_mass, 6)
            213.810186

        &#34;&#34;&#34;
        # Sum masses and return the total molecular mass
        return self.masses.sum()

    @property
    def bonds(self):
        &#34;&#34;&#34;Returns a list of the bonds in the system

        Given that ``N`` is the number of bonds, this is an ``N`` x 2 numpy
        array containing the index of atom 1 and atom 2 of each bond.
        Therefore, bond ``i`` goes from ``self.coordinates[self.bonds[i,0]]``
        to ``self.coordinates[self.bonds[i,1]]``

         .. note:: This is a property method, meaning that this is called
                  as though it were an attribute of :class:`DIM`, so
                  no parentheses are used.

        Returns
        -------
        bonds :  :obj:`numpy.ndarray` of shape ``N`` x 2
            The array of bonds

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.bonds
            array([], shape=(0, 2), dtype=int64)
            &gt;&gt;&gt; # This is empty because the atoms in this
            &gt;&gt;&gt; # example are too far apart to be considered bonding

        &#34;&#34;&#34;
        # Use a C subroutine to find bonds.
        if self._bonds is None:
            try:
                self._bonds = asarray(calc_bonds(self.coordinates,
                                                 self.radii(&#39;vis&#39;), 1.1).T, dtype=int)
            except AttributeError:
                return None
        return self._bonds

    @property
    def maxdist(self):
        &#34;&#34;&#34;The maximum distance between two atoms in the nanoparticle

        .. note:: This is a property method, meaning that this is called
                  as though it were an attribute of :class:`DIM`, so
                  no parentheses are used.

        Returns
        -------
        maxdist : :obj:`float`
            The distance

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.natoms
            2
            &gt;&gt;&gt; # Only 2 atoms, so maxdist is the distance between those two
            &gt;&gt;&gt; static.maxdist
            4.0

        &#34;&#34;&#34;
        # Return the maximum distance between atoms in the system.
        if self._minmax is None:
            self._minmax = minmax_pdist(self.coordinates)
        return self._minmax[1]

    @property
    def mindist(self):
        &#34;&#34;&#34;The minimum distance between two atoms in the nanoparticle

        .. note:: This is a property method, meaning that this is called
                  as though it were an attribute of :class:`DIM`, so
                  no parentheses are used.

        Returns
        -------
        mindist : :obj:`float`
            The distance

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.natoms
            2
            &gt;&gt;&gt; # Only 2 atoms, so mindist is the distance between those two
            &gt;&gt;&gt; static.mindist
            4.0

        &#34;&#34;&#34;
        # Return the mimimum distance between atoms in the system.
        if self._minmax is None:
            self._minmax = minmax_pdist(self.coordinates)
        return self._minmax[0]

    @property
    def isotropic(self):
        &#34;&#34;&#34;The isotropic polarizability for each polarizability tensor.

        .. note:: This is a property method, meaning that this is called
                  as though it were an attribute of :class:`DIM`, so
                  no parentheses are used.

        Returns
        -------
        iso : :obj:`numpy.ndarray` of length :attr:`~.npol`
            Isotropic polarizabilities

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.npol
            1
            &gt;&gt;&gt; static.isotropic
            array([ 78.801])
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.npol
            2
            &gt;&gt;&gt; fd.isotropic
            array([ 70.89400000+274.812j, -80.48033333 +85.293j])

        &#34;&#34;&#34;
        return self.tensor_isotropic(self.polarizability)

    @property
    def anisotropic2(self):
        &#34;&#34;&#34;The anisotropic polarizability squared for each
        polarizability tensor.

        .. note:: This is a property method, meaning that this is called
                  as though it were an attribute of :class:`DIM`, so
                  no parentheses are used.

        Returns
        -------
        ani : :obj:`numpy.ndarray` of length :attr:`~.npol`
            Anisotropic polarizabilities squared

        Examples
        --------

            import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; static.npol
            1
            &gt;&gt;&gt; static.anisotropic2
            array([ 503.149761])
            &gt;&gt;&gt; fd = dim.quick_test(fd=True)
            &gt;&gt;&gt; fd.npol
            2
            &gt;&gt;&gt; fd.anisotropic2
            array([ 152906.539536,    1761.492265])

        &#34;&#34;&#34;

        # Calculates the anisotropic polarizability squared
        return self.tensor_anisotropic2(self.polarizability)

    ####################
    # OPERATOR OVERRIDES
    ####################

    def __str__(self):
        &#39;&#39;&#39;Defines what is printed when the class is printed.&#39;&#39;&#39;
        return &#39;DIM object for file {0}&#39;.format(self.filename)

    def __contains__(self, key):
        &#39;&#39;&#39;\
        Boolean for if a field is filled or not.

        Parameters
        ----------
        key : :obj:`str`
            The :class:`DIM` attribute to check

        Returns
        -------
        contains : :obj:`bool`
            :obj:`True` if the field is not empty, :obj:`False` otherwise

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; static = dim.quick_test()
            &gt;&gt;&gt; &#39;efficiencies&#39; in static
            False
            &gt;&gt;&gt; &#39;coordinates&#39; in static
            True

        &#39;&#39;&#39;
        if getattr(self, key, None) is not None:
            try:
                return bool(getattr(self, key, None))
            except ValueError:
                return True
        else:
            return False

    def __add__(self, other):
        &#39;&#39;&#39;\
        Concatenates two nanoparticles together and returns the new molecule.

        The attributes that are concatenated are:

          - :attr:`coordinates`
          - :attr:`atoms`
          - :attr:`natoms`
          - :attr:`elements`
          - :attr:`nelements`

        All other properties would be unphysical to concatenate
        and are emptied.

        Parameters
        ----------
        other : :class:`DIM`
            The other nanoparticle

        Returns
        -------
        new : :class:`DIM`
            The new :class:`DIM` instance with the data
            concatenated together

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; np1 = dim.quick_test()
            &gt;&gt;&gt; np1.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; np2 = dim.quick_test()
            &gt;&gt;&gt; np2.translate_coordinates([3.0, 0.0, 0.0])
            &gt;&gt;&gt; np2.coordinates
            array([[ 3.,  0.,  0.],
                   [ 3.,  0.,  4.]])
            &gt;&gt;&gt; np3 = np1 + np2
            &gt;&gt;&gt; np3.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.],
                   [ 3.,  0.,  0.],
                   [ 3.,  0.,  4.]])
            &gt;&gt;&gt; np3.atoms
            array([&#39;Ag&#39;, &#39;Ag&#39;, &#39;Ag&#39;, &#39;Ag&#39;], 
                  dtype=&#39;|S2&#39;)

        &#39;&#39;&#39;
        from numpy import concatenate
        from dimpy import DIM
        new = DIM(self.filename)
        new.coordinates = concatenate((self.coordinates, other.coordinates))
        new.atoms = concatenate((self.atoms, other.atoms))
        new.elements = self.elements.union(other.elements)
        new.natoms = len(new.atoms)
        new.nelements = len(new.elements)

        return new

    def __iadd__(self, other):
        &#39;&#39;&#39;\
        Alternative syntax to :meth:`~.join`

        Parameters
        ----------
        other : :class:`DIM`
            The other nanoparticle

        Returns
        -------
        new : :class:`DIM`
            The new :class:`DIM` instance with the data
            concatenated together

        Examples
        --------

            &gt;&gt;&gt; import dim
            &gt;&gt;&gt; np1 = dim.quick_test()
            &gt;&gt;&gt; np1.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.]])
            &gt;&gt;&gt; np2 = dim.quick_test()
            &gt;&gt;&gt; np2.translate_coordinates([3.0, 0.0, 0.0])
            &gt;&gt;&gt; np2.coordinates
            array([[ 3.,  0.,  0.],
                   [ 3.,  0.,  4.]])
            &gt;&gt;&gt; np1 += np2
            &gt;&gt;&gt; np1.coordinates
            array([[ 0.,  0.,  0.],
                   [ 0.,  0.,  4.],
                   [ 3.,  0.,  0.],
                   [ 3.,  0.,  4.]])
            &gt;&gt;&gt; np1.atoms
            array([&#39;Ag&#39;, &#39;Ag&#39;, &#39;Ag&#39;, &#39;Ag&#39;], 
                  dtype=&#39;|S2&#39;)
        &#39;&#39;&#39;
        self.join(other)

    #################
    # PRIVATE METHODS
    #################

    def __det_calc_type(self):
        &#39;&#39;&#39;Determine the calculation type based on what is found in the keys&#39;&#39;&#39;
        if &#39;PRINT&#39; in self.key:
            if &#39;ATMDIP&#39; in self.key[&#39;PRINT&#39;]:
                self.subkey.add(&#39;ATMDIP&#39;)
            if &#39;ENERGY&#39; in self.key[&#39;PRINT&#39;]:
                self.subkey.add(&#39;ENERGY&#39;)
        if &#39;NOPRINT&#39; in self.key:
            if &#39;ATMDIP&#39; in self.key[&#39;NOPRINT&#39;]:
                self.subkey.discard(&#39;ATMDIP&#39;)
            if &#39;ENERGY&#39; in self.key[&#39;NOPRINT&#39;]:
                self.subkey.discard(&#39;ENERGY&#39;)
        if &#39;CPIM&#39; in self.key:
            self.subkey.add(&#39;CPIM&#39;)
        elif &#39;PIM&#39; in self.key:
            self.subkey.add(&#39;PIM&#39;)
        if &#39;FREQRANGE&#39; in self.key or &#39;FREQUENCY&#39; in self.key:
            self.calctype = &#39;FD&#39;
        else:
            self.calctype = &#39;STATIC&#39;

    def _raise_or_pass(self, msg):
        &#39;&#39;&#39;Subroutine to pass or raise on collection error.
        Makes termination more specific by adding error message.

        &#39;&#39;&#39;
        if self.termination is None or &#39;ERROR:&#39; not in self.termination:
            self.termination = msg
        if self._abort:
            raise DIMError(msg)
        else:
            pass

    @staticmethod
    def tensor_isotropic(tn):
        return trace(tn, axis1=1, axis2=2) / 3

    @staticmethod
    def tensor_anisotropic2(tn):
        # Calculate anisotripoc polarizability squared using eq.14 from
        # J. Chem. Phys, 75, 5615:
        # \frac{3}{4}\left[\sum_{ij}\alpha_{ij}\alpha_{ij)^\ast
        #                + \sum_{ij}\alpha_{ij}\alpha_{ji)^\ast\right]
        # - \frac{1}{2}\sum_{ij}\alpha_{ii}\alpha_{jj}^\ast

        # It should be noted that there is no complex anisotropic
        # polarizability like there is isotropic polarizability.  This is due
        # to the fact that the anisotropic polarizaibiltiy is instrinsically
        # a magnatude due to the squared factor, and as such must be real.
        cj = tn.conjugate()
        r = range(3)
        t = empty(len(tn), dtype=float)
        for n in xrange(len(tn)):
            cross1 = sum([tn[n, i, j] * cj[n, i, j] for i in r for j in r])
            cross2 = sum([tn[n, i, j] * cj[n, j, i] for i in r for j in r])
            diag = sum([tn[n, i, i] * cj[n, j, j] for i in r for j in r])
            t[n] = absolute((3 / 4) * (cross1 + cross2) - (1 / 2) * diag)
        return t</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="dimpy.dimclass.DIM.tensor_anisotropic2"><code class="name flex">
<span>def <span class="ident">tensor_anisotropic2</span></span>(<span>tn)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def tensor_anisotropic2(tn):
    # Calculate anisotripoc polarizability squared using eq.14 from
    # J. Chem. Phys, 75, 5615:
    # \frac{3}{4}\left[\sum_{ij}\alpha_{ij}\alpha_{ij)^\ast
    #                + \sum_{ij}\alpha_{ij}\alpha_{ji)^\ast\right]
    # - \frac{1}{2}\sum_{ij}\alpha_{ii}\alpha_{jj}^\ast

    # It should be noted that there is no complex anisotropic
    # polarizability like there is isotropic polarizability.  This is due
    # to the fact that the anisotropic polarizaibiltiy is instrinsically
    # a magnatude due to the squared factor, and as such must be real.
    cj = tn.conjugate()
    r = range(3)
    t = empty(len(tn), dtype=float)
    for n in xrange(len(tn)):
        cross1 = sum([tn[n, i, j] * cj[n, i, j] for i in r for j in r])
        cross2 = sum([tn[n, i, j] * cj[n, j, i] for i in r for j in r])
        diag = sum([tn[n, i, i] * cj[n, j, j] for i in r for j in r])
        t[n] = absolute((3 / 4) * (cross1 + cross2) - (1 / 2) * diag)
    return t</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.tensor_isotropic"><code class="name flex">
<span>def <span class="ident">tensor_isotropic</span></span>(<span>tn)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def tensor_isotropic(tn):
    return trace(tn, axis1=1, axis2=2) / 3</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="dimpy.dimclass.DIM.anisotropic2"><code class="name">var <span class="ident">anisotropic2</span></code></dt>
<dd>
<div class="desc"><p>The anisotropic polarizability squared for each
polarizability tensor.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This is a property method, meaning that this is called</p>
<p>as though it were an attribute of :class:<code><a title="dimpy.dimclass.DIM" href="#dimpy.dimclass.DIM">DIM</a></code>, so
no parentheses are used.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>ani</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code>of `length :attr:`~.npol</code></dt>
<dd>Anisotropic polarizabilities squared</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; static.npol
1
&gt;&gt;&gt; static.anisotropic2
array([ 503.149761])
&gt;&gt;&gt; fd = dim.quick_test(fd=True)
&gt;&gt;&gt; fd.npol
2
&gt;&gt;&gt; fd.anisotropic2
array([ 152906.539536,    1761.492265])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def anisotropic2(self):
    &#34;&#34;&#34;The anisotropic polarizability squared for each
    polarizability tensor.

    .. note:: This is a property method, meaning that this is called
              as though it were an attribute of :class:`DIM`, so
              no parentheses are used.

    Returns
    -------
    ani : :obj:`numpy.ndarray` of length :attr:`~.npol`
        Anisotropic polarizabilities squared

    Examples
    --------

        import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; static.npol
        1
        &gt;&gt;&gt; static.anisotropic2
        array([ 503.149761])
        &gt;&gt;&gt; fd = dim.quick_test(fd=True)
        &gt;&gt;&gt; fd.npol
        2
        &gt;&gt;&gt; fd.anisotropic2
        array([ 152906.539536,    1761.492265])

    &#34;&#34;&#34;

    # Calculates the anisotropic polarizability squared
    return self.tensor_anisotropic2(self.polarizability)</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.bonds"><code class="name">var <span class="ident">bonds</span></code></dt>
<dd>
<div class="desc"><p>Returns a list of the bonds in the system</p>
<p>Given that <code>N</code> is the number of bonds, this is an <code>N</code> x 2 numpy
array containing the index of atom 1 and atom 2 of each bond.
Therefore, bond <code>i</code> goes from <code>self.coordinates[self.bonds[i,0]]</code>
to <code>self.coordinates[self.bonds[i,1]]</code></p>
<p>!!! note "Note:&ensp;This is a property method, meaning that this is called"
as though it were an attribute of :class:<code><a title="dimpy.dimclass.DIM" href="#dimpy.dimclass.DIM">DIM</a></code>, so
no parentheses are used.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>bonds</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code> of <code>shape &lt;/code&gt;N&lt;code&gt;</code> x 2</code></dt>
<dd>The array of bonds</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; static.bonds
array([], shape=(0, 2), dtype=int64)
&gt;&gt;&gt; # This is empty because the atoms in this
&gt;&gt;&gt; # example are too far apart to be considered bonding
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def bonds(self):
    &#34;&#34;&#34;Returns a list of the bonds in the system

    Given that ``N`` is the number of bonds, this is an ``N`` x 2 numpy
    array containing the index of atom 1 and atom 2 of each bond.
    Therefore, bond ``i`` goes from ``self.coordinates[self.bonds[i,0]]``
    to ``self.coordinates[self.bonds[i,1]]``

     .. note:: This is a property method, meaning that this is called
              as though it were an attribute of :class:`DIM`, so
              no parentheses are used.

    Returns
    -------
    bonds :  :obj:`numpy.ndarray` of shape ``N`` x 2
        The array of bonds

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; static.bonds
        array([], shape=(0, 2), dtype=int64)
        &gt;&gt;&gt; # This is empty because the atoms in this
        &gt;&gt;&gt; # example are too far apart to be considered bonding

    &#34;&#34;&#34;
    # Use a C subroutine to find bonds.
    if self._bonds is None:
        try:
            self._bonds = asarray(calc_bonds(self.coordinates,
                                             self.radii(&#39;vis&#39;), 1.1).T, dtype=int)
        except AttributeError:
            return None
    return self._bonds</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.isotropic"><code class="name">var <span class="ident">isotropic</span></code></dt>
<dd>
<div class="desc"><p>The isotropic polarizability for each polarizability tensor.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This is a property method, meaning that this is called</p>
<p>as though it were an attribute of :class:<code><a title="dimpy.dimclass.DIM" href="#dimpy.dimclass.DIM">DIM</a></code>, so
no parentheses are used.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>iso</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code>of `length :attr:`~.npol</code></dt>
<dd>Isotropic polarizabilities</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; static.npol
1
&gt;&gt;&gt; static.isotropic
array([ 78.801])
&gt;&gt;&gt; fd = dim.quick_test(fd=True)
&gt;&gt;&gt; fd.npol
2
&gt;&gt;&gt; fd.isotropic
array([ 70.89400000+274.812j, -80.48033333 +85.293j])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def isotropic(self):
    &#34;&#34;&#34;The isotropic polarizability for each polarizability tensor.

    .. note:: This is a property method, meaning that this is called
              as though it were an attribute of :class:`DIM`, so
              no parentheses are used.

    Returns
    -------
    iso : :obj:`numpy.ndarray` of length :attr:`~.npol`
        Isotropic polarizabilities

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; static.npol
        1
        &gt;&gt;&gt; static.isotropic
        array([ 78.801])
        &gt;&gt;&gt; fd = dim.quick_test(fd=True)
        &gt;&gt;&gt; fd.npol
        2
        &gt;&gt;&gt; fd.isotropic
        array([ 70.89400000+274.812j, -80.48033333 +85.293j])

    &#34;&#34;&#34;
    return self.tensor_isotropic(self.polarizability)</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.masses"><code class="name">var <span class="ident">masses</span></code></dt>
<dd>
<div class="desc"><p>The atomic mass of each atom in the nanoparticle</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This is a property method, meaning that this is called</p>
<p>as though it were an attribute of :class:<code><a title="dimpy.dimclass.DIM" href="#dimpy.dimclass.DIM">DIM</a></code>, so
no parentheses are used.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>masses</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code> of `length </code>natoms```</dt>
<dd>The atomic masses in the system</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; static.masses
array([ 106.905093,  106.905093])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def masses(self):
    &#34;&#34;&#34;The atomic mass of each atom in the nanoparticle

    .. note:: This is a property method, meaning that this is called
              as though it were an attribute of :class:`DIM`, so
              no parentheses are used.

    Returns
    -------
    masses : :obj:`numpy.ndarray` of length ``natoms``
        The atomic masses in the system

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; static.masses
        array([ 106.905093,  106.905093])

    &#34;&#34;&#34;
    # Make the atomic mass function broadcastable on a numpy array
    atm_mass = vectorize(atomic_mass)
    # Return the mass for each atom
    return atm_mass(self.atoms)</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.maxdist"><code class="name">var <span class="ident">maxdist</span></code></dt>
<dd>
<div class="desc"><p>The maximum distance between two atoms in the nanoparticle</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This is a property method, meaning that this is called</p>
<p>as though it were an attribute of :class:<code><a title="dimpy.dimclass.DIM" href="#dimpy.dimclass.DIM">DIM</a></code>, so
no parentheses are used.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>maxdist</code></strong> :&ensp;<code>:obj:</code>float``</dt>
<dd>The distance</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; static.natoms
2
&gt;&gt;&gt; # Only 2 atoms, so maxdist is the distance between those two
&gt;&gt;&gt; static.maxdist
4.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def maxdist(self):
    &#34;&#34;&#34;The maximum distance between two atoms in the nanoparticle

    .. note:: This is a property method, meaning that this is called
              as though it were an attribute of :class:`DIM`, so
              no parentheses are used.

    Returns
    -------
    maxdist : :obj:`float`
        The distance

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; static.natoms
        2
        &gt;&gt;&gt; # Only 2 atoms, so maxdist is the distance between those two
        &gt;&gt;&gt; static.maxdist
        4.0

    &#34;&#34;&#34;
    # Return the maximum distance between atoms in the system.
    if self._minmax is None:
        self._minmax = minmax_pdist(self.coordinates)
    return self._minmax[1]</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.mindist"><code class="name">var <span class="ident">mindist</span></code></dt>
<dd>
<div class="desc"><p>The minimum distance between two atoms in the nanoparticle</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This is a property method, meaning that this is called</p>
<p>as though it were an attribute of :class:<code><a title="dimpy.dimclass.DIM" href="#dimpy.dimclass.DIM">DIM</a></code>, so
no parentheses are used.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>mindist</code></strong> :&ensp;<code>:obj:</code>float``</dt>
<dd>The distance</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; static.natoms
2
&gt;&gt;&gt; # Only 2 atoms, so mindist is the distance between those two
&gt;&gt;&gt; static.mindist
4.0
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mindist(self):
    &#34;&#34;&#34;The minimum distance between two atoms in the nanoparticle

    .. note:: This is a property method, meaning that this is called
              as though it were an attribute of :class:`DIM`, so
              no parentheses are used.

    Returns
    -------
    mindist : :obj:`float`
        The distance

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; static.natoms
        2
        &gt;&gt;&gt; # Only 2 atoms, so mindist is the distance between those two
        &gt;&gt;&gt; static.mindist
        4.0

    &#34;&#34;&#34;
    # Return the mimimum distance between atoms in the system.
    if self._minmax is None:
        self._minmax = minmax_pdist(self.coordinates)
    return self._minmax[0]</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.molecular_mass"><code class="name">var <span class="ident">molecular_mass</span></code></dt>
<dd>
<div class="desc"><p>The total mass of the nanoparticle</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This is a property method, meaning that this is called</p>
<p>as though it were an attribute of :class:<code><a title="dimpy.dimclass.DIM" href="#dimpy.dimclass.DIM">DIM</a></code>, so
no parentheses are used.</p>
</div>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>molecular_mass</code></strong> :&ensp;<code>:obj:</code>float``</dt>
<dd>The molecular mass of the nanoparticle</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; round(static.molecular_mass, 6)
213.810186
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def molecular_mass(self):
    &#34;&#34;&#34;The total mass of the nanoparticle

    .. note:: This is a property method, meaning that this is called
              as though it were an attribute of :class:`DIM`, so
              no parentheses are used.

    Returns
    -------
    molecular_mass : :obj:`float`
        The molecular mass of the nanoparticle

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; round(static.molecular_mass, 6)
        213.810186

    &#34;&#34;&#34;
    # Sum masses and return the total molecular mass
    return self.masses.sum()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dimpy.dimclass.DIM.absorb"><code class="name flex">
<span>def <span class="ident">absorb</span></span>(<span>self, other, ignore=set())</span>
</code></dt>
<dd>
<div class="desc"><p>Method to "absorb" all of the data from another
:py:class:<code><a title="dimpy.dimclass.DIM" href="#dimpy.dimclass.DIM">DIM</a></code> instance to the current DIM instance.</p>
<p>Data in <code>other</code> overwrite data in <code>self</code>.
Empty parameters in <code>other</code> will be ignored.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code>:class:</code>DIM``</dt>
<dd>The :class:<code><a title="dimpy.dimclass.DIM" href="#dimpy.dimclass.DIM">DIM</a></code> object to be absorbed.</dd>
<dt><strong><code>ignore</code></strong> :&ensp;<code>:obj:</code>set``</dt>
<dd>Attributes that will <strong>NOT</strong> be absorbed.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; fd = dim.quick_test(fd=True)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def absorb(self, other, ignore=set()):
    &#39;&#39;&#39;\
    Method to &#34;absorb&#34; all of the data from another
    :py:class:`DIM` instance to the current DIM instance.

    Data in `other` overwrite data in `self`.
    Empty parameters in `other` will be ignored.

    Parameters
    ----------
    other : :class:`DIM`
        The :class:`DIM` object to be absorbed.
    ignore : :obj:`set`
        Attributes that will **NOT** be absorbed.

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; fd = dim.quick_test(fd=True)

    &#39;&#39;&#39;
    # Not DIM instance
    if not isinstance(other, DIM):
        raise DIMError(&#39;absorb(): other != DIM()&#39;)
    # Make sure ignore is a set
    ignore = set(ignore)

    # Set of attributes to absorb
    attr = set([&#39;calctype&#39;, &#39;subkey&#39;, &#39;key&#39;, &#39;natoms&#39;, &#39;coordinates&#39;,
                &#39;atoms&#39;, &#39;elements&#39;, &#39;npol&#39;, &#39;e_frequencies&#39;,
                &#39;polarizability&#39;, &#39;efficiencies&#39;, &#39;cross_section&#39;,
                &#39;dipoles&#39;, &#39;charges&#39;, &#39;start&#39;, &#39;real_time&#39;, &#39;cpu_time&#39;,
                &#39;routine_time&#39;, &#39;termination&#39;, &#39;host&#39;, &#39;nprocs&#39;])

    # Run over all attributes on the attribute list (minus the ones
    # in ignore) and copy into this instance.
    # Don&#39;t copy things that are None.
    for k in attr.difference(ignore):
        if k not in other:
            continue
        setattr(self, k, deepcopy(getattr(other, k)))
    if &#39;coordinates&#39; not in ignore:
        self._minmax = None
        self._bonds = None</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.absorbance"><code class="name flex">
<span>def <span class="ident">absorbance</span></span>(<span>self, pathlength, concentration)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the (unitless) absorbance of the system using
Beer's law.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pathlength</code></strong> :&ensp;<code>:obj:</code>float``</dt>
<dd>The pathlength in centimeters of the light</dd>
<dt><strong><code>concentration</code></strong> :&ensp;<code>:obj:</code>float``</dt>
<dd>The solution concentration in molarity</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>absorbance</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code>of `length :attr:`~.npol</code></dt>
<dd>The unitless absorbance for each frequency</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Invalid arguments given</dd>
<dt><code><a title="dimpy.dimclass.DIMError" href="#dimpy.dimclass.DIMError">DIMError</a></code></dt>
<dd>Not an FD calculation</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; fd = dim.quick_test(fd=True)
&gt;&gt;&gt; fd.absorbance(1.5, 1.5e-6)
array([ 0.19074244,  0.06258293])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def absorbance(self, pathlength, concentration):
    &#39;&#39;&#39;\
    Calculates the (unitless) absorbance of the system using
    Beer&#39;s law.

    Parameters
    ----------
    pathlength : :obj:`float`
        The pathlength in centimeters of the light
    concentration : :obj:`float`
        The solution concentration in molarity

    Returns
    -------
    absorbance : :obj:`numpy.ndarray` of length :attr:`~.npol`
        The unitless absorbance for each frequency

    Raises
    ------
    ValueError
        Invalid arguments given
    DIMError
        Not an FD calculation

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; fd = dim.quick_test(fd=True)
        &gt;&gt;&gt; fd.absorbance(1.5, 1.5e-6)
        array([ 0.19074244,  0.06258293])

    &#39;&#39;&#39;
    eps = self.molar_absorptivitty()
    return eps * pathlength * concentration</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.collect"><code class="name flex">
<span>def <span class="ident">collect</span></span>(<span>self, abort=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Read the data from a :class:<code><a title="dimpy.dimclass.DIM" href="#dimpy.dimclass.DIM">DIM</a></code> input or output file</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>abort</code></strong> :&ensp;<code>:obj:</code>bool``</dt>
<dd>If :obj:<code>True</code>, the collector will raise an error when an collection
error is encountered.
If :obj:<code>False</code>, the error will be
ignored and it will continue collection the remainder of the file.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="dimpy.dimclass.DIMError" href="#dimpy.dimclass.DIMError">DIMError</a></code></dt>
<dd>An expected section of the output was missing.
(Other exceptions may also be raised, but are difficult to predict
because of the nature of parsing an open-ended text file.)</dd>
</dl>
<h2 id="examples">Examples</h2>
<p>The :meth:<code>collect()</code> method can collect output files:</p>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; # .collect() is called as the last step of quick_test()
&gt;&gt;&gt; # Example
&gt;&gt;&gt; # run(inputfile, outputfile)
&gt;&gt;&gt; # data = DIM(outputfile)
&gt;&gt;&gt; # data.collect()
&gt;&gt;&gt;
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; static.coordinates
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  4.]])
&gt;&gt;&gt; static.atoms # doctest: +NORMALIZE_WHITESPACE
array(['Ag', 'Ag'], dtype='|S2')
&gt;&gt;&gt; static.natoms
2
&gt;&gt;&gt; static.elements
set(['Ag'])
&gt;&gt;&gt; static.nelements
1
&gt;&gt;&gt; static.key['XYZ']
('Ag 0.0 0.0 0.0', 'Ag 0.0 0.0 4.0')
</code></pre>
<p>Note that the results of a static and frequency-dependent calculation will be
in a slightly different format.</p>
<pre><code>&gt;&gt;&gt; static.npol
1
&gt;&gt;&gt; static.e_frequencies
array([ 0.])
&gt;&gt;&gt; static.polarizability
array([[[ 71.324,   0.   ,   0.   ],
        [  0.   ,  71.324,   0.   ],
        [  0.   ,   0.   ,  93.755]]])
&gt;&gt;&gt; static.efficiencies
&gt;&gt;&gt; static.cross_sections
&gt;&gt;&gt; fd = dim.quick_test(fd=True)
&gt;&gt;&gt; fd.npol
2
&gt;&gt;&gt; fd.e_frequencies
array([ 0.128623,  0.135972])
&gt;&gt;&gt; fd.polarizability
array([[[ 200.794+264.06j ,    0.000  +0.j   ,    0.000  +0.j   ],
        [   0.000  +0.j   ,  200.794+264.06j ,    0.000  +0.j   ],
        [   0.000  +0.j   ,    0.000  +0.j   , -188.906+296.316j]],
&lt;BLANKLINE&gt;
       [[ -81.283 +99.26j ,    0.000  +0.j   ,    0.000  +0.j   ],
        [   0.000  +0.j   ,  -81.283 +99.26j ,    0.000  +0.j   ],
        [   0.000  +0.j   ,    0.000  +0.j   ,  -78.875 +57.359j]]])
&gt;&gt;&gt; # The following are only collected for FD
&gt;&gt;&gt; # and if 'PRINT EFF' was included in input file
&gt;&gt;&gt; fd.efficiencies
array([  8.09150000e-02,   1.84020000e-12])
&gt;&gt;&gt; fd.cross_sections
array([  7.22310000e-04,   1.64260000e-14])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def collect(self, abort=False):
    &#39;&#39;&#39;\
    Read the data from a :class:`DIM` input or output file

    Parameters
    ----------
    abort : :obj:`bool`
        If :obj:`True`, the collector will raise an error when an collection
        error is encountered.  If :obj:`False`, the error will be
        ignored and it will continue collection the remainder of the file.

    Raises
    ------
    DIMError
        An expected section of the output was missing.
        (Other exceptions may also be raised, but are difficult to predict
        because of the nature of parsing an open-ended text file.)

    Examples
    --------
    The :meth:`collect()` method can collect output files:

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; # .collect() is called as the last step of quick_test()
        &gt;&gt;&gt; # Example
        &gt;&gt;&gt; # run(inputfile, outputfile)
        &gt;&gt;&gt; # data = DIM(outputfile)
        &gt;&gt;&gt; # data.collect()
        &gt;&gt;&gt;
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; static.coordinates
        array([[ 0.,  0.,  0.],
               [ 0.,  0.,  4.]])
        &gt;&gt;&gt; static.atoms # doctest: +NORMALIZE_WHITESPACE
        array([&#39;Ag&#39;, &#39;Ag&#39;], dtype=&#39;|S2&#39;)
        &gt;&gt;&gt; static.natoms
        2
        &gt;&gt;&gt; static.elements
        set([&#39;Ag&#39;])
        &gt;&gt;&gt; static.nelements
        1
        &gt;&gt;&gt; static.key[&#39;XYZ&#39;]
        (&#39;Ag 0.0 0.0 0.0&#39;, &#39;Ag 0.0 0.0 4.0&#39;)

    Note that the results of a static and frequency-dependent calculation will be
    in a slightly different format.

        &gt;&gt;&gt; static.npol
        1
        &gt;&gt;&gt; static.e_frequencies
        array([ 0.])
        &gt;&gt;&gt; static.polarizability
        array([[[ 71.324,   0.   ,   0.   ],
                [  0.   ,  71.324,   0.   ],
                [  0.   ,   0.   ,  93.755]]])
        &gt;&gt;&gt; static.efficiencies
        &gt;&gt;&gt; static.cross_sections
        &gt;&gt;&gt; fd = dim.quick_test(fd=True)
        &gt;&gt;&gt; fd.npol
        2
        &gt;&gt;&gt; fd.e_frequencies
        array([ 0.128623,  0.135972])
        &gt;&gt;&gt; fd.polarizability
        array([[[ 200.794+264.06j ,    0.000  +0.j   ,    0.000  +0.j   ],
                [   0.000  +0.j   ,  200.794+264.06j ,    0.000  +0.j   ],
                [   0.000  +0.j   ,    0.000  +0.j   , -188.906+296.316j]],
        &lt;BLANKLINE&gt;
               [[ -81.283 +99.26j ,    0.000  +0.j   ,    0.000  +0.j   ],
                [   0.000  +0.j   ,  -81.283 +99.26j ,    0.000  +0.j   ],
                [   0.000  +0.j   ,    0.000  +0.j   ,  -78.875 +57.359j]]])
        &gt;&gt;&gt; # The following are only collected for FD
        &gt;&gt;&gt; # and if &#39;PRINT EFF&#39; was included in input file
        &gt;&gt;&gt; fd.efficiencies
        array([  8.09150000e-02,   1.84020000e-12])
        &gt;&gt;&gt; fd.cross_sections
        array([  7.22310000e-04,   1.64260000e-14])

    &#39;&#39;&#39;

    # Collect from file
    try:
        # Set the abort flag
        self._abort = abort
        # Read in file
        from .read_file import read_file
        f, indices = read_file(self)
        # Read input block
        from .input_block import collect_input
        collect_input(self, f, indices)
        # Determine calculation type
        self.__det_calc_type()
        # Techical properties
        from .dimproperties import collect_technical
        collect_technical(self, f, indices)
        # Collect all exciting information
        from .dimproperties import collect_dim
        collect_dim(self, f, indices)
        # Collect timing
        from .dimproperties import collect_timing
        collect_timing(self, f, indices)
    # If a known error occured
    except DIMError as d:
        if abort:
            raise DIMError(str(d) + &#39;: &#39; + self.filename)
    # If a known unknown error occured.
    except (IndexError, StopIteration, KeyError):
        msg = &#39;Did the calculation end prematurely?&#39;
        if abort:
            print(&#39;/\\&#39;*int(len(msg)/2), file=sys.stderr)
            print(msg, file=sys.stderr)
            print(&#39;/\\&#39;*int(len(msg)/2), file=sys.stderr)
            print(file=sys.stderr)
            raise
    except ValueError:
        msg = &#39;Possibly a number too large for the format (********)\n&#39;
        msg += &#39;or a string and number running together (WORD1.785)&#39;
        if abort:
            print(&#39;/\\&#39;*27, file=sys.stderr)
            print(msg, file=sys.stderr)
            print(&#39;/\\&#39;*27, file=sys.stderr)
            print(file=sys.stderr)
            raise</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a copy of the current instance.
Equivalent to :obj:<code>copy.deepcopy</code> (self).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>copy</code></strong> :&ensp;<code>:class:</code>DIM``</dt>
<dd>A copy of the current :class:<code><a title="dimpy.dimclass.DIM" href="#dimpy.dimclass.DIM">DIM</a></code> instance.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; example1 = static
&gt;&gt;&gt; example1 is static
True
&gt;&gt;&gt; example2 = static.copy()
&gt;&gt;&gt; example2 is static
False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#39;&#39;&#39;\
    Returns a copy of the current instance.
    Equivalent to :obj:`copy.deepcopy` (self).

    Returns
    -------
    copy : :class:`DIM`
        A copy of the current :class:`DIM` instance.

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; example1 = static
        &gt;&gt;&gt; example1 is static
        True
        &gt;&gt;&gt; example2 = static.copy()
        &gt;&gt;&gt; example2 is static
        False

    &#39;&#39;&#39;
    return deepcopy(self)</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.cross_section"><code class="name flex">
<span>def <span class="ident">cross_section</span></span>(<span>self, unit='angstroms')</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the absorption cross-section of the system.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'angstroms', 'nm', 'bohr', 'cm', 'm'}</code></dt>
<dd>The unit in which the cross section will be returned<pre><code>- 'angstroms' -&gt; angstroms^2/molecule
- 'nm' -&gt; nm^2/molecule
- 'bohr' -&gt; bohr^2/molecule
- 'cm' -&gt; cm^2/molecule
- 'm' -&gt; m^2/molecule
</code></pre>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>cross_section</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code>of `length :attr:`~.npol</code></dt>
<dd>The absorption cross section for each frequency</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Invalid arguments given</dd>
<dt><code><a title="dimpy.dimclass.DIMError" href="#dimpy.dimclass.DIMError">DIMError</a></code></dt>
<dd>Not an FD calculation</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; fd = dim.quick_test(fd=True)
&gt;&gt;&gt; fd.cross_section()
array([ 3.24137681,  1.06350141])
&gt;&gt;&gt; fd.cross_section(unit='nm')
array([ 0.03241377,  0.01063501])
&gt;&gt;&gt; fd.cross_section(unit='cm')
array([  3.24137681e-16,   1.06350141e-16])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cross_section(self, unit=&#39;angstroms&#39;):
    &#39;&#39;&#39;Returns the absorption cross-section of the system.

    Parameters
    ----------
    unit : {&#39;angstroms&#39;, &#39;nm&#39;, &#39;bohr&#39;, &#39;cm&#39;, &#39;m&#39;}
        The unit in which the cross section will be returned

            - &#39;angstroms&#39; -&gt; angstroms^2/molecule
            - &#39;nm&#39; -&gt; nm^2/molecule
            - &#39;bohr&#39; -&gt; bohr^2/molecule
            - &#39;cm&#39; -&gt; cm^2/molecule
            - &#39;m&#39; -&gt; m^2/molecule

    Returns
    -------
    cross_section : :obj:`numpy.ndarray` of length :attr:`~.npol`
        The absorption cross section for each frequency

    Raises
    ------
    ValueError
        Invalid arguments given
    DIMError
        Not an FD calculation

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; fd = dim.quick_test(fd=True)
        &gt;&gt;&gt; fd.cross_section()
        array([ 3.24137681,  1.06350141])
        &gt;&gt;&gt; fd.cross_section(unit=&#39;nm&#39;)
        array([ 0.03241377,  0.01063501])
        &gt;&gt;&gt; fd.cross_section(unit=&#39;cm&#39;)
        array([  3.24137681e-16,   1.06350141e-16])

    &#39;&#39;&#39;

    # Assign the correct unit converter
    if unit.lower() == &#39;angstroms&#39;:
        conv = NOCONV
    elif unit.lower() == &#39;bohr&#39;:
        conv = ANGSTROM2BOHR
    elif unit.lower() == &#39;nm&#39;:
        conv = ANGSTROM2NM
    elif unit.lower() == &#39;cm&#39;:
        conv = ANGSTROM2CM
    elif unit.lower() == &#39;m&#39;:
        conv = ANGSTROM2M
    else:
        raise ValueError(&#39;cross_section(): Invalid unit (&#39;+unit.lower()+&#39;)&#39;)

    if self.calctype == &#39;FD&#39;:
        iso = self.isotropic.imag
        # Conversion is performed twice because the property is squared
        return conv(conv((4 * PI * self.e_frequencies / LIGHT_AU) * iso))
    else:
        raise DIMError(&#39;cross_section(): Not a FD calculation&#39;)</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.empty"><code class="name flex">
<span>def <span class="ident">empty</span></span>(<span>self, ignore=set())</span>
</code></dt>
<dd>
<div class="desc"><p>Empties all attributes in the current :class:<code><a title="dimpy.dimclass.DIM" href="#dimpy.dimclass.DIM">DIM</a></code> instance
except those on the ignore list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ignore</code></strong> :&ensp;<code>:obj:</code>set``</dt>
<dd>A set of attributes to <strong>NOT</strong> empty</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; fd = dim.quick_test(fd=True)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def empty(self, ignore=set()):
    &#39;&#39;&#39;\
    Empties all attributes in the current :class:`DIM` instance
    except those on the ignore list.

    Parameters
    ----------
    ignore : :obj:`set`
        A set of attributes to **NOT** empty

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; fd = dim.quick_test(fd=True)

    &#39;&#39;&#39;
    # Make sure ignore is a set
    ignore = set(ignore)

    # Set of attributes to empty
    attr = set([&#39;calctype&#39;, &#39;subkey&#39;, &#39;key&#39;, &#39;natoms&#39;, &#39;coordinates&#39;,
                &#39;atoms&#39;, &#39;elements&#39;, &#39;npol&#39;, &#39;e_frequencies&#39;,
                &#39;polarizability&#39;, &#39;efficiencies&#39;, &#39;cross_section&#39;,
                &#39;dipoles&#39;, &#39;charges&#39;, &#39;start&#39;, &#39;real_time&#39;, &#39;cpu_time&#39;,
                &#39;routine_time&#39;, &#39;termination&#39;, &#39;host&#39;, &#39;nprocs&#39;])

    # Run over all attributes and empty them, except for the ones
    # in ignore.
    for k in attr.difference(ignore):
        if k in (&#39;calctype&#39;, &#39;subkey&#39;):
            setattr(self, k, set())
        elif k == &#39;key&#39;:
            setattr(self, k, {})
        else:
            setattr(self, k, None)
    if &#39;coordinates&#39; not in ignore:
        self._minmax = None
        self._bonds = None</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.find_center"><code class="name flex">
<span>def <span class="ident">find_center</span></span>(<span>self, type='geometrical')</span>
</code></dt>
<dd>
<div class="desc"><p>Locates the center of the nanoparticle.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>{'geometrical', 'center-of-mass'}</code></dt>
<dd>The type of the center-of-mass to locate</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>center</code></strong> :&ensp;<code>:obj:</code>float``</dt>
<dd>The center-of-mass of the nanoparticle</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>An invalid type is given.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; static.coordinates
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  4.]])
&gt;&gt;&gt; static.find_center()
array([ 0.,  0.,  2.])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_center(self, type=&#39;geometrical&#39;):
    &#39;&#39;&#39;Locates the center of the nanoparticle.

    Parameters
    ----------
    type : {&#39;geometrical&#39;, &#39;center-of-mass&#39;}
        The type of the center-of-mass to locate

    Returns
    -------
    center : :obj:`float`
        The center-of-mass of the nanoparticle

    Raises
    -------
    ValueError
        An invalid type is given.

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; static.coordinates
        array([[ 0.,  0.,  0.],
               [ 0.,  0.,  4.]])
        &gt;&gt;&gt; static.find_center()
        array([ 0.,  0.,  2.])

    &#39;&#39;&#39;

    if type == &#39;center-of-mass&#39;:
        wt = self.masses
    elif type == &#39;geometrical&#39;:
        wt = None
    else:
        raise ValueError(&#39;find_center(): Invalid type: &#39;+type)

    # Now find the center of mass
    return average(self.coordinates, axis=0, weights=wt)</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.join"><code class="name flex">
<span>def <span class="ident">join</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Concatenates one molecule into the current one.</p>
<p>The attributes that are concatenated are:</p>
<ul>
<li>:attr:<code>~.coordinates</code></li>
<li>:attr:<code>~.atoms</code></li>
<li><code>natoms</code></li>
<li>:attr:<code>~.elements</code></li>
<li>:attr:<code>~.nelements</code></li>
</ul>
<p>All other properties would be unphysical to concatenate
and are emptied.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>other</code></strong> :&ensp;<code>:class:</code>DIM``</dt>
<dd>The other :class:<code><a title="dimpy.dimclass.DIM" href="#dimpy.dimclass.DIM">DIM</a></code> object to concatenate with this one</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; np1 = dim.quick_test()
&gt;&gt;&gt; np1.coordinates
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  4.]])
&gt;&gt;&gt; np2 = dim.quick_test()
&gt;&gt;&gt; np2.translate_coordinates([3.0, 0.0, 0.0])
&gt;&gt;&gt; np2.coordinates
array([[ 3.,  0.,  0.],
       [ 3.,  0.,  4.]])
&gt;&gt;&gt; np1.join(np2)
&gt;&gt;&gt; np1.coordinates
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  4.],
       [ 3.,  0.,  0.],
       [ 3.,  0.,  4.]])
&gt;&gt;&gt; np1.atoms
array(['Ag', 'Ag', 'Ag', 'Ag'], 
      dtype='|S2')
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def join(self, other):
    &#39;&#39;&#39;Concatenates one molecule into the current one.

    The attributes that are concatenated are:

      - :attr:`~.coordinates`
      - :attr:`~.atoms`
      - ``natoms``
      - :attr:`~.elements`
      - :attr:`~.nelements`

    All other properties would be unphysical to concatenate
    and are emptied.

    Parameters
    ----------
    other : :class:`DIM`
        The other :class:`DIM` object to concatenate with this one

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; np1 = dim.quick_test()
        &gt;&gt;&gt; np1.coordinates
        array([[ 0.,  0.,  0.],
               [ 0.,  0.,  4.]])
        &gt;&gt;&gt; np2 = dim.quick_test()
        &gt;&gt;&gt; np2.translate_coordinates([3.0, 0.0, 0.0])
        &gt;&gt;&gt; np2.coordinates
        array([[ 3.,  0.,  0.],
               [ 3.,  0.,  4.]])
        &gt;&gt;&gt; np1.join(np2)
        &gt;&gt;&gt; np1.coordinates
        array([[ 0.,  0.,  0.],
               [ 0.,  0.,  4.],
               [ 3.,  0.,  0.],
               [ 3.,  0.,  4.]])
        &gt;&gt;&gt; np1.atoms
        array([&#39;Ag&#39;, &#39;Ag&#39;, &#39;Ag&#39;, &#39;Ag&#39;], 
              dtype=&#39;|S2&#39;)

    &#39;&#39;&#39;
    self.coordinates = concatenate((self.coordinates, other.coordinates))
    self.atoms = concatenate((self.atoms, other.atoms))
    self.natoms = len(self.atoms)
    self.elements.update(other.elements)
    self.nelements = len(self.elements)
    self.empty(ignore=[&#39;coordinates&#39;, &#39;atoms&#39;, &#39;natoms&#39;,
                       &#39;elements&#39;, &#39;nelements&#39;])
    self._bonds = None
    self._minmax = None</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.molar_absorptivitty"><code class="name flex">
<span>def <span class="ident">molar_absorptivitty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the molar absorptivitty of the system in units of
L mol^{-1} cm^{-1} or M^{-1} cm^{-1} (these are equivalent).</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>molar_absorptivitty</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code>of `length :attr:`~.npol</code></dt>
<dd>The molar absorptivitty for each frequency in</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Invalid arguments given</dd>
<dt><code><a title="dimpy.dimclass.DIMError" href="#dimpy.dimclass.DIMError">DIMError</a></code></dt>
<dd>Not an FD calculation</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; fd = dim.quick_test(fd=True)
&gt;&gt;&gt; fd.molar_absorptivitty()
array([ 84774.41649881,  27814.63448711])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def molar_absorptivitty(self):
    &#39;&#39;&#39;Calculates the molar absorptivitty of the system in units of
    L mol^{-1} cm^{-1} or M^{-1} cm^{-1} (these are equivalent).

    Returns
    -------
    molar_absorptivitty : :obj:`numpy.ndarray` of length :attr:`~.npol`
        The molar absorptivitty for each frequency in

    Raises
    ------
    ValueError
        Invalid arguments given
    DIMError
        Not an FD calculation

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; fd = dim.quick_test(fd=True)
        &gt;&gt;&gt; fd.molar_absorptivitty()
        array([ 84774.41649881,  27814.63448711])

    &#39;&#39;&#39;
    from math import log as ln

    # Conversion factor to get from angstroms^2 to L/cm.
    # L == dm^3
    # dm^2 == 1E18 angstroms^2
    # dm^2 == 0.1 dm^3/cm
    # 0.1 dm^3/cm = 1E18 angstroms^2
    # 1E-19 = dm^3/(cm*angstroms^2)
    CONVFACTOR = 1E-19

    # Get the absorption cross-section in angstroms^2/molecule
    acs = self.cross_section()
    # Use this to calculate the molar absorptivity
    # LN(10) accounts for Beer&#39;s law
    return AVOGADRO * CONVFACTOR * acs / ln(10)</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.order_coords"><code class="name flex">
<span>def <span class="ident">order_coords</span></span>(<span>self, atom=None, coord=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Reorders the coordinates according to proximity to either
a specific atom or a point in space.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>atom</code></strong> :&ensp;<code>:obj:</code>int``</dt>
<dd>The atom to reorder by.</dd>
<dt><strong><code>coord</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code><code>of &lt;/code&gt;length 3</code></dt>
<dd>The point in space to reorder with respect to.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>One and only one of <code>atom</code> and <code>coord</code> is not given.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; np1 = dim.quick_test()
&gt;&gt;&gt; np1.coordinates
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  4.]])
&gt;&gt;&gt; np1.order_coords(coord=[0.0, 0.0, 5.0])
&gt;&gt;&gt; np1.coordinates
array([[ 0.,  0.,  4.],
       [ 0.,  0.,  0.]])
&gt;&gt;&gt; np2 = dim.quick_test()
&gt;&gt;&gt; np2.coordinates
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  4.]])
&gt;&gt;&gt; np2.order_coords(atom=2)
&gt;&gt;&gt; np2.coordinates
array([[ 0.,  0.,  4.],
       [ 0.,  0.,  0.]])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def order_coords(self, atom=None, coord=None):
    &#39;&#39;&#39;\
    Reorders the coordinates according to proximity to either
    a specific atom or a point in space.

    Parameters
    ----------
    atom : :obj:`int`
        The atom to reorder by.
    coord : :obj:`numpy.ndarray` of length 3
        The point in space to reorder with respect to.

    Raises
    ------
    ValueError
        One and only one of `atom` and `coord` is not given.

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; np1 = dim.quick_test()
        &gt;&gt;&gt; np1.coordinates
        array([[ 0.,  0.,  0.],
               [ 0.,  0.,  4.]])
        &gt;&gt;&gt; np1.order_coords(coord=[0.0, 0.0, 5.0])
        &gt;&gt;&gt; np1.coordinates
        array([[ 0.,  0.,  4.],
               [ 0.,  0.,  0.]])
        &gt;&gt;&gt; np2 = dim.quick_test()
        &gt;&gt;&gt; np2.coordinates
        array([[ 0.,  0.,  0.],
               [ 0.,  0.,  4.]])
        &gt;&gt;&gt; np2.order_coords(atom=2)
        &gt;&gt;&gt; np2.coordinates
        array([[ 0.,  0.,  4.],
               [ 0.,  0.,  0.]])

    &#39;&#39;&#39;

    if atom is None and coord is None:
        raise ValueError(&#39;order_coords(): Must choose one of atoms or coords.&#39;)
    if atom and coord:
        raise ValueError(&#39;order_coords(): Cannot use both atoms and coords.&#39;)

    # First determine the distance from the points
    if atom is not None:
        c = self.coordinates[atom-1]
    else:
        c = coord

    # Sort the distances and return the sorted indices.
    index = argsort(npsqrt(sum((c - self.coordinates)**2, axis=1)))
    # Sort atoms coodinates and modes.
    self.atoms = self.atoms[index]
    self.coordinates = self.coordinates[index]
    self._bonds = None</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.pol_diagonalize"><code class="name flex">
<span>def <span class="ident">pol_diagonalize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Diagonalizes the polarizability tensors in place.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>rotmat</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code><code>of &lt;/code&gt;shape :attr:</code>~.npol<code>x 3 x 3</code></dt>
<dd>Rotation matrix after diagonalization</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="dimpy.dimclass.DIMError" href="#dimpy.dimclass.DIMError">DIMError</a></code></dt>
<dd>Diagonalization does not converge</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; static.polarizability
array([[[ 71.324,   0.   ,   0.   ],
        [  0.   ,  71.324,   0.   ],
        [  0.   ,   0.   ,  93.755]]])
&gt;&gt;&gt; static.pol_diagonalize()
array([[[ 1.,  0.,  0.],
        [ 0.,  1.,  0.],
        [ 0.,  0.,  1.]]])
&gt;&gt;&gt; static.polarizability
array([[[ 71.324,   0.   ,   0.   ],
        [  0.   ,  71.324,   0.   ],
        [  0.   ,   0.   ,  93.755]]])
&gt;&gt;&gt; # Note: This example shows no difference  before and
&gt;&gt;&gt; # after diagonalization because the tensor was already
&gt;&gt;&gt; # diagonalized because the nanoparticle is linear on the
&gt;&gt;&gt; # z-axis.
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pol_diagonalize(self):
    &#39;&#39;&#39;Diagonalizes the polarizability tensors in place.

    Returns
    -------
    rotmat : :obj:`numpy.ndarray` of shape :attr:`~.npol` x 3 x 3
        Rotation matrix after diagonalization

    Raises
    ------
    DIMError
        Diagonalization does not converge

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; static.polarizability
        array([[[ 71.324,   0.   ,   0.   ],
                [  0.   ,  71.324,   0.   ],
                [  0.   ,   0.   ,  93.755]]])
        &gt;&gt;&gt; static.pol_diagonalize()
        array([[[ 1.,  0.,  0.],
                [ 0.,  1.,  0.],
                [ 0.,  0.,  1.]]])
        &gt;&gt;&gt; static.polarizability
        array([[[ 71.324,   0.   ,   0.   ],
                [  0.   ,  71.324,   0.   ],
                [  0.   ,   0.   ,  93.755]]])
        &gt;&gt;&gt; # Note: This example shows no difference  before and
        &gt;&gt;&gt; # after diagonalization because the tensor was already
        &gt;&gt;&gt; # diagonalized because the nanoparticle is linear on the
        &gt;&gt;&gt; # z-axis.

    &#39;&#39;&#39;

    # Find the eigenvector and eigenvalues of the tensor
    # The eigenvector is the diagonal of the tensor, and the
    # eigenvalues are the rotation matrix.
    rotation = zeros_like(self.polarizability)

    for n in range(self.npol):
        try:
            eigenvec, eigenval = eig(self.polarizability[n])
        except LinAlgError:
            raise DIMError(&#39;Diagonalization of polarizability &#39;
                           &#39;tensor does not converge&#39;)
        else:
            self.polarizability[n] = diagflat(eigenvec)
            rotation[n] = eigenval

    # Remember the state
    self._diagonalized = True

    return rotation</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.pol_minmax"><code class="name flex">
<span>def <span class="ident">pol_minmax</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the minimum and maximum isotropic polarizabilities</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>pol_min</code></strong> :&ensp;<code>:obj:</code>float``</dt>
<dd>Minimum isotropic polarizability</dd>
<dt><strong><code>pol_max</code></strong> :&ensp;<code>:obj:</code>float``</dt>
<dd>Maximum isotropic polarizability</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; fd = dim.quick_test(fd=True)
&gt;&gt;&gt; minmax = fd.pol_minmax()
&gt;&gt;&gt; fd.isotropic
array([ 70.89400000+274.812j, -80.48033333 +85.293j])
&gt;&gt;&gt; round(minmax[0].real, 4)
-80.4803
&gt;&gt;&gt; round(minmax[0].imag, 4)
85.293
&gt;&gt;&gt; round(minmax[1].real, 4)
70.894
&gt;&gt;&gt; round(minmax[1].imag, 4)
274.812
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pol_minmax(self):
    &#39;&#39;&#39;\
    Finds the minimum and maximum isotropic polarizabilities

    Returns
    -------
    pol_min : :obj:`float`
        Minimum isotropic polarizability
    pol_max : :obj:`float`
        Maximum isotropic polarizability

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; fd = dim.quick_test(fd=True)
        &gt;&gt;&gt; minmax = fd.pol_minmax()
        &gt;&gt;&gt; fd.isotropic
        array([ 70.89400000+274.812j, -80.48033333 +85.293j])
        &gt;&gt;&gt; round(minmax[0].real, 4)
        -80.4803
        &gt;&gt;&gt; round(minmax[0].imag, 4)
        85.293
        &gt;&gt;&gt; round(minmax[1].real, 4)
        70.894
        &gt;&gt;&gt; round(minmax[1].imag, 4)
        274.812

    &#39;&#39;&#39;
    return (self.isotropic.min(),
            self.isotropic.max())</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.printCoords"><code class="name flex">
<span>def <span class="ident">printCoords</span></span>(<span>self, mode=None, a1=1, a2=None, file=None, latex=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Prints the geometry coordinates to screen.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code>{'xyz', 'xyz_title', 'num', 'dimblock'}</code></dt>
<dd>
<p>Determines how the coordinates will be printed.
If
omitted, the coordinates will be printed without numbers.</p>
<p>Valid options are:</p>
<pre><code>- 'num':       Prints the number of each atom with the element.
- 'xyz':       Prints the total number of atoms, then a space, then the coordinates.
- 'xyz_title': Same as 'xyz', but prints the title instead of a space, if a title is available.
- 'dimblock':  Same as 'xyz', but omits the space altogether.
</code></pre>
</dd>
<dt><strong><code>a1</code></strong> :&ensp;<code>:obj:</code>int``</dt>
<dd>The number of the lowest atom to print</dd>
<dt><strong><code>a2</code></strong> :&ensp;<code>:obj:</code>int<code>, :obj:</code>None``</dt>
<dd>The number of the highest atom to print.
If given :obj:<code>None</code>, the number of the last atom is used</dd>
<dt><strong><code>file</code></strong> :&ensp;<code>:obj:</code>str<code>, :obj:</code>file``</dt>
<dd>Where to print to.
If omitted, it will print to standard
output.
You may give the name of a file or an already open
:obj:<code>file</code> object to write to. Or, if <code>file</code> is 'xyz', then
it will create a <code>.xyz</code> file based on the :attr:<code>filename</code>
attribute and print there.</dd>
<dt><strong><code>latex</code></strong> :&ensp;<code>:obj:</code>bool``</dt>
<dd>Causes the output to be printed in a LaTeX table type of format.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>An invalid mode is entered</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; static.printCoords()
Ag    0.00000000    0.00000000    0.00000000
Ag    0.00000000    0.00000000    4.00000000
&gt;&gt;&gt; static.printCoords(mode='num')
1 Ag    0.00000000    0.00000000    0.00000000
2 Ag    0.00000000    0.00000000    4.00000000
&gt;&gt;&gt; static.printCoords(mode='xyz')
2
&lt;BLANKLINE&gt;
Ag    0.00000000    0.00000000    0.00000000
Ag    0.00000000    0.00000000    4.00000000
&gt;&gt;&gt; static.printCoords(latex=True)
 Ag   &amp;    0.000000 &amp;    0.000000 &amp;    0.000000\\
 \hline
 Ag   &amp;    0.000000 &amp;    0.000000 &amp;    4.000000\\
 \hline
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printCoords(self, mode=None, a1=1, a2=None, file=None, latex=False):
    &#39;&#39;&#39;Prints the geometry coordinates to screen.

    Parameters
    ----------
    mode : {&#39;xyz&#39;, &#39;xyz_title&#39;, &#39;num&#39;, &#39;dimblock&#39;}
        Determines how the coordinates will be printed.  If
        omitted, the coordinates will be printed without numbers.

        Valid options are:

            - &#39;num&#39;:       Prints the number of each atom with the element.
            - &#39;xyz&#39;:       Prints the total number of atoms, then a space, then the coordinates.
            - &#39;xyz_title&#39;: Same as &#39;xyz&#39;, but prints the title instead of a space, if a title is available.
            - &#39;dimblock&#39;:  Same as &#39;xyz&#39;, but omits the space altogether.

    a1 : :obj:`int`
        The number of the lowest atom to print
    a2 : :obj:`int`, :obj:`None`
        The number of the highest atom to print.
        If given :obj:`None`, the number of the last atom is used
    file : :obj:`str`, :obj:`file`
        Where to print to.  If omitted, it will print to standard
        output.  You may give the name of a file or an already open
        :obj:`file` object to write to. Or, if `file` is &#39;xyz&#39;, then
        it will create a ``.xyz`` file based on the :attr:`filename`
        attribute and print there.
    latex : :obj:`bool`
        Causes the output to be printed in a LaTeX table type of format.

    Raises
    ------
    ValueError
        An invalid mode is entered

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; static.printCoords()
        Ag    0.00000000    0.00000000    0.00000000
        Ag    0.00000000    0.00000000    4.00000000
        &gt;&gt;&gt; static.printCoords(mode=&#39;num&#39;)
        1 Ag    0.00000000    0.00000000    0.00000000
        2 Ag    0.00000000    0.00000000    4.00000000
        &gt;&gt;&gt; static.printCoords(mode=&#39;xyz&#39;)
        2
        &lt;BLANKLINE&gt;
        Ag    0.00000000    0.00000000    0.00000000
        Ag    0.00000000    0.00000000    4.00000000
        &gt;&gt;&gt; static.printCoords(latex=True)
         Ag   &amp;    0.000000 &amp;    0.000000 &amp;    0.000000\\\\
         \\hline
         Ag   &amp;    0.000000 &amp;    0.000000 &amp;    4.000000\\\\
         \\hline

    &#39;&#39;&#39;
    valid_modes = (&#39;xyz&#39;, &#39;xyz_title&#39;, &#39;num&#39;, &#39;dimblock&#39;)
    if mode is not None and (mode not in valid_modes):
        raise ValueError(&#39;printCoords(): Invalid mode: &#39;+mode)

    # Create an xyz file if file is True
    if file == &#39;xyz&#39;:
        # Split current extention off filename, then replace with .xyz
        file = &#39;.&#39;.join([os.path.splitext(self.filename)[0], &#39;xyz&#39;])
        # Open, and remember we need to close after
        file = open(file, &#39;w&#39;)
        closebool = True
    # If file is None, use standard out
    elif file is None:
        file = sys.stdout
        closebool = False
    # Otherwise, try to open the file
    else:
        try:
            file = open(file, &#39;w&#39;)
        # If it fails, then it was already an open file
        except TypeError:
            closebool = False
        # If it suceeds, then remmeber that we must close the file
        else:
            closebool = True

    # Convert atom number to index
    a1 -= 1
    # Default to all.
    if a2 is None:
        a2 = len(self.atoms)

    # Determine how to format the line, and make numbers correct
    if mode == &#39;num&#39;:
        # Find string length of largest number to be printed and make that
        # number a string
        maxlen = str(len(str((a2 - a1) + 1)))
        fmt = &#39;{0:&lt;&#39;+maxlen+&#39;} {1:&lt;2}{2[0]:14.8f}{2[1]:14.8f}{2[2]:14.8f}&#39;
        num = 1
    else:
        if latex:
            fmt = &#39;{0:&gt;3}{2:&gt;4}{1[0]:12.6f}{2:&gt;2}{1[1]:12.6f}{2:&gt;2}{1[2]:12.6f}{3:&lt;2}&#39;
        else:
            fmt = &#39;{0:&lt;2}{1[0]:14.8f}{1[1]:14.8f}{1[2]:14.8f}&#39;

    # Make number of atoms
    natoms = len(self.atoms[a1:a2])

    # Print the number of atoms if the mode calls for it
    if mode in (&#39;xyz&#39;, &#39;xyz_title&#39;, &#39;dimblock&#39;):
        print(natoms, file=file)

    # Print a space if &#39;xyz&#39;, or if &#39;xyz_title&#39; and there is no title
    if mode == &#39;xyz&#39; or (mode == &#39;xyz_title&#39; and (&#39;title&#39; not in self or not self.title)):
        print(file=file)
    # Print the title if &#39;xyz_title&#39; and there is a title
    elif mode == &#39;xyz_title&#39;:
        print(self.title, file=file)

    # Print the coordinates
    for i in range(a1, a2):
        if mode == &#39;num&#39;:
            print(fmt.format(num, self.atoms[i], self.coordinates[i]), file=file)
            num += 1
        else:
            if latex:
                print(fmt.format(self.atoms[i], self.coordinates[i], &#39;&amp;&#39;, r&#39;\\&#39;), file=file)
                print(r&#39; \hline&#39;, file=file)
            else:
                print(fmt.format(self.atoms[i], self.coordinates[i]), file=file)

    # Close the file if appropriate
    if closebool:
        file.close()</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.printOptical"><code class="name flex">
<span>def <span class="ident">printOptical</span></span>(<span>self, property='cross-section', pathlength=None, concentration=None, unit='au', absunit='angstroms')</span>
</code></dt>
<dd>
<div class="desc"><p>Prints a list of optical properties.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>property</code></strong> :&ensp;<code>{'absorption', 'absorptivitty', 'absorbance', 'transmittance'}</code></dt>
<dd>Specifies the optical property to print.
The choices are:<pre><code>- cross-section-&gt; :meth:&lt;code&gt;cross\_section&lt;/code&gt;
- absorptivitty -&gt; :meth:&lt;code&gt;molar\_absorptivitty&lt;/code&gt;
- absorbance -&gt; :meth:&lt;code&gt;absorbance&lt;/code&gt;
- transmittance -&gt; :meth:&lt;code&gt;transmittance&lt;/code&gt;
</code></pre>
</dd>
<dt><strong><code>pathlength</code></strong> :&ensp;<code>:obj:</code>float``</dt>
<dd>If the <code>property</code> is 'absorbance' or 'transmission',
you will need to specify the pathlength for Beer's
law in centimeters.</dd>
<dt><strong><code>concentration</code></strong> :&ensp;<code>:obj:</code>float``</dt>
<dd>If the <code>property</code> is 'absorbance' or 'transmission',
you will need to specify the concentration for Beer's
law in molarity.</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'au', 'ev', 'nm'}</code></dt>
<dd>This is the unit to print the frequencies. The options are:<pre><code>- 'au' -&gt; atomic units, Hartrees
- 'ev' -&gt; electron volts
- 'nm' -&gt; nanometers
</code></pre>
</dd>
<dt><strong><code>absunit</code></strong> :&ensp;<code>:obj:</code>str``</dt>
<dd>This is the unit that that absorption cross section
is calculated at.
See :meth:<code>cross_section</code>.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Invalid arguments given</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; fd = dim.quick_test(fd=True)
&gt;&gt;&gt; fd.printOptical(property='cross-section', unit='nm', absunit='cm')  # doctest: +NORMALIZE_WHITESPACE
Wavelength (nm)   Absorption Cross-Section (cm^2/molecule)
    354.2395                       3.24138E-02
    335.0936                       1.06350E-02
&gt;&gt;&gt; fd.printOptical(property='transmittance', pathlength=1.0, concentration=1e-6)  # doctest: +NORMALIZE_WHITESPACE
Pathlength=1.00 cm, Concentration=1.000E-06 M
 Frequency (a.u.)            Transmittance (unitless)
   1.2862E-01                      8.22670E-01
   1.3597E-01                      9.37962E-01
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printOptical(self, property=&#39;cross-section&#39;,
                 pathlength=None, concentration=None, unit=&#39;au&#39;,
                 absunit=&#39;angstroms&#39;):
    &#39;&#39;&#39;Prints a list of optical properties.

    Parameters
    ----------
    property : {&#39;absorption&#39;, &#39;absorptivitty&#39;, &#39;absorbance&#39;, &#39;transmittance&#39;}
        Specifies the optical property to print.
        The choices are:

            - cross-section-&gt; :meth:`cross_section`
            - absorptivitty -&gt; :meth:`molar_absorptivitty`
            - absorbance -&gt; :meth:`absorbance`
            - transmittance -&gt; :meth:`transmittance`

    pathlength : :obj:`float`
        If the `property` is &#39;absorbance&#39; or &#39;transmission&#39;,
        you will need to specify the pathlength for Beer&#39;s
        law in centimeters.
    concentration : :obj:`float`
        If the `property` is &#39;absorbance&#39; or &#39;transmission&#39;,
        you will need to specify the concentration for Beer&#39;s
        law in molarity.
    unit : {&#39;au&#39;, &#39;ev&#39;, &#39;nm&#39;}
        This is the unit to print the frequencies. The options are:

            - &#39;au&#39; -&gt; atomic units, Hartrees
            - &#39;ev&#39; -&gt; electron volts
            - &#39;nm&#39; -&gt; nanometers

    absunit : :obj:`str`
        This is the unit that that absorption cross section
        is calculated at.  See :meth:`cross_section`.

    Raises
    ------
    ValueError
        Invalid arguments given

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; fd = dim.quick_test(fd=True)
        &gt;&gt;&gt; fd.printOptical(property=&#39;cross-section&#39;, unit=&#39;nm&#39;, absunit=&#39;cm&#39;)  # doctest: +NORMALIZE_WHITESPACE
        Wavelength (nm)   Absorption Cross-Section (cm^2/molecule)
            354.2395                       3.24138E-02
            335.0936                       1.06350E-02
        &gt;&gt;&gt; fd.printOptical(property=&#39;transmittance&#39;, pathlength=1.0, concentration=1e-6)  # doctest: +NORMALIZE_WHITESPACE
        Pathlength=1.00 cm, Concentration=1.000E-06 M
         Frequency (a.u.)            Transmittance (unitless)
           1.2862E-01                      8.22670E-01
           1.3597E-01                      9.37962E-01

    &#39;&#39;&#39;

    # Prep for printing
    if property == &#39;cross-section&#39;:
        values = self.cross_section(unit=absunit)
        label = &#39;Absorption Cross-Section&#39;
        if absunit == &#39;angstroms&#39;:
            u = unicode(u&#39;\u212B^2/molecule&#39;)
        elif absunit == &#39;bohr&#39;:
            u = &#39;bohr^2/molecule&#39;
        elif absunit == &#39;nm&#39;:
            u = &#39;nm^2/molecule&#39;
        elif absunit == &#39;cm&#39;:
            u = &#39;cm^2/molecule&#39;
        elif absunit == &#39;m&#39;:
            u = &#39;m^2/molecule&#39;
    elif property == &#39;absorptivitty&#39;:
        values = self.molar_absorptivitty()
        label, u = &#39;Molar Absorptivitty&#39;, &#39;L mol^{-1} cm^{-1}&#39;
    elif property == &#39;absorbance&#39;:
        values = self.absorbance(pathlength, concentration)
        label, u = &#39;Absorbance&#39;, &#39;unitless&#39;
    elif property == &#39;transmittance&#39;:
        values = self.transmittance(pathlength, concentration)
        label, u = &#39;Transmittance&#39;, &#39;unitless&#39;
    else:
        raise ValueError(&#39;printOptical(): &#39;
                         &#39;invalid property (&#39;+property+&#39;)&#39;)

    # Choose frequency unit
    if not re.match(r&#39;au|ev|nm&#39;, unit, re.I):
        raise ValueError(&#39;printTensor() : Invalid unit: &#39;+unit)
    unit = {&#39;au&#39;: &#39;a.u.&#39;, &#39;ev&#39;: &#39;eV&#39;, &#39;nm&#39;: &#39;nm&#39;}[unit.lower()]
    etyp = {&#39;a.u.&#39;: &#39;Frequency&#39;,
            &#39;eV&#39;: &#39;Energy&#39;,
            &#39;nm&#39;: &#39;Wavelength&#39;}[unit]
    frequencies = {&#39;a.u.&#39;: self.e_frequencies,
                   &#39;eV&#39;: HART2EV(self.e_frequencies),
                   &#39;nm&#39;: HART2NM(self.e_frequencies)}[unit]

    # Title
    if property in (&#39;absorbance&#39;, &#39;transmittance&#39;):
        string = &#39;Pathlength={0:.2f} cm, Concentration={1:.3E} M&#39;
        print(string.format(pathlength, concentration))
    string = unicode(u&#39;{0:&gt;10} {1:&lt;6} {2:&gt;24} {3:&lt;20}&#39;)
    print(string.format(etyp, &#39;(&#39;+unit+&#39;)&#39;, label, &#39;(&#39;+u+&#39;)&#39;))

    # A format string
    if unit == &#39;a.u.&#39;:
        fmt = &#39;{0:^17.4E} {1:^45.5E}&#39;
    else:
        fmt = &#39;{0:^17.4f} {1:^45.5E}&#39;

    # Print the properties
    for freq, val in zip(frequencies, values):
        print(fmt.format(freq, val))</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.printTensor"><code class="name flex">
<span>def <span class="ident">printTensor</span></span>(<span>self, iso=False, ani=False, unit='au', p1=1, p2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Pretty print the polarizability tensor to standard output.
One
tensor is printed for each frequency.</p>
<p>If the calculation was FD,
then the real and imaginary tensors are printed alongside each other.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>iso</code></strong> :&ensp;<code>:obj:</code>bool``</dt>
<dd>Prints the isotropic polarizability along with the tensor</dd>
<dt><strong><code>ani</code></strong> :&ensp;<code>:obj:</code>bool``</dt>
<dd>Prints the anisotropic polarizability along with the tensor</dd>
<dt><strong><code>unit</code></strong> :&ensp;<code>{'au', 'ev', 'nm'}</code></dt>
<dd>Specifies the unit to print the frequency that corresponds
to each polarizability tensor.</dd>
<dt><strong><code>p1</code></strong> :&ensp;<code>:obj:</code>int``</dt>
<dd>The number of the lowest polarizability tensor to print</dd>
<dt><strong><code>a2</code></strong> :&ensp;<code>:obj:</code>int<code>, :obj:</code>None``</dt>
<dd>The number of the highest polarizability tensor to print.
If given :obj:<code>None</code>, the number of the last atom is used</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code><a title="dimpy.dimclass.DIMError" href="#dimpy.dimclass.DIMError">DIMError</a></code></dt>
<dd>No polarizabilities were collected.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; static.printTensor(iso=True, ani=True, unit='ev')
&lt;BLANKLINE&gt;
Static Polarizability
                X               Y               Z
   X          71.324           0.000           0.000
   Y           0.000          71.324           0.000
   Z           0.000           0.000          93.755
&lt;BLANKLINE&gt;
ISOTROPIC PART    =       78.801
ANISOTROPIC PART  =       22.431
&lt;BLANKLINE&gt;
&gt;&gt;&gt; fd = dim.quick_test(fd=True)
&gt;&gt;&gt; fd.printTensor(iso=True, ani=True, unit='ev')
&lt;BLANKLINE&gt;
FD Polarizability: Energy 3.50001 eV
                               Real                                                Imaginary
                X               Y               Z                      X               Y               Z
   X         200.794           0.000           0.000      X         264.060           0.000           0.000
   Y           0.000         200.794           0.000      Y           0.000         264.060           0.000
   Z           0.000           0.000        -188.906      Z           0.000           0.000         296.316
&lt;BLANKLINE&gt;
ISOTROPIC PART    =       70.894 + 274.812j
ANISOTROPIC PART  =      391.033
&lt;BLANKLINE&gt;
FD Polarizability: Energy 3.69999 eV
                               Real                                                Imaginary
                X               Y               Z                      X               Y               Z
   X         -81.283           0.000           0.000      X          99.260           0.000           0.000
   Y           0.000         -81.283           0.000      Y           0.000          99.260           0.000
   Z           0.000           0.000         -78.875      Z           0.000           0.000          57.359
&lt;BLANKLINE&gt;
ISOTROPIC PART    =     -80.4803 +  85.293j
ANISOTROPIC PART  =      41.9701
&lt;BLANKLINE&gt;
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def printTensor(self, iso=False, ani=False, unit=&#39;au&#39;, p1=1, p2=None):
    &#39;&#39;&#39;\
    Pretty print the polarizability tensor to standard output.  One
    tensor is printed for each frequency.

    If the calculation was FD,
    then the real and imaginary tensors are printed alongside each other.

    Parameters
    ----------
    iso : :obj:`bool`
        Prints the isotropic polarizability along with the tensor
    ani : :obj:`bool`
        Prints the anisotropic polarizability along with the tensor
    unit : {&#39;au&#39;, &#39;ev&#39;, &#39;nm&#39;}
        Specifies the unit to print the frequency that corresponds
        to each polarizability tensor.
    p1 : :obj:`int`
        The number of the lowest polarizability tensor to print
    a2 : :obj:`int`, :obj:`None`
        The number of the highest polarizability tensor to print.
        If given :obj:`None`, the number of the last atom is used

    Raises
    ------
    DIMError
        No polarizabilities were collected.

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; static.printTensor(iso=True, ani=True, unit=&#39;ev&#39;)
        &lt;BLANKLINE&gt;
        Static Polarizability
                        X               Y               Z
           X          71.324           0.000           0.000
           Y           0.000          71.324           0.000
           Z           0.000           0.000          93.755
        &lt;BLANKLINE&gt;
        ISOTROPIC PART    =       78.801
        ANISOTROPIC PART  =       22.431
        &lt;BLANKLINE&gt;
        &gt;&gt;&gt; fd = dim.quick_test(fd=True)
        &gt;&gt;&gt; fd.printTensor(iso=True, ani=True, unit=&#39;ev&#39;)
        &lt;BLANKLINE&gt;
        FD Polarizability: Energy 3.50001 eV
                                       Real                                                Imaginary
                        X               Y               Z                      X               Y               Z
           X         200.794           0.000           0.000      X         264.060           0.000           0.000
           Y           0.000         200.794           0.000      Y           0.000         264.060           0.000
           Z           0.000           0.000        -188.906      Z           0.000           0.000         296.316
        &lt;BLANKLINE&gt;
        ISOTROPIC PART    =       70.894 + 274.812j
        ANISOTROPIC PART  =      391.033
        &lt;BLANKLINE&gt;
        FD Polarizability: Energy 3.69999 eV
                                       Real                                                Imaginary
                        X               Y               Z                      X               Y               Z
           X         -81.283           0.000           0.000      X          99.260           0.000           0.000
           Y           0.000         -81.283           0.000      Y           0.000          99.260           0.000
           Z           0.000           0.000         -78.875      Z           0.000           0.000          57.359
        &lt;BLANKLINE&gt;
        ISOTROPIC PART    =     -80.4803 +  85.293j
        ANISOTROPIC PART  =      41.9701
        &lt;BLANKLINE&gt;

    &#39;&#39;&#39;
    if &#39;polarizability&#39; not in self:
        raise ValueError(&#39;printTensor(): &#39;
                         &#39;No polarizabilities were collected.&#39;)
    # Convert pol number to index
    p1 -= 1
    # Default to all.
    if p2 is None:
        p2 = self.npol

    # Set the unit and energy type
    if not re.match(r&#39;au|ev|nm&#39;, unit, re.I):
        raise ValueError(&#39;printTensor() : Invalid unit: &#39;+unit)
    else:
        unit = {&#39;au&#39;: &#39;a.u.&#39;, &#39;ev&#39;: &#39;eV&#39;, &#39;nm&#39;: &#39;nm&#39;}[unit.lower()]
        etyp = {&#39;a.u.&#39;: &#39;Frequency&#39;,
                &#39;eV&#39;: &#39;Energy&#39;,
                &#39;nm&#39;: &#39;Wavelength&#39;}[unit]

    # Set the tensor
    prop = &#39;Polarizability&#39;

    # Start the formatting of the label
    if &#39;RAMAN&#39; in self.calctype:
        lbl = self.v_frequencies
    else:
        with errstate(divide=&#39;ignore&#39;):
            lbl = {&#39;a.u.&#39;: self.e_frequencies,
                   &#39;eV&#39;: HART2EV(self.e_frequencies),
                   &#39;nm&#39;: HART2NM(self.e_frequencies)}[unit]

    # Diagonalized or not
    d = &#39;, Diagonalized&#39; if self._diagonalized else &#39;&#39;

    # Print selected tensors in class
    print()
    for n in range(p1, p2):

        t = self.polarizability[n]
        r = t.real
        i = t.imag

        # Prints out the proper heading depending on the energy type
        # and the unit.
        # First, make the number at most 7 digits with &#39;good&#39; formatting
        # Strip off whitespace
        s = &#39;{0:7g}&#39;.format(lbl[n]).strip()
        # Now place this number in the heading
        head = &#39;FD {4}: {0} {1} {2}{3}&#39;.format(etyp, s, unit, d, prop)
        # Replace the heading if this was a static calculation
        if s == &#39;0&#39;:
            head = &#39;Static {0}&#39;.format(prop)
        print(head)

        # Pretty-print the tensor
        if self.calctype == &#39;FD&#39;:
            label = &#39;{0:&gt;35}{1:35}{2:&gt;22}&#39;
            head = &#39;{0:&gt;17}{1:&gt;16}{2:&gt;16}{3:6}{0:&gt;17}{1:&gt;16}{2:&gt;16}&#39;
            fr = &#39;{0:&gt;4}{1[0]:16.3f}{1[1]:16.3f}{1[2]:16.3f}  &#39;
            fi = &#39;{0:&gt;4}{1[0]:16.3f}{1[1]:16.3f}{1[2]:16.3f}&#39;
            print(label.format(&#39;Real&#39;, &#39;&#39;, &#39;Imaginary&#39;))
            print(head.format(&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;, &#39;&#39;))
            print(fr.format(&#39;X&#39;, r[0, :]), fi.format(&#39;X&#39;, i[0, :]))
            print(fr.format(&#39;Y&#39;, r[1, :]), fi.format(&#39;Y&#39;, i[1, :]))
            print(fr.format(&#39;Z&#39;, r[2, :]), fi.format(&#39;Z&#39;, i[2, :]))
        else:
            head = &#39;{0:&gt;17}{1:&gt;16}{2:&gt;16}&#39;
            f = &#39;{0:&gt;4}{1[0]:16.3f}{1[1]:16.3f}{1[2]:16.3f}&#39;
            print(head.format(&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;))
            print(f.format(&#39;X&#39;, r[0, :]))
            print(f.format(&#39;Y&#39;, r[1, :]))
            print(f.format(&#39;Z&#39;, r[2, :]))

        # Add the invariants at the end if requested
        if iso or ani:
            print()
        if iso:
            print(&#39;ISOTROPIC PART    = &#39;, end=&#39;&#39;)
            iso = self.isotropic[n]
            if &#39;FD&#39; in self.calctype:
                print(&#39;{0:12g} + {1:7g}j&#39;.format(iso.real, iso.imag))
            else:
                print(&#39;{0:12g}&#39;.format(iso))
        if ani:
            ani = self.anisotropic2[n]
            print(&#39;ANISOTROPIC PART  = {0:12g}&#39;.format(sqrt(ani)))

        print()</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.radii"><code class="name flex">
<span>def <span class="ident">radii</span></span>(<span>self, set)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the radii for each atom in the nanoparticle.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>set</code></strong> :&ensp;<code>{'vis', 'vdw'}</code></dt>
<dd>Specifies from which set of data you wish
to collect the radii.
The options are:<pre><code>-vis: These radii are good for molecular visualizations but are not physical
-vdw: These use the van Der Waals radii and are intended to be physical, however not all elements are available.
</code></pre>
</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>radii : :obj:<code>numpy.ndarray</code> of length <code>natoms</code>.
The radii for each atom</p>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; static.atoms
array(['Ag', 'Ag'], 
      dtype='|S2')
&gt;&gt;&gt; static.radii('vis')
array([ 1.44,  1.44])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def radii(self, set):
    &#39;&#39;&#39;\
    Returns the radii for each atom in the nanoparticle.

    Parameters
    ----------
    set : {&#39;vis&#39;, &#39;vdw&#39;}
        Specifies from which set of data you wish
        to collect the radii.  The options are:

            -vis: These radii are good for molecular visualizations but are not physical
            -vdw: These use the van Der Waals radii and are intended to be physical, however not all elements are available.

    Returns
    -------
    radii : :obj:`numpy.ndarray` of length ``natoms``.
        The radii for each atom

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; static.atoms
        array([&#39;Ag&#39;, &#39;Ag&#39;], 
              dtype=&#39;|S2&#39;)
        &gt;&gt;&gt; static.radii(&#39;vis&#39;)
        array([ 1.44,  1.44])

    &#39;&#39;&#39;

    # Find radii for each atom
    rad = zeros(self.natoms)
    for i in xrange(self.natoms):
        rad[i] = atomic_radius(self.atoms[i], set)
    return rad</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.rotate_coordinates"><code class="name flex">
<span>def <span class="ident">rotate_coordinates</span></span>(<span>self, rotmat=None, angle=None, dir=None, rad=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotates the coordinates.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>rotmat</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code><code>of &lt;/code&gt;shape 3 x 3</code></dt>
<dd>The rotation matrix to use to rotate the nanoparticle.
Mutually exclusive with the <code>angle</code> parameter.</dd>
<dt><strong><code>angle</code></strong> :&ensp;<code>:obj:</code>float<code>, :obj:</code>list<code>of `:obj:`float</code></dt>
<dd>An angle by which to rotate the coordinates.
If given
as a :obj:<code>list</code>, the coordinates are rotated by each
angle in the order they are given.
Mutually exclusive with the <code>rotmat</code> parameter.</dd>
<dt><strong><code>dir</code></strong> :&ensp;<code>{'X', 'Y', 'Z'}</code></dt>
<dd>The direction in which to rotate the coordinates
for a given angle. Required when the <code>angle</code> parameter
is given. If <code>angle</code> is given as a :obj:<code>list</code>, <code>dir</code>
must be a :obj:<code>list</code> of the same length</dd>
<dt><strong><code>rad</code></strong> :&ensp;<code>:obj:</code>bool``</dt>
<dd>Tells if the angle is in radians or note.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Invalid arguments are given</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; import numpy
&gt;&gt;&gt; np1 = dim.quick_test()
&gt;&gt;&gt; np1.coordinates
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  4.]])
&gt;&gt;&gt; np1.rotate_coordinates(angle=90, dir='X')
&gt;&gt;&gt; numpy.around(np1.coordinates)
array([[ 0.,  0.,  0.],
       [ 0.,  4.,  0.]])
&gt;&gt;&gt; np2 = dim.quick_test()
&gt;&gt;&gt; np2.rotate_coordinates(angle=[45, 45], dir=['X', 'Z'])
&gt;&gt;&gt; numpy.around(np2.coordinates, decimals=5)
array([[ 0.     ,  0.     ,  0.     ],
       [ 0.     ,  2.82843,  2.82843]])
&gt;&gt;&gt; np3 = dim.quick_test()
&gt;&gt;&gt; np3.rotate_coordinates(rotmat=numpy.array([[0.5, 1.0, 1.0],
...                                            [1.0, 0.5, 0.0],
...                                            [1.0, 0.0, 0.5]]))
&gt;&gt;&gt; numpy.around(np3.coordinates, decimals=5)
array([[ 0.,  0.,  0.],
       [ 4.,  0.,  2.]])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def rotate_coordinates(self, rotmat=None, angle=None, dir=None, rad=False):
    &#39;&#39;&#39;Rotates the coordinates.

    Parameters
    ----------
    rotmat : :obj:`numpy.ndarray` of shape 3 x 3
        The rotation matrix to use to rotate the nanoparticle.
        Mutually exclusive with the `angle` parameter.
    angle : :obj:`float`, :obj:`list` of :obj:`float`
        An angle by which to rotate the coordinates.  If given
        as a :obj:`list`, the coordinates are rotated by each
        angle in the order they are given.
        Mutually exclusive with the `rotmat` parameter.
    dir : {&#39;X&#39;, &#39;Y&#39;, &#39;Z&#39;}
        The direction in which to rotate the coordinates
        for a given angle. Required when the `angle` parameter
        is given. If `angle` is given as a :obj:`list`, `dir`
        must be a :obj:`list` of the same length
    rad : :obj:`bool`
        Tells if the angle is in radians or note.

    Raises
    ------
    ValueError
        Invalid arguments are given

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; import numpy
        &gt;&gt;&gt; np1 = dim.quick_test()
        &gt;&gt;&gt; np1.coordinates
        array([[ 0.,  0.,  0.],
               [ 0.,  0.,  4.]])
        &gt;&gt;&gt; np1.rotate_coordinates(angle=90, dir=&#39;X&#39;)
        &gt;&gt;&gt; numpy.around(np1.coordinates)
        array([[ 0.,  0.,  0.],
               [ 0.,  4.,  0.]])
        &gt;&gt;&gt; np2 = dim.quick_test()
        &gt;&gt;&gt; np2.rotate_coordinates(angle=[45, 45], dir=[&#39;X&#39;, &#39;Z&#39;])
        &gt;&gt;&gt; numpy.around(np2.coordinates, decimals=5)
        array([[ 0.     ,  0.     ,  0.     ],
               [ 0.     ,  2.82843,  2.82843]])
        &gt;&gt;&gt; np3 = dim.quick_test()
        &gt;&gt;&gt; np3.rotate_coordinates(rotmat=numpy.array([[0.5, 1.0, 1.0],
        ...                                            [1.0, 0.5, 0.0],
        ...                                            [1.0, 0.0, 0.5]]))
        &gt;&gt;&gt; numpy.around(np3.coordinates, decimals=5)
        array([[ 0.,  0.,  0.],
               [ 4.,  0.,  2.]])

    &#39;&#39;&#39;

    if rotmat is None and angle is None:
        ValueError(&#34;rotate_coordinates(): &#34;
                   &#34;Must choose one of &#39;rotmat&#39; or &#39;angle&#39;&#34;)
    if rotmat is not None and angle is not None:
        ValueError(&#34;rotate_coordinates(): &#34;
                   &#34;Must choose only one of &#39;rotmat&#39; or &#39;angle&#39;&#34;)

    # Create matrix if not given explicitly
    # Create a general 3-D rotation
    if rotmat is None:
        if dir is None:
            raise ValueError(&#34;rotate_coordinates(): &#34;
                             &#34;&#39;dir&#39; must not be empty with &#39;angle&#39;&#34;)
        if isinstance(angle, list) and not isinstance(dir, list):
            raise ValueError(&#34;rotate_coordinates(): &#34;
                             &#34;&#39;angle&#39; and &#39;dir&#39; must both be either &#34;
                             &#34;a &#39;list&#39; or &#39;str&#39;&#34;)
        if not isinstance(angle, list) and isinstance(dir, list):
            raise ValueError(&#34;rotate_coordinates(): &#34;
                             &#34;&#39;angle&#39; and &#39;dir&#39; must both be either &#34;
                             &#34;a &#39;list&#39; or &#39;str&#39;&#34;)
        # Make sure lists are the same length, and turn non-list in to list
        if isinstance(angle, list):
            if len(angle) != len(dir):
                raise ValueError(&#34;rotate_coordinates(): &#34;
                                 &#34;&#39;angle&#39; and &#39;dir&#39; must be the same length&#34;)
        else:
            angle = [angle]
            dir = [dir]

        # Generate the general rotation matrix
        rotmat = eye(3)
        for a, d in zip(angle, dir):
            if not rad:
                a = radians(a)
            c = cos(a)
            s = sin(a)
            if d.lower() == &#39;x&#39;:
                temp = array([[ 1,  0,  0 ],
                              [ 0,  c, -s ],
                              [ 0,  s,  c ]], dtype=float)
            elif d.lower() == &#39;y&#39;:
                temp = array([[ c,  0,  s ],
                              [ 0,  1,  0 ],
                              [-s,  0,  c ]], dtype=float)
            elif d.lower() == &#39;z&#39;:
                temp = array([[ c, -s,  0 ],
                              [ s,  c,  0 ],
                              [ 0,  0,  1 ]], dtype=float)
            else:
                raise ValueError(&#34;Unknown value for &#39;dir&#39;: &#34;+str(d))

            # Create the rotmat in rotation order. Not that this is
            # backwards from what you would expect because internally the
            # rotation is done with the coordinates first.
            rotmat = dot(temp, rotmat)

    # Rotate. Use fast MKL routine to do so
    #self.coordinates = rotate(rotmat, self.coordinates)
    self.coordinates = dot(self.coordinates, rotmat)</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.shift_to_origin"><code class="name flex">
<span>def <span class="ident">shift_to_origin</span></span>(<span>self, type='geometrical')</span>
</code></dt>
<dd>
<div class="desc"><p>Shifts the coordinates in place so that the center of the
molecule is at the origin.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>type</code></strong> :&ensp;<code>{'geometrical', 'center-of-mass'}</code></dt>
<dd>Determines the center type.
See :meth:<code>find_center</code>.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; static.coordinates
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  4.]])
&gt;&gt;&gt; static.shift_to_origin()
&gt;&gt;&gt; static.coordinates
array([[ 0.,  0., -2.],
       [ 0.,  0.,  2.]])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def shift_to_origin(self, type=&#39;geometrical&#39;):
    &#39;&#39;&#39;\
    Shifts the coordinates in place so that the center of the
    molecule is at the origin.

    Parameters
    ----------
    type : {&#39;geometrical&#39;, &#39;center-of-mass&#39;}
        Determines the center type.  See :meth:`find_center`.

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; static.coordinates
        array([[ 0.,  0.,  0.],
               [ 0.,  0.,  4.]])
        &gt;&gt;&gt; static.shift_to_origin()
        &gt;&gt;&gt; static.coordinates
        array([[ 0.,  0., -2.],
               [ 0.,  0.,  2.]])

    &#39;&#39;&#39;
    self.translate_coordinates(-self.find_center(type))</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.translate_coordinates"><code class="name flex">
<span>def <span class="ident">translate_coordinates</span></span>(<span>self, transvec)</span>
</code></dt>
<dd>
<div class="desc"><p>Translates the coordinates in place.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>transvec</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code><code>of &lt;/code&gt;length 3</code></dt>
<dd>The translation vector by which to translate the coordinates</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; static = dim.quick_test()
&gt;&gt;&gt; static.coordinates
array([[ 0.,  0.,  0.],
       [ 0.,  0.,  4.]])
&gt;&gt;&gt; static.translate_coordinates([3.0, 1.0, 0.0])
&gt;&gt;&gt; static.coordinates
array([[ 3.,  1.,  0.],
       [ 3.,  1.,  4.]])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def translate_coordinates(self, transvec):
    &#39;&#39;&#39;\
    Translates the coordinates in place.

    Parameters
    ----------
    transvec : :obj:`numpy.ndarray` of length 3
        The translation vector by which to translate the coordinates

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; static = dim.quick_test()
        &gt;&gt;&gt; static.coordinates
        array([[ 0.,  0.,  0.],
               [ 0.,  0.,  4.]])
        &gt;&gt;&gt; static.translate_coordinates([3.0, 1.0, 0.0])
        &gt;&gt;&gt; static.coordinates
        array([[ 3.,  1.,  0.],
               [ 3.,  1.,  4.]])

    &#39;&#39;&#39;
    self.coordinates += transvec</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.transmittance"><code class="name flex">
<span>def <span class="ident">transmittance</span></span>(<span>self, pathlength, concentration)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the transmittance from the absorbance on a scale
from 0 to 1.
The user must convert to percent if she so desires.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pathlength</code></strong> :&ensp;<code>:obj:</code>float``</dt>
<dd>The pathlength in centimeters of the light</dd>
<dt><strong><code>concentration</code></strong> :&ensp;<code>:obj:</code>float``</dt>
<dd>The solution concentration in molarity</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>transmittance</code></strong> :&ensp;<code>:obj:</code>numpy.ndarray<code>of `length :attr:`~.npol</code></dt>
<dd>The normalized transmittance for each frequency in</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>Invalid arguments given</dd>
<dt><code><a title="dimpy.dimclass.DIMError" href="#dimpy.dimclass.DIMError">DIMError</a></code></dt>
<dd>Not an FD calculation</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; fd = dim.quick_test(fd=True)
&gt;&gt;&gt; fd.transmittance(1.5, 1.5e-6)
array([ 0.64455141,  0.86579899])
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def transmittance(self, pathlength, concentration):
    &#39;&#39;&#39;\
    Calculates the transmittance from the absorbance on a scale
    from 0 to 1.  The user must convert to percent if she so desires.

    Parameters
    ----------
    pathlength : :obj:`float`
        The pathlength in centimeters of the light
    concentration : :obj:`float`
        The solution concentration in molarity

    Returns
    -------
    transmittance : :obj:`numpy.ndarray` of length :attr:`~.npol`
        The normalized transmittance for each frequency in

    Raises
    ------
    ValueError
        Invalid arguments given
    DIMError
        Not an FD calculation

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; fd = dim.quick_test(fd=True)
        &gt;&gt;&gt; fd.transmittance(1.5, 1.5e-6)
        array([ 0.64455141,  0.86579899])

    &#39;&#39;&#39;
    absorb = self.absorbance(pathlength, concentration)
    return power(10, -absorb)</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.writeCoords"><code class="name flex">
<span>def <span class="ident">writeCoords</span></span>(<span>self, a1=1, a2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>This is a shortcut for
:func:<code>printCoords(mode='xyz', file='xyz') &lt;printCoords&gt;</code>.</p>
<p>This will write the coordinates to a .xyz file based on the
name in the filename attribute.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writeCoords(self, a1=1, a2=None):
    &#39;&#39;&#39;This is a shortcut for
    :func:`printCoords(mode=&#39;xyz&#39;, file=&#39;xyz&#39;) &lt;printCoords&gt;`.

    This will write the coordinates to a .xyz file based on the
    name in the filename attribute.

    &#39;&#39;&#39;
    self.printCoords(mode=&#39;xyz&#39;, file=&#39;xyz&#39;, a1=a1, a2=a2)</code></pre>
</details>
</dd>
<dt id="dimpy.dimclass.DIM.writePDB"><code class="name flex">
<span>def <span class="ident">writePDB</span></span>(<span>self, a1=1, a2=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Writes the coordinates to a .pdb file with the same name
as the current file.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>a1</code></strong> :&ensp;<code>:obj:</code>int``</dt>
<dd>The number of the lowest atom to print</dd>
<dt><strong><code>a2</code></strong> :&ensp;<code>:obj:</code>int<code>, :obj:</code>None``</dt>
<dd>The number of the highest atom to print.
If given :obj:<code>None</code>, the number of the last atom is used</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def writePDB(self, a1=1, a2=None):
    &#39;&#39;&#39;Writes the coordinates to a .pdb file with the same name
    as the current file.

    Parameters
    ----------
    a1 : :obj:`int`
        The number of the lowest atom to print
    a2 : :obj:`int`, :obj:`None`
        The number of the highest atom to print.
        If given :obj:`None`, the number of the last atom is used

    &#39;&#39;&#39;

    # Define title format
    ft = &#39;CMPND  {0}&#39;
    # Define coordinate format
    fc = (&#39;HETATM{0:&gt;5d}{1:&gt;3}   LIG     1    &#39;
          &#39;{2[0]:&gt;8.3f}{2[1]:&gt;8.3f}{2[2]:&gt;8.3f}  1.00  0.00          &#39;
          &#39;{1:&gt;2}  &#39;)
    # Define bond format
    fb = &#39;CONECT{0:&gt;5d}&#39;

    # Convert atom number to index
    a1 -= 1
    # Default to all.
    if a2 is None:
        a2 = len(self.atoms)

    # Open the file as pdb with same name
    filename = &#39;.&#39;.join([os.path.splitext(self.filename)[0], &#39;pdb&#39;])
    with open(filename, &#39;w&#39;) as fl:

        # pbd Starts with some info.  Give the title if there is one
        if &#39;title&#39; in self and self.title:
            title = ft.format(&#39;MOLECULE: &#39;+self.title)
        else:
            title = ft.format(&#39;UNNAMED&#39;)
        print(title, file=fl)

        # Place the coordinates in the file
        i = 1
        for atom, coord in zip(self.atoms[a1:a2], self.coordinates[a1:a2]):
            print(fc.format(i, atom, coord), file=fl)
            i += 1

        # Place the bonds in the file.  The bonding is redundant, so each
        # atom must be specified and bonds will be listed mutlitple times.
        for i in xrange(self.natoms):

            # Skip atoms we don&#39;t want to show a bond to
            if i &lt; a1 or i &gt; a2:
                continue

            # Print the bonding keyword
            print(fb.format(i+1), end=&#39;&#39;, file=fl)

            # Find everywhere that this atoms is in the first column
            indx = where(self.bonds[:, 0] == i)[0]

            # Print off all atoms this one is bonded to
            for j in indx:
                # Skip atoms we don&#39;t want to show a bond to
                if self.bonds[j, 1] &lt; a1 or self.bonds[j, 1] &gt; a2:
                    continue
                print(&#39;{0:&gt;5d}&#39;.format(self.bonds[j, 1]+1), end=&#39;&#39;, file=fl)

            # Repeat for the second column
            indx = where(self.bonds[:, 1] == i)[0]
            for j in indx:
                # Skip atoms we don&#39;t want to show a bond to
                if self.bonds[j, 0] &lt; a1 or self.bonds[j, 0] &gt; a2:
                    continue
                print(&#39;{0:&gt;5d}&#39;.format(self.bonds[j, 0]+1), end=&#39;&#39;, file=fl)

            # New line
            print(file=fl)

        # End the file
        print(&#39;END   &#39;, file=fl)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dimpy.dimclass.DIMError"><code class="flex name class">
<span>class <span class="ident">DIMError</span></span>
<span>(</span><span>msg)</span>
</code></dt>
<dd>
<div class="desc"><p>Error class for DIM errors.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>msg</code></strong> :&ensp;<code>:obj:</code>str``</dt>
<dd>The message to give to the user.</dd>
</dl>
<h2 id="examples">Examples</h2>
<pre><code>&gt;&gt;&gt; import dim
&gt;&gt;&gt; try:
...     filedata = dim.quick_test('file.dim')
... except dim.DIMError as d:
...     sys.exit(str(d))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class DIMError(Exception):
    &#39;&#39;&#39;Error class for DIM errors.

    Parameters
    ----------
    msg : :obj:`str`
        The message to give to the user.

    Examples
    --------

        &gt;&gt;&gt; import dim
        &gt;&gt;&gt; try:
        ...     filedata = dim.quick_test(&#39;file.dim&#39;)
        ... except dim.DIMError as d:
        ...     sys.exit(str(d))

    &#39;&#39;&#39;
    def __init__(self, msg):
        self.msg = msg

    def __str__(self):
        return self.msg</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dimpy" href="index.html">dimpy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dimpy.dimclass.DIM" href="#dimpy.dimclass.DIM">DIM</a></code></h4>
<ul class="">
<li><code><a title="dimpy.dimclass.DIM.absorb" href="#dimpy.dimclass.DIM.absorb">absorb</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.absorbance" href="#dimpy.dimclass.DIM.absorbance">absorbance</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.anisotropic2" href="#dimpy.dimclass.DIM.anisotropic2">anisotropic2</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.bonds" href="#dimpy.dimclass.DIM.bonds">bonds</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.collect" href="#dimpy.dimclass.DIM.collect">collect</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.copy" href="#dimpy.dimclass.DIM.copy">copy</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.cross_section" href="#dimpy.dimclass.DIM.cross_section">cross_section</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.empty" href="#dimpy.dimclass.DIM.empty">empty</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.find_center" href="#dimpy.dimclass.DIM.find_center">find_center</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.isotropic" href="#dimpy.dimclass.DIM.isotropic">isotropic</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.join" href="#dimpy.dimclass.DIM.join">join</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.masses" href="#dimpy.dimclass.DIM.masses">masses</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.maxdist" href="#dimpy.dimclass.DIM.maxdist">maxdist</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.mindist" href="#dimpy.dimclass.DIM.mindist">mindist</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.molar_absorptivitty" href="#dimpy.dimclass.DIM.molar_absorptivitty">molar_absorptivitty</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.molecular_mass" href="#dimpy.dimclass.DIM.molecular_mass">molecular_mass</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.order_coords" href="#dimpy.dimclass.DIM.order_coords">order_coords</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.pol_diagonalize" href="#dimpy.dimclass.DIM.pol_diagonalize">pol_diagonalize</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.pol_minmax" href="#dimpy.dimclass.DIM.pol_minmax">pol_minmax</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.printCoords" href="#dimpy.dimclass.DIM.printCoords">printCoords</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.printOptical" href="#dimpy.dimclass.DIM.printOptical">printOptical</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.printTensor" href="#dimpy.dimclass.DIM.printTensor">printTensor</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.radii" href="#dimpy.dimclass.DIM.radii">radii</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.rotate_coordinates" href="#dimpy.dimclass.DIM.rotate_coordinates">rotate_coordinates</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.shift_to_origin" href="#dimpy.dimclass.DIM.shift_to_origin">shift_to_origin</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.tensor_anisotropic2" href="#dimpy.dimclass.DIM.tensor_anisotropic2">tensor_anisotropic2</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.tensor_isotropic" href="#dimpy.dimclass.DIM.tensor_isotropic">tensor_isotropic</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.translate_coordinates" href="#dimpy.dimclass.DIM.translate_coordinates">translate_coordinates</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.transmittance" href="#dimpy.dimclass.DIM.transmittance">transmittance</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.writeCoords" href="#dimpy.dimclass.DIM.writeCoords">writeCoords</a></code></li>
<li><code><a title="dimpy.dimclass.DIM.writePDB" href="#dimpy.dimclass.DIM.writePDB">writePDB</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dimpy.dimclass.DIMError" href="#dimpy.dimclass.DIMError">DIMError</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>